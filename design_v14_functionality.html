﻿<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- iOS PWA Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MOZI">
    <link rel="apple-touch-icon" id="appleTouchIcon" sizes="180x180" href="/mozi_icon_180.png">
    <link rel="apple-touch-icon-precomposed" id="appleTouchIconPre" sizes="180x180" href="/mozi_icon_180.png">
    <link rel="icon" type="image/svg+xml" href="./icon.svg?v=9">
    <meta name="theme-color" content="#141218">
    <link rel="manifest" href="/manifest.json">

    <!-- Libraries -->
    <script src="./libs/jszip.min.js"></script>
    <script src="./libs/epub.min.js"></script>

    <title>MOZI</title>
    <link rel="stylesheet" href="./ReaderStyles.css">
</head>
<body>

    <div class="phone-frame">
        <!-- Status Bar (Hidden on Mobile) -->
        <div class="status-bar">
            <span>9:48</span>
            <div class="reader-status-icons">
                <svg width="18" height="12" viewBox="0 0 18 12" fill="currentColor"><path d="M16 4h-2V2h2v2zm0 4h-2V6h2v2zm0 4h-2v-2h2v2zM2 12h2V0H2v12zm4 0h2V4H6v8zm4 0h2V6h-2v6z"/></svg>
                <svg width="24" height="12" viewBox="0 0 24 12" fill="currentColor"><path d="M20 3.5V0H0v12h20V8.5h1.5V11H24V1h-2.5v2.5H20zM18 10H2V2h16v8z"/></svg>
            </div>
        </div>

        <!-- Hidden File Input -->
        <input type="file" id="fileInput" hidden accept=".txt,.epub,.pdf">

        <!-- VIEW: BOOKSHELF -->
        <div id="view-bookshelf" class="view-section active">
            <div class="header-container">
                <div class="header-glow"></div>
                <div class="header-top-row">
                    <span class="date-display">WEDNESDAY, JAN 28</span>
                    <div class="avatar-btn" onclick="switchTab('me')">
                        <div class="reader-avatar-placeholder">U</div>
                    </div>
                </div>
                <h1 class="header-title">书架</h1>
                <div class="header-subtitle">最近阅读 3 本书</div>
            </div>

            <div class="scroll-content">
                <!-- Quick Actions -->
                <div class="quick-actions">
                    <div class="action-card" onclick="triggerImport()">
                        <div class="action-icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg></div>
                        <span class="action-text">导入书籍</span>
                    </div>
                    <div class="action-card" onclick="alert('Wi-Fi 传书功能演示')">
                        <div class="action-icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>
                        <span class="action-text">Wi-Fi 传书</span>
                    </div>
                </div>

                <div class="section-header">
                    <span class="section-title">我的书籍</span>
                    <button class="view-toggle-btn" onclick="toggleView()" id="toggleBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                        <span>视图</span>
                    </button>
                </div>

                <!-- Books Container -->
                <div class="books-container" id="booksContainer">
                    <!-- Book 1 -->
                    <div class="book-card" onclick="openBook(this)">
                        <div class="book-cover cover-1">
                            <div class="cover-text">三体：死神永生</div>
                            <div class="reading-dot"></div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">三体：死神永生</div>
                            <div class="book-meta"><span>刘慈欣</span><span class="format-badge">EPUB</span></div>
                            <div class="progress-container">
                                <div class="progress-track"><div class="progress-fill progress-fill--p45"></div></div>
                                <span class="progress-text">45%</span>
                            </div>
                            <div class="book-stats"><span>52.4万字</span><button class="edit-btn" onclick="event.stopPropagation(); editBook(this)">编辑</button></div>
                        </div>
                    </div>
                    <!-- Book 2 -->
                    <div class="book-card" onclick="openBook(this)">
                        <div class="book-cover cover-2">
                            <div class="cover-text">Thinking Fast</div>
                            <div class="reading-dot"></div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">Thinking, Fast and Slow</div>
                            <div class="book-meta"><span>Daniel Kahneman</span><span class="format-badge">PDF</span></div>
                            <div class="progress-container">
                                <div class="progress-track"><div class="progress-fill progress-fill--p12"></div></div>
                                <span class="progress-text">12%</span>
                            </div>
                            <div class="book-stats"><span>49.9万字</span><button class="edit-btn" onclick="event.stopPropagation(); editBook(this)">编辑</button></div>
                        </div>
                    </div>
                    <!-- Book 3 -->
                    <div class="book-card" onclick="openBook(this)">
                        <div class="book-cover cover-3">
                            <div class="cover-text">Steve Jobs</div>
                            <div class="reading-dot"></div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">Steve Jobs</div>
                            <div class="book-meta"><span>Walter Isaacson</span><span class="format-badge">TXT</span></div>
                            <div class="progress-container">
                                <div class="progress-track"><div class="progress-fill progress-fill--p88"></div></div>
                                <span class="progress-text">88%</span>
                            </div>
                            <div class="book-stats"><span>65.1万字</span><button class="edit-btn" onclick="event.stopPropagation(); editBook(this)">编辑</button></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- VIEW: DISCOVER -->
        <div id="view-discover" class="view-section hidden">
            <div class="header-container">
                <div class="header-glow"></div>
                <h1 class="header-title">发现</h1>
                <div class="header-subtitle">探索百万好书</div>
            </div>
            <div class="scroll-content">
                <div class="search-container">
                    <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    <input type="text" class="search-input" id="searchInput" placeholder="搜索书名、作者..." onkeypress="handleSearch(event)">
                </div>
                
                <div class="section-header reader-section-header--flush">
                    <span class="section-title">热门推荐</span>
                </div>
                
                <div class="search-results" id="searchResults">
                    <!-- Initial Placeholder Content -->
                    <div class="search-item" onclick="alert('点击了书籍')">
                        <div class="search-cover"></div>
                        <div class="search-title">Dune</div>
                        <div class="search-author">Frank Herbert</div>
                    </div>
                    <div class="search-item" onclick="alert('点击了书籍')">
                        <div class="search-cover"></div>
                        <div class="search-title">1984</div>
                        <div class="search-author">George Orwell</div>
                    </div>
                    <div class="search-item" onclick="alert('点击了书籍')">
                        <div class="search-cover"></div>
                        <div class="search-title">The Great Gatsby</div>
                        <div class="search-author">F. Scott Fitzgerald</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- VIEW: ME -->
        <div id="view-me" class="view-section hidden">
            <div class="header-container reader-header-container--compact">
                <div class="header-glow"></div>
            </div>
            <div class="scroll-content">
                <div class="profile-header">
                    <div class="profile-avatar">
                        <div class="reader-avatar-placeholder reader-avatar-placeholder--lg">U</div>
                    </div>
                    <div class="profile-name">Reader User</div>
                    <div class="profile-bio">热爱阅读，探索世界</div>
                </div>

                <div class="stats-row">
                    <div class="stat-item">
                        <span class="stat-val">32</span>
                        <span class="stat-label">读完书籍</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-val">128</span>
                        <span class="stat-label">阅读小时</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-val">15</span>
                        <span class="stat-label">连续打卡</span>
                    </div>
                </div>

                <div class="menu-list">
                    <div class="menu-item">
                        <div class="menu-item-left">
                            <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                            <span>个人信息</span>
                        </div>
                        <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </div>
                    <div class="menu-item">
                        <div class="menu-item-left">
                            <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>
                            <span>阅读偏好</span>
                        </div>
                        <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </div>
                    <div class="menu-item">
                        <div class="menu-item-left">
                            <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                            <span>设置</span>
                        </div>
                        <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </div>
                </div>
            </div>
        </div>

        <!-- Floating Tab Bar -->
        <div class="tab-bar">
            <div class="tab-item active" onclick="switchTab('bookshelf')" id="tab-bookshelf">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
                <span class="tab-text">书架</span>
            </div>
            <div class="tab-item" onclick="switchTab('discover')" id="tab-discover">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7" rx="2" ry="2"></rect><rect x="14" y="3" width="7" height="7" rx="2" ry="2"></rect><rect x="14" y="14" width="7" height="7" rx="2" ry="2"></rect><rect x="3" y="14" width="7" height="7" rx="2" ry="2"></rect></svg>
                <span class="tab-text">发现</span>
            </div>
            <div class="tab-item" onclick="switchTab('me')" id="tab-me">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                <span class="tab-text">我的</span>
            </div>
        </div>

        <!-- Edit Modal -->
        <div class="modal-overlay" id="editModal">
            <div class="modal-card">
                <div class="modal-title">编辑书籍信息</div>
                <input type="text" class="modal-input" id="bookTitleInput" placeholder="输入书名">
                <div class="modal-actions">
                    <button class="btn btn-cancel" onclick="closeModal()">取消</button>
                    <button class="btn btn-save" onclick="saveBookTitle()">保存</button>
                </div>
            </div>
        </div>

        <!-- Animation Layer -->
        <div class="animation-layer" id="animLayer"></div>

        <!-- Reader View (Enhanced) -->
        <div class="reader-view" id="readerView">
            <!-- Top Bar -->
            <div class="reader-top-bar">
                <button class="reader-btn reader-btn--icon" id="closeButton" onpointerdown="isClosingReader=true;" onclick="event.stopPropagation(); closeBook()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </button>
                <div class="reader-title-wrap">
                    <span class="reader-title-text" id="readerTitle">正在阅读</span>
                    <span class="reader-page-indicator" id="readerPageIndicator"></span>
                </div>
                <button class="reader-btn reader-btn--icon" id="moreButton" onclick="event.stopPropagation(); toggleMoreMenu()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></svg>
                </button>
            </div>
            
            <!-- More Menu -->
            <div class="more-menu" id="moreMenu" onclick="event.stopPropagation()">
                <div class="more-item" onclick="event.stopPropagation(); alert('添加书签成功')">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>
                    <span>添加书签</span>
                </div>
                <div class="more-item" onclick="event.stopPropagation(); alert('分享功能')">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
                    <span>分享书籍</span>
                </div>
                <div class="more-item" onclick="event.stopPropagation(); alert('书籍详情')">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                    <span>书籍信息</span>
                </div>
                <div class="more-item" onclick="event.stopPropagation(); toggleReaderDebug()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"></path></svg>
                    <span>调试面板</span>
                </div>
            </div>

            <!-- Content -->
            <div class="reader-content" id="readerContent">
                <div class="reader-content-inner" id="readerContentInner"></div>
                <div class="reader-interaction-layer" id="readerInteractionLayer">
                    <div class="reader-interaction-zone menu"></div>
                    <div class="reader-interaction-zone corner tl"></div>
                    <div class="reader-interaction-zone corner tr"></div>
                    <div class="reader-interaction-zone corner bl"></div>
                    <div class="reader-interaction-zone corner br"></div>
                </div>
            </div>
            <div class="reader-chapter-page-indicator" id="readerChapterPageIndicator"></div>
            <div class="reader-bottom-status" id="readerBottomStatus">
                <div class="reader-bottom-status-left" id="readerBottomPage"></div>
                <div class="reader-bottom-status-right">
                    <div id="readerBottomClock"></div>
                    <span class="reader-bottom-status-battery" aria-hidden="true">
                        <svg viewBox="0 0 28 12" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="1" y="1" width="22" height="10" rx="2"></rect>
                            <rect id="readerBatteryFill" x="2.8" y="2.8" width="0" height="6.4" rx="1.2" fill="currentColor" stroke="none"></rect>
                            <path d="M25 4v4"></path>
                        </svg>
                    </span>
                </div>
            </div>
            <button class="selection-query-btn" id="selectionQueryBtn" onclick="event.stopPropagation(); openSelectionQueryPanel()">
                查询
            </button>
            <div class="query-overlay" id="queryOverlay" onclick="event.stopPropagation(); hideSelectionQueryPanel()"></div>
            <div class="query-panel" id="queryPanel" onclick="event.stopPropagation()">
                <div class="query-header">
                    <div class="reader-query-meta">
                        <div class="query-title">查询</div>
                        <div class="query-text" id="queryPanelText"></div>
                    </div>
                    <button class="query-action reader-query-action--close" onclick="event.stopPropagation(); hideSelectionQueryPanel()">关闭</button>
                </div>
                <div class="query-result" id="queryResult"></div>
                <div class="query-actions">
                    <button class="query-action" onclick="event.stopPropagation(); openSelectionQuery('youdao')">怎么读</button>
                    <button class="query-action" onclick="event.stopPropagation(); openSelectionQuery('baidu_hanyu')">百度汉语</button>
                    <button class="query-action" onclick="event.stopPropagation(); openSelectionQuery('baidu_baike')">百度百科</button>
                    <button class="query-action" onclick="event.stopPropagation(); openSelectionQuery('wiki')">维基百科</button>
                </div>
            </div>

            <!-- Bottom Bar (Fanqie Style: Catalog | Night | Settings) -->
            <div class="reader-bottom-bar">
                <div class="reader-bottom-bar-inner">
                    <button class="reader-btn" id="tocButton" onclick="event.stopPropagation(); toggleToc()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                        <span>目录</span>
                    </button>
                    <button class="reader-btn" id="nightButton" onclick="event.stopPropagation(); toggleNightMode()">
                        <svg id="nightModeIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                        <span id="nightModeText">夜间</span>
                    </button>
                    <button class="reader-btn" id="settingsButton" onclick="event.stopPropagation(); toggleSettings()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                        <span>设置</span>
                    </button>
                </div>
            </div>

            <!-- Settings Panel -->
            <div class="settings-panel settings-bar" id="settingsPanel" onclick="event.stopPropagation()">
                <div class="setting-row">
                    <div class="setting-label">背景颜色</div>
                    <div class="theme-options">
                        <div class="theme-circle theme-white active" onclick="event.stopPropagation(); setReaderTheme('white', this)"></div>
                        <div class="theme-circle theme-sepia" onclick="event.stopPropagation(); setReaderTheme('sepia', this)"></div>
                        <div class="theme-circle theme-green" onclick="event.stopPropagation(); setReaderTheme('green', this)"></div>
                        <div class="theme-circle theme-dark" onclick="event.stopPropagation(); setReaderTheme('dark', this)"></div>
                    </div>
                </div>
                <div class="setting-row">
                    <div class="setting-label">字体大小 <span id="fontSizeDisplay" class="reader-fontsize-display">18</span></div>
                    <div class="slider-container">
                        <span class="reader-fontsize-minus">A-</span>
                        <input type="range" class="slider-control" min="14" max="30" value="18" onclick="event.stopPropagation()" oninput="updateFontSize(this.value)">
                        <span class="reader-fontsize-plus">A+</span>
                    </div>
                </div>
                <div class="setting-row">
                    <div class="setting-label">行间距</div>
                    <div class="slider-container">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 6h16M4 12h16M4 18h16"/></svg>
                        <input type="range" class="slider-control" min="12" max="24" value="18" onclick="event.stopPropagation()" oninput="updateLineHeight(this.value)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 3h16M4 12h16M4 21h16"/></svg>
                    </div>
                </div>
                
            </div>

            <!-- TOC Overlay -->
            <div class="toc-overlay" id="tocOverlay" onclick="event.stopPropagation(); toggleToc()"></div>
            <div class="toc-panel" id="tocPanel" onclick="event.stopPropagation()">
                <div class="toc-scroll" id="tocScroll">
                    <div class="toc-header">
                        <div class="toc-header-row">
                            <div class="toc-title">目录</div>
                            <div class="toc-actions">
                                <button class="toc-action-btn" onclick="event.stopPropagation(); scrollTocActiveIntoView()">定位</button>
                                <button class="toc-action-btn" id="tocOrderBtn" onclick="event.stopPropagation(); toggleTocOrder()">正序</button>
                            </div>
                        </div>
                        <div class="toc-subtitle">共 12 章</div>
                    </div>
                    <div class="toc-list" id="tocList">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>

        </div>

    </div>

    <script>
        if ('scrollRestoration' in history) {
            try { history.scrollRestoration = 'manual'; } catch (e) {}
        }

        function updateFrameScale() {
            try {
                const isMobile = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                const scale = isMobile ? 1 : Math.min(1, (window.innerWidth - 40) / 428, (window.innerHeight - 40) / 926);
                document.documentElement.style.setProperty('--frame-scale', String(Math.max(0.25, Number.isFinite(scale) ? scale : 1)));
            } catch (e) {}
        }

        updateFrameScale();
        window.addEventListener('resize', updateFrameScale, { passive: true });

        function updateReaderBottomSheetOffset() {
            try {
                const reader = document.getElementById('readerView');
                if (!reader) return;
                const panel = document.getElementById('settingsPanel');
                const bottomBar = document.querySelector('.reader-bottom-bar');
                const panelActive = !!(panel && panel.classList && panel.classList.contains('active'));
                if (!panelActive) {
                    reader.style.setProperty('--reader-bottom-sheet', '0px');
                    try { invalidateTxtCharsPerPage(); updatePageIndicatorByTxtPos(txtActiveAbsPos); } catch (e) {}
                    return;
                }
                const panelH = panel.getBoundingClientRect ? (panel.getBoundingClientRect().height || 0) : 0;
                const bottomH = bottomBar && bottomBar.getBoundingClientRect ? (bottomBar.getBoundingClientRect().height || 0) : 0;
                const extra = Math.max(0, panelH - bottomH);
                reader.style.setProperty('--reader-bottom-sheet', `${Math.round(extra)}px`);
                try { invalidateTxtCharsPerPage(); updatePageIndicatorByTxtPos(txtActiveAbsPos); } catch (e) {}
            } catch (e) {}
        }

        window.addEventListener('resize', updateReaderBottomSheetOffset, { passive: true });
        window.addEventListener('orientationchange', updateReaderBottomSheetOffset, { passive: true });

        // --- Storage Layer (IndexedDB) ---
        const DB_NAME = 'ReaderAppDB';
        const DB_VERSION = 2;
        const STORES = { BOOKS: 'books', PROGRESS: 'progress' };
        const debugEnabled = new URLSearchParams(location.search).get('debug') === '1' || localStorage.getItem('reader_debug') === '1';
        const HOTZONE_CORNER_WIDTH_PCT = 0.3;
        const HOTZONE_CORNER_HEIGHT_PCT = 0.25;
        const LINE_HEIGHT = 32;
        let debugPanelEl = null;
        let debugPanelContentEl = null;
        let debugPanelTimer = null;
        let debugLines = [];
        let debugEvents = [];
        let bodyScrollLockState = null;

        try {
            document.documentElement.classList.toggle('debug-mode', !!debugEnabled);
        } catch (e) {}

        function shouldShowDebugPanel() {
            try { return localStorage.getItem('reader_debug_panel') !== '0'; } catch (e) { return true; }
        }

        function closeDebugPanel() {
            try { localStorage.setItem('reader_debug_panel', '0'); } catch (e) {}
            try { if (debugPanelTimer) clearInterval(debugPanelTimer); } catch (e) {}
            debugPanelTimer = null;
            try { if (debugPanelEl && debugPanelEl.parentElement) debugPanelEl.parentElement.removeChild(debugPanelEl); } catch (e) {}
            debugPanelEl = null;
            debugPanelContentEl = null;
        }

        function ensureSettingsPanelMountPoint() {
            const el = document.getElementById('settingsPanel');
            const readerView = document.getElementById('readerView');
            if (!el || !readerView) return;
            try {
                if (el.parentElement !== readerView) readerView.appendChild(el);
            } catch (e) {}
        }

        try { ensureSettingsPanelMountPoint(); } catch (e) {}

        function toggleReaderDebug() {
            const next = localStorage.getItem('reader_debug') === '1' ? '0' : '1';
            localStorage.setItem('reader_debug', next);
            location.reload();
        }

        function debugLog(event, payload = null) {
            if (!debugEnabled) return;
            try {
                console.log('[reader-debug]', event, payload || '');
            } catch (e) {}
            try {
                const time = new Date().toISOString().slice(11, 19);
                const line = payload ? `${time} ${event} ${JSON.stringify(payload)}` : `${time} ${event}`;
                debugLines.push(line);
                if (debugLines.length > 200) debugLines.shift();
                debugEvents.push({ time, event, payload });
                if (debugEvents.length > 200) debugEvents.shift();
            } catch (e) {}
        }

        function formatDebugPanelText() {
            const contentArea = document.getElementById('readerContent');
            const docEl = document.scrollingElement;
            const lastTxt = typeof lastTxtProgress !== 'undefined' ? lastTxtProgress : null;
            const readerView = document.getElementById('readerView');
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const filtered = debugEvents.filter(e => {
                const ev = e.event || '';
                return (
                    ev.startsWith('txt open:') ||
                    ev === 'saveTxtProgressFromView' ||
                    ev === 'saveProgress' ||
                    ev.startsWith('skip saveProgress') ||
                    ev.startsWith('closeBook') ||
                    ev.startsWith('ui:') ||
                    ev.startsWith('openBookFromId wait close') ||
                    ev.startsWith('openBookFromId wait close')
                );
            }).slice(-60);

            const snap = {
                bookId: typeof currentBookId !== 'undefined' ? currentBookId : null,
                isRestoringTxt: typeof isRestoringTxt !== 'undefined' ? isRestoringTxt : null,
                isClosingReader: typeof isClosingReader !== 'undefined' ? isClosingReader : null,
                ui: {
                    readerView: readerView ? readerView.className : null,
                    tocPanel: tocPanel ? tocPanel.className : null,
                    tocOverlay: tocOverlay ? tocOverlay.className : null,
                    settingsPanel: settingsPanel ? settingsPanel.className : null,
                    moreMenu: moreMenu ? moreMenu.className : null
                },
                content: contentArea ? {
                    top: contentArea.scrollTop,
                    h: contentArea.scrollHeight,
                    ch: contentArea.clientHeight,
                    chunkStart: parseInt(contentArea.getAttribute('data-chunk-start') || '0'),
                    loadedLength: parseInt(contentArea.getAttribute('data-render-length') || '0'),
                    nextStart: contentArea.getAttribute('data-next-start')
                } : null,
                doc: docEl ? { top: docEl.scrollTop } : null,
                lastTxt: lastTxt ? {
                    absolutePos: lastTxt.absolutePos,
                    percent: lastTxt.percent,
                    chunkStart: lastTxt.chunkStart,
                    scrollTop: lastTxt.scrollTop,
                    scrollRatio: lastTxt.scrollRatio,
                    ratio: lastTxt.ratio,
                    loadedLength: lastTxt.loadedLength
                } : null
            };

            const lines = filtered.map(e => {
                if (e.payload === null || e.payload === undefined) return `${e.time} ${e.event}`;
                return `${e.time} ${e.event} ${JSON.stringify(e.payload)}`;
            });
            return JSON.stringify(snap, null, 2) + '\n\n' + lines.join('\n');
        }

        function ensureDebugPanel() {
            if (!debugEnabled || !shouldShowDebugPanel() || debugPanelEl) return;
            const wrap = document.createElement('div');
            wrap.style.position = 'fixed';
            wrap.style.left = '8px';
            wrap.style.right = '8px';
            wrap.style.bottom = '8px';
            wrap.style.maxHeight = '45vh';
            wrap.style.overflow = 'hidden';
            wrap.style.zIndex = '9999';
            wrap.style.background = 'rgba(0,0,0,0.75)';
            wrap.style.color = '#fff';
            wrap.style.borderRadius = '10px';
            wrap.style.fontSize = '12px';
            wrap.style.pointerEvents = 'auto';
            wrap.style.display = 'flex';
            wrap.style.flexDirection = 'column';

            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.padding = '8px 10px';
            header.style.borderBottom = '1px solid rgba(255,255,255,0.12)';
            header.style.userSelect = 'none';

            const title = document.createElement('div');
            title.textContent = 'Debug';
            title.style.opacity = '0.85';
            title.style.fontWeight = '600';

            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.textContent = '关闭';
            closeBtn.style.border = '1px solid rgba(255,255,255,0.25)';
            closeBtn.style.background = 'transparent';
            closeBtn.style.color = '#fff';
            closeBtn.style.borderRadius = '8px';
            closeBtn.style.padding = '4px 10px';
            closeBtn.style.fontSize = '12px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.onclick = (e) => { try { e.stopPropagation(); } catch (err) {} closeDebugPanel(); };

            header.appendChild(title);
            header.appendChild(closeBtn);

            const pre = document.createElement('pre');
            pre.style.margin = '0';
            pre.style.padding = '10px';
            pre.style.flex = '1';
            pre.style.overflow = 'auto';
            pre.style.whiteSpace = 'pre-wrap';
            pre.style.userSelect = 'text';
            pre.style.webkitUserSelect = 'text';

            wrap.appendChild(header);
            wrap.appendChild(pre);
            document.body.appendChild(wrap);
            debugPanelEl = wrap;
            debugPanelContentEl = pre;
            debugLog('debug enabled');
            window.addEventListener('error', (e) => {
                debugLog('ui:error', { message: e.message, filename: e.filename, lineno: e.lineno, colno: e.colno, stack: e.error && e.error.stack ? String(e.error.stack) : null });
            });
            window.addEventListener('unhandledrejection', (e) => {
                const reason = e && e.reason;
                debugLog('ui:unhandledrejection', { reason: reason && reason.stack ? String(reason.stack) : String(reason) });
            });
            debugPanelTimer = setInterval(() => {
                if (!debugPanelContentEl) return;
                debugPanelContentEl.textContent = formatDebugPanelText();
            }, 350);
        }

        function lockBodyScroll(lock) {
            if (lock) {
                if (bodyScrollLockState) return;
                const scrollY = window.scrollY || 0;
                bodyScrollLockState = {
                    scrollY,
                    overflow: document.body.style.overflow,
                    position: document.body.style.position,
                    top: document.body.style.top,
                    left: document.body.style.left,
                    right: document.body.style.right,
                    width: document.body.style.width
                };
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.top = `-${scrollY}px`;
                document.body.style.left = '0';
                document.body.style.right = '0';
                document.body.style.width = '100%';
            } else {
                if (!bodyScrollLockState) return;
                const { scrollY, overflow, position, top, left, right, width } = bodyScrollLockState;
                document.body.style.overflow = overflow;
                document.body.style.position = position;
                document.body.style.top = top;
                document.body.style.left = left;
                document.body.style.right = right;
                document.body.style.width = width;
                bodyScrollLockState = null;
                window.scrollTo(0, scrollY);
            }
        }

        class StorageManager {
            constructor() { this.dbPromise = this.initDB(); }
            progressKey(bookId) { return `reader_progress_${bookId}`; }
            legacyProgressKey(bookId) { return `reader_progress_cache_${bookId}`; }
            booksListKey() { return 'my_books'; }
            readLocalBooksList() {
                try {
                    const raw = localStorage.getItem(this.booksListKey());
                    const parsed = raw ? JSON.parse(raw) : [];
                    return Array.isArray(parsed) ? parsed : [];
                } catch (e) {
                    return [];
                }
            }
            writeLocalBooksList(list) {
                try {
                    if (!Array.isArray(list)) return;
                    localStorage.setItem(this.booksListKey(), JSON.stringify(list));
                } catch (e) {}
            }
            toLocalBookMeta(book) {
                try {
                    if (!book || typeof book !== 'object') return null;
                    const meta = {
                        id: book.id,
                        title: book.title,
                        author: book.author,
                        cover: book.cover,
                        addedDate: book.addedDate,
                        format: book.format
                    };
                    return meta && meta.id ? meta : null;
                } catch (e) {
                    return null;
                }
            }
            upsertLocalBookMeta(bookMeta) {
                try {
                    if (!bookMeta || !bookMeta.id) return;
                    const list = this.readLocalBooksList();
                    const next = [];
                    let inserted = false;
                    for (const item of list) {
                        if (item && item.id === bookMeta.id) {
                            next.push({ ...(item || {}), ...bookMeta });
                            inserted = true;
                        } else {
                            next.push(item);
                        }
                    }
                    if (!inserted) next.push(bookMeta);
                    this.writeLocalBooksList(next);
                } catch (e) {}
            }
            updateLocalBookProgress(bookId, progressPercent, lastReadIndex = null) {
                try {
                    const list = this.readLocalBooksList();
                    if (!Array.isArray(list) || list.length === 0) return;
                    const next = list.map((item) => {
                        if (!item || item.id !== bookId) return item;
                        const patch = { progress: progressPercent, lastReadTime: Date.now() };
                        if (Number.isFinite(Number(lastReadIndex))) patch.lastReadIndex = Number(lastReadIndex);
                        return { ...item, ...patch };
                    });
                    this.writeLocalBooksList(next);
                } catch (e) {}
            }
            initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (e.oldVersion < 2) {
                            if (db.objectStoreNames.contains(STORES.PROGRESS)) db.deleteObjectStore(STORES.PROGRESS);
                        }
                        if (!db.objectStoreNames.contains(STORES.BOOKS)) db.createObjectStore(STORES.BOOKS, { keyPath: 'id' });
                        if (!db.objectStoreNames.contains(STORES.PROGRESS)) db.createObjectStore(STORES.PROGRESS, { keyPath: 'bookId' });
                    };
                    request.onsuccess = (e) => resolve(e.target.result);
                    request.onerror = (e) => reject(e.target.error);
                });
            }
            async getDB() { return this.dbPromise; }
            async addBook(book) {
                const db = await this.getDB();
                await new Promise((resolve) => {
                    const tx = db.transaction(STORES.BOOKS, 'readwrite');
                    tx.objectStore(STORES.BOOKS).put(book);
                    tx.oncomplete = () => resolve();
                });
                try {
                    const meta = this.toLocalBookMeta(book);
                    if (meta) this.upsertLocalBookMeta(meta);
                } catch (e) {}
            }
            async getAllBooks() {
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.BOOKS, 'readonly');
                    const request = tx.objectStore(STORES.BOOKS).getAll();
                    request.onsuccess = () => resolve(request.result.sort((a, b) => b.addedDate - a.addedDate));
                });
            }
            async getBook(id) {
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.BOOKS, 'readonly');
                    const request = tx.objectStore(STORES.BOOKS).get(id);
                    request.onsuccess = () => resolve(request.result);
                });
            }
            async deleteBook(id) {
                try {
                    localStorage.removeItem(this.progressKey(id));
                    localStorage.removeItem(this.legacyProgressKey(id));
                } catch (e) {}
                try {
                    const list = this.readLocalBooksList();
                    if (Array.isArray(list) && list.length > 0) {
                        this.writeLocalBooksList(list.filter(item => !item || item.id !== id));
                    }
                } catch (e) {}
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction([STORES.BOOKS, STORES.PROGRESS], 'readwrite');
                    tx.objectStore(STORES.BOOKS).delete(id);
                    tx.objectStore(STORES.PROGRESS).delete(id);
                    tx.oncomplete = () => resolve();
                });
            }
            async saveProgress(bookId, cfi, percentage, scrollTop = 0, chunkStart = null, extra = null) {
                debugLog('saveProgress', { bookId, cfi, percentage, scrollTop, chunkStart, extra });
                const isTxt = extra && extra.kind === 'txt';
                const newPos = isTxt ? parseInt(cfi) : NaN;
                if (isTxt && Number.isFinite(newPos)) {
                    try {
                        const raw = localStorage.getItem(this.progressKey(bookId)) || localStorage.getItem(this.legacyProgressKey(bookId));
                        const prev = raw ? JSON.parse(raw) : null;
                        const prevPos = prev && prev.cfi !== undefined && prev.cfi !== null ? parseInt(prev.cfi) : NaN;
                        const guardClose = extra && extra.reason === 'close' && !!extra.nearEdge;
                        if (guardClose && Number.isFinite(prevPos) && prevPos > newPos + 5000) {
                            debugLog('skip saveProgress (rollback guard)', { bookId, prevPos, newPos, scrollTop });
                            return;
                        }
                    } catch (e) {}
                }
                try {
                    localStorage.setItem(this.progressKey(bookId), JSON.stringify({ bookId, cfi, percentage, scrollTop, chunkStart, timestamp: Date.now(), ...(extra || {}) }));
                    try { localStorage.removeItem(this.legacyProgressKey(bookId)); } catch (e) {}
                } catch (e) {}
                try {
                    const percentNum = Number(percentage);
                    if (Number.isFinite(percentNum)) {
                        const progressPercent = Math.max(0, Math.min(100, Math.round(percentNum)));
                        const lastReadIndex = extra && extra.chapterIndex !== undefined ? extra.chapterIndex : null;
                        this.updateLocalBookProgress(bookId, progressPercent, lastReadIndex);
                    }
                } catch (e) {}
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.PROGRESS, 'readwrite');
                    tx.objectStore(STORES.PROGRESS).put({ bookId, cfi, percentage, scrollTop, chunkStart, timestamp: Date.now(), ...(extra || {}) });
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => resolve();
                });
            }
            async getProgress(bookId) {
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.PROGRESS, 'readonly');
                    const request = tx.objectStore(STORES.PROGRESS).get(bookId);
                    request.onsuccess = () => {
                        let cachedNew = null;
                        let cachedLegacy = null;
                        try {
                            const rawNew = localStorage.getItem(this.progressKey(bookId));
                            cachedNew = rawNew ? JSON.parse(rawNew) : null;
                            const rawLegacy = localStorage.getItem(this.legacyProgressKey(bookId));
                            cachedLegacy = rawLegacy ? JSON.parse(rawLegacy) : null;
                        } catch (e) {}
                        const newTs = cachedNew && cachedNew.timestamp ? Number(cachedNew.timestamp) : 0;
                        const legacyTs = cachedLegacy && cachedLegacy.timestamp ? Number(cachedLegacy.timestamp) : 0;
                        const cached = (cachedNew && cachedLegacy) ? (newTs >= legacyTs ? cachedNew : cachedLegacy) : (cachedNew || cachedLegacy || null);

                        const idb = request.result || null;
                        const idbTs = idb && idb.timestamp ? Number(idb.timestamp) : 0;
                        const cacheTs = cached && cached.timestamp ? Number(cached.timestamp) : 0;

                        const result = (idb && cached) ? (idbTs >= cacheTs ? idb : cached) : (idb || cached || null);
                        debugLog('getProgress', { bookId, hasIdb: !!idb, hasCache: !!cached, idbTs, cacheTs, result });
                        resolve(result);
                    };
                    request.onerror = () => {
                        try {
                            const raw = localStorage.getItem(this.progressKey(bookId)) || localStorage.getItem(this.legacyProgressKey(bookId));
                            const fallback = raw ? JSON.parse(raw) : null;
                            debugLog('getProgress error', { bookId, fallback });
                            resolve(fallback);
                        } catch (e) {
                            debugLog('getProgress error', { bookId, fallback: null });
                            resolve(null);
                        }
                    };
                });
            }
        }
        const storage = new StorageManager();
        if (debugEnabled) ensureDebugPanel();
        window.addEventListener('pagehide', () => {
            isClosingReader = true;
            saveTxtProgressFromView('close');
            saveEpubProgressFromView('close');
        });
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                isClosingReader = true;
                saveTxtProgressFromView('close');
                saveEpubProgressFromView('close');
            } else {
                isClosingReader = false;
            }
        });

        // --- Tabs Logic ---
        function switchTab(tabName) {
            // Hide all views
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active', 'hidden'));
            document.querySelectorAll('.view-section').forEach(el => {
                if(el.id !== 'view-' + tabName) el.classList.add('hidden');
            });
            
            // Show target view
            document.getElementById('view-' + tabName).classList.add('active');
            
            // Update Tab Bar
            document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('active'));
            document.getElementById('tab-' + tabName).classList.add('active');
            try { if (tabName === 'bookshelf') renderBookshelf(); } catch (e) {}
        }

        // --- Import Logic ---
        function triggerImport() {
            document.getElementById('fileInput').click();
        }
        
        document.getElementById('fileInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const ext = file.name.split('.').pop().toLowerCase();
            const bookId = 'book_' + Date.now();
            let bookData = {
                id: bookId,
                title: file.name.replace(/\.[^/.]+$/, ""),
                author: '未知作者',
                cover: '',
                fileBlob: file,
                addedDate: Date.now(),
                format: ext.toUpperCase()
            };

            if (ext === 'epub') {
                try {
                    const book = ePub(file);
                    const metadata = await book.loaded.metadata;
                    bookData.title = metadata.title;
                    bookData.author = metadata.creator;
                    
                    const coverUrl = await book.coverUrl();
                    if (coverUrl) {
                        // Convert cover to data URL for persistent storage
                        const resp = await fetch(coverUrl);
                        const blob = await resp.blob();
                        bookData.cover = await new Promise(r => {
                            const reader = new FileReader();
                            reader.onload = () => r(reader.result);
                            reader.readAsDataURL(blob);
                        });
                    }
                } catch (err) {
                    console.error('EPUB parse error:', err);
                }
            }

            await storage.addBook(bookData);
            renderBookshelf();
        });

        async function renderBookshelf() {
             const books = await storage.getAllBooks();
             const container = document.getElementById('booksContainer');
             
             if (books.length === 0) {
                 container.innerHTML = '<div class="reader-empty-state">书架空空如也，点击上方“导入”开始阅读</div>';
                 return;
             }

             const cardResults = await Promise.all(books.map(async (book) => {
                 const progressData = await storage.getProgress(book.id);
                 const progress = progressData
                    ? (
                        Number.isFinite(Number(progressData.percentage)) ? Number(progressData.percentage)
                        : (progressData.ratio !== undefined && progressData.ratio !== null ? Math.max(1, Math.round(parseFloat(progressData.ratio) * 100)) : 0)
                    )
                    : 0;
                 const meta = {
                     id: book.id,
                     title: book.title,
                     author: book.author,
                     cover: book.cover,
                     addedDate: book.addedDate,
                     format: book.format,
                     progress,
                     lastReadIndex: progressData && progressData.chapterIndex !== undefined ? progressData.chapterIndex : null,
                     lastReadTime: progressData && progressData.timestamp ? progressData.timestamp : null
                 };
                 const html = `
                     <div class="book-card" onclick="openBookFromId('${book.id}')">
                         ${book.cover 
                             ? `<div class="book-cover" style="background-image: url('${book.cover}');"></div>`
                             : `<div class="book-cover dynamic-cover cover-${(book.title.length % 3) + 1}"><div class="cover-text">${book.title}</div></div>`
                         }
                         <div class="book-info">
                             <div class="book-title">${book.title}</div>
                             <div class="book-meta"><span>${book.author}</span><span class="format-badge">${book.format}</span></div>
                             <div class="progress-container">
                                 <div class="progress-track"><div class="progress-fill" style="width: ${progress}%;"></div></div>
                                 <span class="progress-text">${progress}%</span>
                             </div>
                             <div class="book-stats">
                                 <span>${(((book.fileBlob && book.fileBlob.size) ? book.fileBlob.size : 0) / 1024 / 1024).toFixed(2)} MB</span>
                                 <button class="edit-btn" onclick="event.stopPropagation(); deleteBook('${book.id}')">删除</button>
                             </div>
                         </div>
                     </div>
                 `;
                 return { html, meta };
             }));
             
             container.innerHTML = cardResults.map(r => r.html).join('');
             try { localStorage.setItem('my_books', JSON.stringify(cardResults.map(r => r.meta))); } catch (e) {}
         }

        async function deleteBook(id) {
            if (confirm('确定要删除这本书吗？')) {
                await storage.deleteBook(id);
                renderBookshelf();
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            renderBookshelf();
            updateAppleTouchIcon();
            try { bindReaderGlobalGestures(); } catch (e) {}
            try { bindReaderInteractionLayer(); } catch (e) {}
            try { ensureReaderBottomStatusTimer(); } catch (e) {}
        });

        async function updateAppleTouchIcon() {
            const link = document.getElementById('appleTouchIcon');
            const pre = document.getElementById('appleTouchIconPre');
            if (!link && !pre) return;
            try {
                if (link) {
                    link.setAttribute('sizes', '180x180');
                    link.setAttribute('href', './icon/mozi_icon_180.png?v=2');
                }
                if (pre) {
                    pre.setAttribute('sizes', '180x180');
                    pre.setAttribute('href', './icon/mozi_icon_180.png?v=2');
                }
            } catch (e) {}
        }

        window.addEventListener('pagehide', async () => {
            if (document.getElementById('readerView').classList.contains('active')) {
                await saveTxtProgressFromView();
                await saveEpubProgressFromView();
            }
        });

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'hidden' && document.getElementById('readerView').classList.contains('active')) {
                await saveTxtProgressFromView();
                await saveEpubProgressFromView();
            }
        });

        // --- Search Logic (Google Books API) ---
        async function handleSearch(event) {
            if (event.key === 'Enter') {
                const query = event.target.value;
                if (!query) return;
                
                const resultsContainer = document.getElementById('searchResults');
                resultsContainer.innerHTML = '<div class="reader-grid-message reader-grid-message--secondary">搜索中...</div>';
                
                try {
                    const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=9`);
                    const data = await response.json();
                    
                    if (data.items && data.items.length > 0) {
                        resultsContainer.innerHTML = '';
                        data.items.forEach(item => {
                            const info = item.volumeInfo;
                            const cover = info.imageLinks ? (info.imageLinks.thumbnail || info.imageLinks.smallThumbnail) : '';
                            const title = info.title || '无标题';
                            const authors = info.authors ? info.authors.join(', ') : '未知作者';
                            
                            const html = `
                                <div class="search-item" onclick="addBookFromSearch('${title.replace(/'/g, "\\'")}', '${authors.replace(/'/g, "\\'")}', '${cover}')">
                                    <div class="search-cover" style="background-image: url('${cover}');"></div>
                                    <div class="search-title">${title}</div>
                                    <div class="search-author">${authors}</div>
                                </div>
                            `;
                            resultsContainer.innerHTML += html;
                        });
                    } else {
                        resultsContainer.innerHTML = '<div class="reader-grid-message reader-grid-message--secondary">未找到相关书籍</div>';
                    }
                } catch (e) {
                    console.error(e);
                    resultsContainer.innerHTML = '<div class="reader-grid-message reader-grid-message--secondary">网络错误，请检查连接</div>';
                }
            }
        }
        
        function addBookFromSearch(title, author, coverUrl) {
            if(confirm(`要把《${title}》加入书架吗？`)) {
                const newBookHTML = `
                    <div class="book-card" onclick="openBook(this)">
                        <div class="book-cover" style="background-image: url('${coverUrl}');">
                            <div class="reading-dot"></div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">${title}</div>
                            <div class="book-meta"><span>${author}</span><span class="format-badge">网络</span></div>
                            <div class="progress-container">
                                <div class="progress-track"><div class="progress-fill progress-fill--p0"></div></div>
                                <span class="progress-text">0%</span>
                            </div>
                            <div class="book-stats"><span>未知字数</span><button class="edit-btn" onclick="event.stopPropagation(); editBook(this)">编辑</button></div>
                        </div>
                    </div>
                `;
                document.getElementById('booksContainer').insertAdjacentHTML('afterbegin', newBookHTML);
                switchTab('bookshelf');
            }
        }

        // --- View Toggle Logic ---
        function toggleView() {
            const container = document.getElementById('booksContainer');
            const btn = document.getElementById('toggleBtn');
            const icon = btn.querySelector('svg');
            container.classList.toggle('grid-view');
            if (container.classList.contains('grid-view')) {
                icon.innerHTML = '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>';
            } else {
                icon.innerHTML = '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>';
            }
        }

        // --- Edit Modal Logic ---
        let currentEditingBook = null;
        function editBook(btn) {
            const card = btn.closest('.book-card');
            const titleEl = card.querySelector('.book-title');
            currentEditingBook = titleEl;
            document.getElementById('bookTitleInput').value = titleEl.innerText;
            document.getElementById('editModal').classList.add('active');
        }
        function closeModal() { document.getElementById('editModal').classList.remove('active'); currentEditingBook = null; }
        function saveBookTitle() {
            if (currentEditingBook) currentEditingBook.innerText = document.getElementById('bookTitleInput').value.trim();
            closeModal();
        }

        // --- Content Generator ---
        function generateChapter(title, index) {
            const paragraphs = [
                "那个年代，人们的心中充满了理想主义的火焰。叶文洁站在雷达峰顶，看着夕阳下的红岸基地，心中涌起一股难以言喻的复杂情感。",
                "天线巨大的抛物面在余晖中闪烁着冷冽的金属光泽，仿佛一只巨大的耳朵，倾听着宇宙深处的秘密。风从群山间呼啸而过，带来了远方森林的气息。",
                "这段信息穿越了数光年的距离，最终抵达了这颗蓝色的星球。命运的齿轮，在这一刻悄然转动。谁也没有想到，这短短的一句话，竟然改变了人类文明的进程。",
                "物理学不存在了。这是一个极其荒谬的结论，但在这个疯狂的年代，似乎没有什么是不可能的。汪淼看着眼前的倒计时，感到一种前所未有的恐惧。",
                "在那一瞬间，他仿佛看到了宇宙的终极真理，那是一种超越人类理解的宏大与冷漠。星空闪烁，仿佛无数双眼睛在注视着这颗微不足道的尘埃。",
                "生活依然在继续，但每个人都知道，一切都已经改变了。那种潜藏在平静表面下的危机感，像瘟疫一样蔓延开来。",
                "智子无处不在。它们监视着人类的一举一动，封锁了人类的基础科学。人类就像被困在玻璃罩里的虫子，无论如何挣扎，都无法逃脱命运的安排。",
                "然而，虫子从来没有被真正战胜过。史强吐出一口烟圈，脸上露出了那标志性的痞气笑容。既然我们是虫子，那就要像虫子一样活着，顽强地活着。"
            ];
            
            let content = `<h2 id="chap-${index}" class="reader-txt-chapter-title">${title}</h2>`;
            for(let i=0; i<15; i++) {
                // Randomly select paragraphs to create length
                const p = paragraphs[Math.floor(Math.random() * paragraphs.length)];
                content += `<p class="reader-txt-paragraph">${p}</p>`;
            }
            return content;
        }

        function setFlipMode(mode) {
            let nextMode = mode;
            nextMode = 'scroll';
            currentFlipMode = nextMode;
            try { localStorage.setItem('reader_flip_mode_last', String(currentFlipMode)); } catch (e) {}
            try { invalidateTxtCharsPerPage(); } catch (e) {}
            // Update UI
            document.querySelectorAll('.flip-option').forEach(el => el.classList.remove('active'));
            const opt = document.getElementById('opt-' + nextMode);
            if (opt) opt.classList.add('active');
            try {
                const indicator = document.getElementById('flipModeIndicator');
                if (indicator) {
                    const idx = nextMode === 'scroll' ? 0 : 1;
                    indicator.style.transform = `translateX(${idx * 100}%)`;
                }
            } catch (e) {}
            // Apply logic
            const contentArea = document.getElementById('readerContent');
            const readerView = document.getElementById('readerView');
            contentArea.classList.add('mode-scroll');
            contentArea.classList.remove('mode-slide');
            contentArea.classList.remove('mode-sim');
            readerView.classList.remove('flip-slide');
            destroyTxtPagedView(Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : null);
            if (contentArea.scrollLeft) contentArea.scrollLeft = 0;
            schedulePersistTxtAnchorProgress('auto');
        }

        let menuPinned = false;
        let txtPagedMode = null;
        let txtPagedPages = [];
        let txtPagedPageAbs = [];
        let txtPagedChunkStart = 0;
        let txtPagedIndex = 0;
        let txtPagedTurnLock = false;
        let txtPagedScrollTimer = null;
        let txtPagedScrollRaf = null;
        let txtMeasureCanvas = null;

        function getTxtAvgCharWidth(cs) {
            try {
                if (!txtMeasureCanvas) txtMeasureCanvas = document.createElement('canvas');
                const ctx = txtMeasureCanvas.getContext('2d');
                if (!ctx) return (parseFloat(cs.fontSize || '18') || 18) * 0.56;
                const font = cs.font || `${cs.fontWeight || '400'} ${cs.fontSize || '18px'} ${cs.fontFamily || 'serif'}`;
                ctx.font = font;
                const w1 = ctx.measureText('汉').width || 0;
                const w2 = ctx.measureText('M').width || 0;
                const avg = (w1 > 0 && w2 > 0) ? ((w1 + w2) / 2) : (w1 || w2);
                const fallback = (parseFloat(cs.fontSize || '18') || 18) * 0.56;
                return avg > 0 ? avg : fallback;
            } catch (e) {
                return (parseFloat(cs.fontSize || '18') || 18) * 0.56;
            }
        }

        function paginateTxtChunk(chunk, startPos, cs, contentArea, linesPerPage) {
            const pagePaddingX = 48;
            const usableWidth = Math.max(220, (contentArea.clientWidth || 360) - pagePaddingX);
            const avgCharWidth = getTxtAvgCharWidth(cs);
            const charsPerLine = Math.max(10, Math.floor(usableWidth / Math.max(6, avgCharWidth)));
            const charsPerPage = Math.max(200, charsPerLine * Math.max(6, linesPerPage));
            const pages = [];
            const pageAbs = [];
            const breakChars = new Set(['\n', '。', '！', '？', '.', '!', '?', '；', ';', '，', ',', '、', ' ', '\t']);
            let offset = 0;
            while (offset < chunk.length) {
                const abs = startPos + offset;
                const end = Math.min(chunk.length, offset + charsPerPage);
                const windowText = chunk.slice(offset, end);
                const lookBack = Math.max(40, Math.floor(charsPerPage * 0.22));
                let cut = windowText.length;
                for (let i = windowText.length - 1; i >= 0 && i >= windowText.length - lookBack; i--) {
                    const c = windowText[i];
                    if (breakChars.has(c)) { cut = i + 1; break; }
                }
                if (cut <= 0) cut = windowText.length;
                const pageText = chunk.slice(offset, offset + cut);
                pages.push(`<div class="paged-text" data-abs="${abs}">${escapeHtml(pageText)}</div>`);
                pageAbs.push(abs);
                offset += cut;
            }
            return { pages, pageAbs };
        }

        function buildTxtPagedView(mode, absHint = null) {
            if (!currentBookId || !currentTxtContent) return;
            const contentArea = document.getElementById('readerContent');
            const inner = document.getElementById('readerContentInner');
            if (!contentArea || !inner) return;
            txtPagedMode = mode;
            const CHUNK_SIZE = 15000;
            const startPos = Math.max(0, parseInt(contentArea.getAttribute('data-chunk-start') || '0', 10) || 0);
            const chunk = currentTxtContent.slice(startPos, startPos + CHUNK_SIZE);
            const cs = window.getComputedStyle(contentArea);
            const fontSize = parseFloat(cs.fontSize || '18') || 18;
            const lineHeightPx = cs.lineHeight === 'normal' ? (fontSize * 1.6) : (parseFloat(cs.lineHeight) || fontSize * 1.6);
            const rootCs = window.getComputedStyle(document.documentElement);
            const safeTop = parseFloat(rootCs.getPropertyValue('--safe-top') || '0') || 0;
            const safeBottom = parseFloat(rootCs.getPropertyValue('--safe-bottom') || '0') || 0;
            const reader = document.getElementById('readerView');
            const bottomSheet = reader ? (parseFloat(window.getComputedStyle(reader).getPropertyValue('--reader-bottom-sheet') || '0') || 0) : 0;
            const padT = 56 + safeTop + 18;
            const padB = 82 + safeBottom + 18 + bottomSheet;
            const usableHeight = Math.max(200, (contentArea.clientHeight || 600) - padT - padB);
            const linesPerPage = Math.max(6, Math.floor(usableHeight / lineHeightPx));
            const paged = paginateTxtChunk(chunk, startPos, cs, contentArea, linesPerPage);
            txtPagedPages = paged.pages;
            txtPagedPageAbs = paged.pageAbs;
            txtPagedChunkStart = startPos;
            let targetAbs = absHint;
            if (!Number.isFinite(targetAbs)) targetAbs = Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : startPos;
            let idx = 0;
            for (let lo = 0, hi = txtPagedPageAbs.length - 1; lo <= hi;) {
                const mid = (lo + hi) >> 1;
                if ((txtPagedPageAbs[mid] || 0) <= targetAbs) { idx = mid; lo = mid + 1; }
                else hi = mid - 1;
            }
            txtPagedIndex = Math.max(0, Math.min(txtPagedPages.length - 1, idx));
            inner.innerHTML = '';
            if (mode === 'simulation') {
                contentArea.onscroll = null;
                contentArea.classList.add('mode-sim');
                contentArea.classList.remove('mode-slide');
                const surface = document.createElement('div');
                surface.className = 'sim-surface';
                const cur = document.createElement('div');
                cur.className = 'sim-current';
                const next = document.createElement('div');
                next.className = 'sim-next';
                cur.innerHTML = `<div class="paged-page">${txtPagedPages[txtPagedIndex] || ''}</div>`;
                next.innerHTML = '';
                surface.appendChild(next);
                surface.appendChild(cur);
                inner.appendChild(surface);
                setTxtActiveFromPagedIndex();
                schedulePersistTxtAnchorProgress('auto');
                return;
            }
            contentArea.classList.add('mode-slide');
            contentArea.classList.remove('mode-sim');
            for (let p = 0; p < txtPagedPages.length; p++) {
                const page = document.createElement('div');
                page.className = 'paged-page';
                page.setAttribute('data-page-index', String(p));
                page.innerHTML = txtPagedPages[p];
                inner.appendChild(page);
            }
            const pageWidth = contentArea.clientWidth || 1;
            contentArea.scrollLeft = txtPagedIndex * pageWidth;
            setTxtActiveFromPagedIndex();
            schedulePersistTxtAnchorProgress('auto');
            if (txtPagedScrollTimer) {
                clearTimeout(txtPagedScrollTimer);
                txtPagedScrollTimer = null;
            }
            contentArea.onscroll = () => {
                if (currentFlipMode !== 'slide') return;
                if (txtPagedScrollRaf) return;
                txtPagedScrollRaf = requestAnimationFrame(() => {
                    txtPagedScrollRaf = null;
                    if (currentFlipMode !== 'slide') return;
                    const w = contentArea.clientWidth || 1;
                    const nextIdx = Math.max(0, Math.min(txtPagedPages.length - 1, Math.round((contentArea.scrollLeft || 0) / w)));
                    if (nextIdx === txtPagedIndex) return;
                    txtPagedIndex = nextIdx;
                    setTxtActiveFromPagedIndex();
                    schedulePersistTxtAnchorProgress('auto');
                });
            };
        }

        function destroyTxtPagedView(absHint = null) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            if (!txtPagedMode) return;
            if (txtPagedScrollRaf) {
                try { cancelAnimationFrame(txtPagedScrollRaf); } catch (e) {}
                txtPagedScrollRaf = null;
            }
            const startPos = Math.max(0, parseInt(contentArea.getAttribute('data-chunk-start') || '0', 10) || 0);
            renderTxtChunk(startPos);
            contentArea.onscroll = null;
            txtPagedMode = null;
            txtPagedPages = [];
            txtPagedPageAbs = [];
            txtPagedChunkStart = 0;
            txtPagedIndex = 0;
            const abs = Number.isFinite(absHint) ? absHint : txtActiveAbsPos;
            if (Number.isFinite(abs)) {
                setTimeout(() => {
                    const ps = Array.from(contentArea.querySelectorAll('p[data-abs]'));
                    let target = null;
                    for (const p of ps) {
                        const a = parseInt(p.getAttribute('data-abs') || 'NaN', 10);
                        if (!Number.isFinite(a)) continue;
                        if (a <= abs) target = p;
                        else break;
                    }
                    if (!target && ps.length > 0) target = ps[0];
                    if (target) scrollParagraphIntoView(target);
                }, 0);
            }
        }

        function setTxtActiveFromPagedIndex() {
            if (!txtPagedPageAbs || txtPagedPageAbs.length === 0) return;
            const abs = txtPagedPageAbs[Math.max(0, Math.min(txtPagedPageAbs.length - 1, txtPagedIndex))];
            if (!Number.isFinite(abs)) return;
            txtActiveAbsPos = abs;
            txtActiveAnchorId = txtAnchorIdForAbsPos(currentBookId, abs);
            updateActiveTxtTocByPos(abs);
        }

        function turnTxtPaged(direction) {
            if (txtPagedTurnLock) return;
            if (!currentBookId || !currentTxtContent) return;
            if (currentFlipMode !== 'slide' && currentFlipMode !== 'simulation') return;
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            const CHUNK_SIZE = 15000;
            const nextIndex = txtPagedIndex + (direction > 0 ? 1 : -1);
            if (nextIndex < 0) {
                const prevStart = Math.max(0, txtPagedChunkStart - CHUNK_SIZE);
                if (prevStart === txtPagedChunkStart) return;
                contentArea.setAttribute('data-chunk-start', String(prevStart));
                contentArea.setAttribute('data-render-length', String(Math.min(CHUNK_SIZE, currentTxtContent.length - prevStart)));
                if (prevStart + CHUNK_SIZE < currentTxtContent.length) contentArea.setAttribute('data-next-start', String(prevStart + CHUNK_SIZE));
                else contentArea.removeAttribute('data-next-start');
                buildTxtPagedView(currentFlipMode, prevStart + CHUNK_SIZE - 1);
                return;
            }
            if (nextIndex >= txtPagedPages.length) {
                const nextStart = txtPagedChunkStart + CHUNK_SIZE;
                if (nextStart >= currentTxtContent.length) return;
                contentArea.setAttribute('data-chunk-start', String(nextStart));
                contentArea.setAttribute('data-render-length', String(Math.min(CHUNK_SIZE, currentTxtContent.length - nextStart)));
                if (nextStart + CHUNK_SIZE < currentTxtContent.length) contentArea.setAttribute('data-next-start', String(nextStart + CHUNK_SIZE));
                else contentArea.removeAttribute('data-next-start');
                buildTxtPagedView(currentFlipMode, nextStart);
                return;
            }
            if (currentFlipMode === 'slide') {
                const w = contentArea.clientWidth || 1;
                txtPagedIndex = nextIndex;
                contentArea.scrollTo({ left: w * nextIndex, behavior: 'smooth' });
                setTimeout(() => {
                    setTxtActiveFromPagedIndex();
                    schedulePersistTxtAnchorProgress('auto');
                }, 180);
                return;
            }
            const surface = contentArea.querySelector('.sim-surface');
            if (!surface) return;
            const cur = surface.querySelector('.sim-current');
            const next = surface.querySelector('.sim-next');
            if (!cur || !next) return;
            txtPagedTurnLock = true;
            next.innerHTML = `<div class="paged-page">${txtPagedPages[nextIndex] || ''}</div>`;
            const turn = document.createElement('div');
            turn.className = 'sim-turn';
            const pageHtml = cur.innerHTML || '';
            const safePageHtml = pageHtml.replace(/\sid="txt-[^"]+"/g, '');
            const forward = direction > 0;
            turn.classList.add(forward ? 'turn-forward' : 'turn-backward');
            turn.innerHTML = `<div class="sim-sheet"><div class="sim-front">${safePageHtml}</div><div class="sim-back">${safePageHtml}</div><div class="sim-shadow"></div></div>`;
            turn.style.transformOrigin = forward ? 'left center' : 'right center';
            turn.style.transform = 'rotateY(0deg)';
            surface.appendChild(turn);
            cur.style.opacity = '0';
            requestAnimationFrame(() => {
                turn.style.transition = 'transform 620ms cubic-bezier(0.2, 0.8, 0.2, 1)';
                turn.style.transform = forward ? 'rotateY(-180deg)' : 'rotateY(180deg)';
            });
            setTimeout(() => {
                txtPagedIndex = nextIndex;
                cur.innerHTML = next.innerHTML;
                cur.style.opacity = '1';
                next.innerHTML = '';
                if (turn.parentElement) turn.parentElement.removeChild(turn);
                txtPagedTurnLock = false;
                setTxtActiveFromPagedIndex();
                schedulePersistTxtAnchorProgress('auto');
            }, 680);
        }

        // --- TXT Processing Logic ---
        
        async function parseTxt(fileBlob) {
            // Detect encoding by reading first 1KB
            const chunk = fileBlob.slice(0, 1024);
            const buffer = await chunk.arrayBuffer();
            const decoder = new TextDecoder('utf-8', {fatal: true});
            let encoding = 'utf-8';
            try {
                decoder.decode(buffer);
            } catch(e) {
                encoding = 'gbk'; // Fallback to GBK for Chinese content
            }
            console.log('Detected encoding:', encoding);
            
            // Read full content with detected encoding
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsText(fileBlob, encoding);
            });
        }
        
        function parseTxtToc(content) {
            const toc = [];
            const MAX_TOC = 10000;
            const isRoman = (s) => /^[IVXLCDM]+$/i.test(s);
            const patterns = [
                /^\s*[【\[\(（《「『]*\s*(第[零一二三四五六七八九十百千两0-9]{1,8}\s*[章回卷节篇部])\s*[:：、.\-— ]*\s*([^\r\n]{0,60})/i,
                /^\s*[【\[\(（《「『]*\s*([Cc]hapter\s*\d{1,6})\s*[:：、.\-— ]*\s*([^\r\n]{0,60})/,
                /^\s*[【\[\(（《「『]*\s*([Pp]art\s*\d{1,6})\s*[:：、.\-— ]*\s*([^\r\n]{0,60})/,
                /^\s*[【\[\(（《「『]*\s*([IVXLCDM]{1,12})\s*[.\-— ]\s*([^\r\n]{0,60})/
            ];

            let i = 0;
            while (i <= content.length) {
                let lineEnd = content.indexOf('\n', i);
                if (lineEnd === -1) lineEnd = content.length;
                const rawLine = content.slice(i, lineEnd);
                const line = rawLine.replace(/\r$/, '');
                const trimmed = line.trim();
                if (trimmed) {
                    for (const re of patterns) {
                        const m = re.exec(line);
                        if (!m) continue;
                        const marker = String(m[1] || '').trim();
                        if (re === patterns[3] && !isRoman(marker)) break;
                        const suffix = String(m[2] || '').trim();
                        const label = (marker + (suffix ? (' ' + suffix) : '')).trim();
                        const offsetInLine = rawLine.indexOf(m[1]);
                        const pos = offsetInLine >= 0 ? (i + offsetInLine) : i;
                        toc.push({ label: label || trimmed, position: pos });
                        break;
                    }
                    if (toc.length >= MAX_TOC) break;
                }
                i = lineEnd + 1;
            }

            if (toc.length === 0) {
                const len = content.length;
                const chunkSize = 10000;
                for (let p = 0; p < len; p += chunkSize) {
                    toc.push({ label: `Page ${Math.floor(p / chunkSize) + 1}`, position: p });
                    if (toc.length >= MAX_TOC) break;
                }
            }
            return toc;
        }

        // --- 3D Open Book Animation & Reader Logic ---
        let rendition = null;
        let currentBook = null;
        let currentTxtContent = null;
        let currentTxtToc = [];
        let currentEpubToc = [];
        let currentBookId = null;
        let lastTxtProgress = null;
        let lastEpubProgress = null;
        let lastEpubRelocatedHref = null;
        let epubHrefToTocIndex = null;
        let txtScrollHandler = null;
        let txtTouchHandler = null;
        let txtPointerHandler = null;
        let progressAutoSaveTimer = null;
        let isRestoringTxt = false;
        let isClosingReader = false;
        let closeInFlight = null;
        let isAppendingTxt = false;
        let currentTxtTocActiveIndex = -1;
        let currentEpubTocActiveIndex = -1;
        let txtSessionId = 0;
        const TXT_PAGE_SIZE = 3000;
        let txtCharsPerPageCache = { perPage: TXT_PAGE_SIZE, w: 0, h: 0, fontSize: 0, lineHeightPx: 0, padL: 0, padR: 0, padT: 0, padB: 0 };
        let txtChapterPagingCache = { chapterIndex: -1, perPage: 0, start: 0, end: 0, starts: [] };

        function invalidateTxtCharsPerPage() {
            txtCharsPerPageCache = { perPage: TXT_PAGE_SIZE, w: 0, h: 0, fontSize: 0, lineHeightPx: 0, padL: 0, padR: 0, padT: 0, padB: 0 };
            txtChapterPagingCache = { chapterIndex: -1, perPage: 0, start: 0, end: 0, starts: [] };
        }

        function getTxtChapterPagingByAbsPos(absolutePos) {
            if (!currentTxtContent || !Number.isFinite(absolutePos)) return null;
            if (!currentTxtToc || currentTxtToc.length === 0) return null;
            const perPage = Math.max(1, getTxtCharsPerPage());
            const chapterIndex = computeTxtChapterIndexByAbsPos(absolutePos);
            const start = currentTxtToc[chapterIndex] && Number.isFinite(currentTxtToc[chapterIndex].position) ? currentTxtToc[chapterIndex].position : 0;
            const end = (chapterIndex + 1 < currentTxtToc.length) && currentTxtToc[chapterIndex + 1] && Number.isFinite(currentTxtToc[chapterIndex + 1].position)
                ? currentTxtToc[chapterIndex + 1].position
                : currentTxtContent.length;
            const cache = txtChapterPagingCache;
            if (
                cache
                && cache.chapterIndex === chapterIndex
                && cache.perPage === perPage
                && cache.start === start
                && cache.end === end
                && Array.isArray(cache.starts)
                && cache.starts.length > 0
            ) return cache;
            const starts = [Math.max(0, start)];
            const safeEnd = Math.max(starts[0], Math.min(currentTxtContent.length, end));
            const breakChars = new Set(['\n', '。', '！', '？', '.', '!', '?', '；', ';', '，', ',', '、', ' ', '\t']);
            const lookBack = Math.max(40, Math.floor(perPage * 0.22));
            let p = starts[0];
            while (p < safeEnd) {
                const windowEnd = Math.min(safeEnd, p + perPage);
                const windowText = currentTxtContent.slice(p, windowEnd);
                let cut = windowText.length;
                for (let i = windowText.length - 1; i >= 0 && i >= windowText.length - lookBack; i--) {
                    const c = windowText[i];
                    if (breakChars.has(c)) { cut = i + 1; break; }
                }
                if (cut <= 0) cut = windowText.length;
                let next = p + cut;
                if (next <= p) next = Math.min(safeEnd, p + Math.max(1, windowText.length));
                if (next <= p) break;
                starts.push(next);
                p = next;
            }
            if (starts[starts.length - 1] !== safeEnd) starts.push(safeEnd);
            txtChapterPagingCache = { chapterIndex, perPage, start: starts[0], end: safeEnd, starts };
            return txtChapterPagingCache;
        }

        function getTxtCharsPerPage() {
            try {
                const contentArea = document.getElementById('readerContent');
                if (!contentArea) return TXT_PAGE_SIZE;
                const cs = window.getComputedStyle(contentArea);
                const w = contentArea.clientWidth || 0;
                const h = contentArea.clientHeight || 0;
                const fontSize = parseFloat(cs.fontSize || '18') || 18;
                const lineHeightPx = cs.lineHeight === 'normal' ? (fontSize * 1.6) : (parseFloat(cs.lineHeight) || fontSize * 1.6);
                const isPaged = currentFlipMode === 'slide' || currentFlipMode === 'simulation' || currentFlipMode === 'sim';
                let padL = parseFloat(cs.paddingLeft || '0') || 0;
                let padR = parseFloat(cs.paddingRight || '0') || 0;
                let padT = parseFloat(cs.paddingTop || '0') || 0;
                let padB = parseFloat(cs.paddingBottom || '0') || 0;
                if (isPaged) {
                    const rootCs = window.getComputedStyle(document.documentElement);
                    const safeTop = parseFloat(rootCs.getPropertyValue('--safe-top') || '0') || 0;
                    const safeBottom = parseFloat(rootCs.getPropertyValue('--safe-bottom') || '0') || 0;
                    const reader = document.getElementById('readerView');
                    const bottomSheet = reader ? (parseFloat(window.getComputedStyle(reader).getPropertyValue('--reader-bottom-sheet') || '0') || 0) : 0;
                    padL = 24;
                    padR = 24;
                    padT = 56 + safeTop + 18;
                    padB = 82 + safeBottom + 18 + bottomSheet;
                }
                const cache = txtCharsPerPageCache;
                if (
                    cache
                    && cache.perPage
                    && cache.w === w
                    && cache.h === h
                    && cache.fontSize === fontSize
                    && cache.lineHeightPx === lineHeightPx
                    && cache.padL === padL
                    && cache.padR === padR
                    && cache.padT === padT
                    && cache.padB === padB
                ) return cache.perPage;

                const usableW = Math.max(200, w - padL - padR);
                const usableH = Math.max(200, h - padT - padB);
                const linesPerPage = Math.max(6, Math.floor(usableH / Math.max(1, lineHeightPx)));
                const avgCharW = Math.max(6, getTxtAvgCharWidth(cs));
                const charsPerLine = Math.max(10, Math.floor(usableW / avgCharW));
                const perPage = Math.max(300, Math.floor(charsPerLine * linesPerPage * 0.92));
                txtCharsPerPageCache = { perPage, w, h, fontSize, lineHeightPx, padL, padR, padT, padB };
                return perPage;
            } catch (e) {
                return TXT_PAGE_SIZE;
            }
        }
        let currentFlipMode = 'scroll';
        let lastFlipGestureAt = 0;
        let txtParagraphObserver = null;
        let txtSentinelObserver = null;
        let txtTopSentinelObserver = null;
        let txtActiveAnchorId = null;
        let txtActiveAbsPos = NaN;
        let txtProgressPersistTimer = null;
        let txtIntersecting = new Map();
        let txtObserved = new WeakSet();
        let txtLastAppendStart = null;
        let txtLastAppendAt = 0;
        let isPrependingTxt = false;
        let txtLastPrependStart = null;
        let txtLastPrependAt = 0;
        let lastPointerTarget = null;
        let suppressNextContentClickUntil = 0;

        function waitForFontsReady(maxWaitMs = 4500) {
            try {
                if (!document.fonts || !document.fonts.ready) return Promise.resolve();
                return Promise.race([
                    document.fonts.ready,
                    new Promise((resolve) => setTimeout(resolve, maxWaitMs))
                ]);
            } catch (e) {
                return Promise.resolve();
            }
        }

        function nextFrame() {
            return new Promise((resolve) => requestAnimationFrame(() => resolve()));
        }

        async function waitForScrollSettle(el, maxWaitMs = 320) {
            if (!el) return;
            const useLeft = currentFlipMode === 'slide';
            let last = useLeft ? (el.scrollLeft || 0) : (el.scrollTop || 0);
            let stable = 0;
            const start = Date.now();
            while ((Date.now() - start) < maxWaitMs) {
                await nextFrame();
                const cur = useLeft ? (el.scrollLeft || 0) : (el.scrollTop || 0);
                if (Math.abs(cur - last) < 0.5) stable += 1;
                else stable = 0;
                last = cur;
                if (stable >= 2) return;
            }
        }

        function isIOSLike() {
            try {
                const ua = String(navigator.userAgent || '');
                const platform = String(navigator.platform || '');
                const maxTouch = Number(navigator.maxTouchPoints || 0);
                if (/iP(hone|ad|od)/.test(ua)) return true;
                if (platform === 'MacIntel' && maxTouch > 1) return true;
                return false;
            } catch (e) {
                return false;
            }
        }

        let readerInteractionLayerBound = false;
        let readerInteractionLastTouchAt = 0;
        let readerInteractionScrollSyncBound = false;

        function clamp01(n) {
            const v = Number(n);
            if (!Number.isFinite(v)) return 0;
            return Math.max(0, Math.min(1, v));
        }

        function getPctFromClientRect(rect, clientX, clientY) {
            if (!rect || !rect.width || !rect.height) return null;
            const xPct = clamp01((((clientX || 0) - rect.left) / rect.width));
            const yPct = clamp01((((clientY || 0) - rect.top) / rect.height));
            return { xPct, yPct };
        }

        function getReaderIntentFromPct(xPct, yPct) {
            const inCornerW = xPct <= HOTZONE_CORNER_WIDTH_PCT || xPct >= (1 - HOTZONE_CORNER_WIDTH_PCT);
            const inCornerH = yPct <= HOTZONE_CORNER_HEIGHT_PCT || yPct >= (1 - HOTZONE_CORNER_HEIGHT_PCT);
            if (inCornerW && inCornerH) return yPct <= HOTZONE_CORNER_HEIGHT_PCT ? 'prev' : 'next';
            return 'menu';
        }

        function getReaderInteractionIntentFromClientXY(layerRect, clientX, clientY) {
            const pct = getPctFromClientRect(layerRect, clientX, clientY);
            if (!pct) return null;
            return getReaderIntentFromPct(pct.xPct, pct.yPct);
        }

        function getReaderInteractionIntent(clientX, clientY) {
            const layer = document.getElementById('readerInteractionLayer');
            if (!layer) return null;
            const rect = layer.getBoundingClientRect ? layer.getBoundingClientRect() : null;
            return getReaderInteractionIntentFromClientXY(rect, clientX, clientY);
        }

        function getContentPaddingTopPx(contentArea) {
            if (!contentArea) return 0;
            try {
                const cs = window.getComputedStyle(contentArea);
                const padTop = parseFloat(cs.paddingTop || '0');
                return Number.isFinite(padTop) ? Math.max(0, padTop) : 0;
            } catch (e) {
                return 0;
            }
        }

        function getScrollLineIndex(scrollTop, paddingTopPx, lineHeightPx) {
            const s = Number(scrollTop);
            const p = Number(paddingTopPx);
            const lh = Number(lineHeightPx);
            if (!Number.isFinite(s) || !Number.isFinite(p) || !Number.isFinite(lh) || lh <= 0) return 0;
            return Math.max(0, Math.floor(Math.max(0, s - p) / lh));
        }

        function getScrollTopFromLineIndex(lineIndex, paddingTopPx, lineHeightPx) {
            const idx = Number(lineIndex);
            const p = Number(paddingTopPx);
            const lh = Number(lineHeightPx);
            if (!Number.isFinite(idx) || !Number.isFinite(p) || !Number.isFinite(lh) || lh <= 0) return 0;
            return Math.max(0, Math.floor(idx) * lh + p);
        }

        function syncReaderInteractionLayerPosition() {
            const content = document.getElementById('readerContent');
            const layer = document.getElementById('readerInteractionLayer');
            if (!content || !layer) return;
            const x = content.scrollLeft || 0;
            const y = content.scrollTop || 0;
            layer.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        }

        function dispatchReaderInteractionIntent(intent, e) {
            if (!intent) return;
            if (e && e.stopPropagation) e.stopPropagation();

            if (intent === 'menu') {
                toggleMenu({ event: e, ignoreGuard: true });
                return;
            }

            const readerView = document.getElementById('readerView');
            if (readerView && readerView.classList.contains('menu-visible')) return;
            if (hasAnyReaderPanelOpen()) return;

            lastFlipGestureAt = Date.now();
            if (intent === 'prev') {
                if (currentTxtContent && (currentFlipMode === 'slide' || currentFlipMode === 'simulation')) turnTxtPaged(-1);
                else scrollPage(-1);
                return;
            }
            if (intent === 'next') {
                if (currentTxtContent && (currentFlipMode === 'slide' || currentFlipMode === 'simulation')) turnTxtPaged(1);
                else scrollPage(1);
            }
        }

        function bindReaderInteractionLayer() {
            if (readerInteractionLayerBound) return;
            const layer = document.getElementById('readerInteractionLayer');
            const content = document.getElementById('readerContent');
            if (!layer || !content) return;
            readerInteractionLayerBound = true;

            const onTouchEnd = (e) => {
                readerInteractionLastTouchAt = Date.now();
                if (!e || !e.changedTouches || !e.changedTouches[0]) return;
                const t = e.changedTouches[0];
                const intent = getReaderInteractionIntent(t.clientX || 0, t.clientY || 0);
                dispatchReaderInteractionIntent(intent, e);
            };
            const onClick = (e) => {
                if (!e) return;
                if ((Date.now() - readerInteractionLastTouchAt) < 650) return;
                const intent = getReaderInteractionIntent(e.clientX || 0, e.clientY || 0);
                dispatchReaderInteractionIntent(intent, e);
            };
            layer.addEventListener('touchend', onTouchEnd, { passive: true });
            layer.addEventListener('click', onClick, { passive: true });

            if (!readerInteractionScrollSyncBound) {
                readerInteractionScrollSyncBound = true;
                const sync = () => syncReaderInteractionLayerPosition();
                content.addEventListener('scroll', sync, { passive: true });
                window.addEventListener('resize', sync, { passive: true });
                setTimeout(sync, 0);
            }
        }

        let readerBottomClockTimer = null;
        let readerBottomBattery = null;

        function updateReaderBottomClock() {
            const el = document.getElementById('readerBottomClock');
            if (!el) return;
            const d = new Date();
            const hh = String(d.getHours()).padStart(2, '0');
            const mm = String(d.getMinutes()).padStart(2, '0');
            el.textContent = `${hh}:${mm}`;
        }

        function setReaderBottomBatteryLevel(level01) {
            const fill = document.getElementById('readerBatteryFill');
            if (!fill) return;
            const lvl = Number.isFinite(level01) ? Math.max(0, Math.min(1, level01)) : NaN;
            const maxW = 18.8;
            fill.setAttribute('width', Number.isFinite(lvl) ? String(Math.round(maxW * lvl * 10) / 10) : '0');
        }

        async function ensureReaderBottomBattery() {
            if (readerBottomBattery) return;
            const icon = document.querySelector('.reader-bottom-status-battery');
            if (!navigator || typeof navigator.getBattery !== 'function') {
                if (icon) icon.classList.add('unknown');
                setReaderBottomBatteryLevel(0.72);
                return;
            }
            try {
                const b = await navigator.getBattery();
                if (!b) return;
                readerBottomBattery = b;
                if (icon) icon.classList.remove('unknown');
                const sync = () => setReaderBottomBatteryLevel(b.level);
                sync();
                try { b.addEventListener('levelchange', sync); } catch (e) {}
                try { b.addEventListener('chargingchange', sync); } catch (e) {}
            } catch (e) {}
        }

        function updateReaderBottomStatusPage() {
            const out = document.getElementById('readerBottomPage');
            if (!out) return;
            const top = document.getElementById('readerPageIndicator');
            const txt = top ? String(top.textContent || '').trim() : '';
            if (txt) {
                out.textContent = txt;
                return;
            }
            if (lastEpubProgress && Number.isFinite(lastEpubProgress.percent)) {
                out.textContent = `${lastEpubProgress.percent}%`;
                return;
            }
            out.textContent = '';
        }

        function ensureReaderBottomStatusTimer() {
            if (readerBottomClockTimer) return;
            updateReaderBottomClock();
            try { updateReaderBottomStatusPage(); } catch (e) {}
            const now = new Date();
            const msToNextMinute = (60 - now.getSeconds()) * 1000 - now.getMilliseconds();
            setTimeout(() => {
                updateReaderBottomClock();
                readerBottomClockTimer = setInterval(updateReaderBottomClock, 30000);
            }, Math.max(250, msToNextMinute));
            try { ensureReaderBottomBattery(); } catch (e) {}
        }

        function trackLastPointerTarget(e) {
            lastPointerTarget = e && e.target ? e.target : null;
        }

        document.addEventListener('pointerdown', trackLastPointerTarget, { capture: true, passive: true });
        document.addEventListener('touchstart', trackLastPointerTarget, { capture: true, passive: true });
        document.addEventListener('mousedown', trackLastPointerTarget, { capture: true, passive: true });

        let readerGlobalGesturesBound = false;
        function bindReaderGlobalGestures() {
            if (readerGlobalGesturesBound) return;
            const reader = document.getElementById('readerView');
            if (!reader) return;
            readerGlobalGesturesBound = true;

            let lastTouchEndAt = 0;

            let tapStartX = 0;
            let tapStartY = 0;
            let tapStartAt = 0;
            let tapMoved = false;

            let edgeStartX = 0;
            let edgeStartY = 0;
            let edgeStartAt = 0;
            let edgeCandidate = false;
            let edgeMoved = false;

            const isReaderActive = () => {
                try { return reader.classList.contains('active') && !reader.classList.contains('closing'); } catch (e) { return false; }
            };

            const isSwipeBack = (dx, dy, dt) => {
                if (dt > 650) return false;
                if (dx < 78) return false;
                if (Math.abs(dy) > 44) return false;
                if (Math.abs(dx) < Math.abs(dy) * 1.35) return false;
                return true;
            };

            document.addEventListener('touchstart', (e) => {
                if (!isReaderActive()) return;
                if (!e || !e.touches || !e.touches[0]) return;
                const t = e.touches[0];
                tapStartX = t.clientX || 0;
                tapStartY = t.clientY || 0;
                tapStartAt = Date.now();
                tapMoved = false;

                edgeStartX = tapStartX;
                edgeStartY = tapStartY;
                edgeStartAt = tapStartAt;
                edgeMoved = false;
                edgeCandidate = (tapStartX <= 16);
            }, { capture: true, passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!isReaderActive()) return;
                if (!e || !e.touches || !e.touches[0]) return;
                const t = e.touches[0];
                const dx = (t.clientX || 0) - tapStartX;
                const dy = (t.clientY || 0) - tapStartY;
                if (!tapMoved && (Math.abs(dx) > 12 || Math.abs(dy) > 12)) tapMoved = true;

                const edx = (t.clientX || 0) - edgeStartX;
                const edy = (t.clientY || 0) - edgeStartY;
                if (!edgeMoved && (Math.abs(edx) > 10 || Math.abs(edy) > 10)) edgeMoved = true;
            }, { capture: true, passive: true });

            document.addEventListener('touchend', (e) => {
                if (!isReaderActive()) return;
                lastTouchEndAt = Date.now();
                if (!e || !e.changedTouches || !e.changedTouches[0]) return;
                const t = e.changedTouches[0];
                const endX = t.clientX || 0;
                const endY = t.clientY || 0;
                const now = Date.now();

                if (edgeCandidate && edgeMoved) {
                    const dx = endX - edgeStartX;
                    const dy = endY - edgeStartY;
                    const dt = Math.max(1, now - edgeStartAt);
                    if (isSwipeBack(dx, dy, dt)) {
                        suppressNextContentClickUntil = Date.now() + 700;
                        if (hasAnyReaderPanelOpen()) {
                            toggleMenu({ event: e, ignoreGuard: true });
                            return;
                        }
                        closeBook();
                        return;
                    }
                }
            }, { capture: true, passive: true });
        }

        let txtFlipTouchStartHandler = null;
        let txtFlipTouchEndHandler = null;
        let txtFlipTouchMoveHandler = null;
        let txtFlipTouchCancelHandler = null;
        let txtFlipPointerDownHandler = null;
        let txtFlipPointerMoveHandler = null;
        let txtFlipPointerUpHandler = null;
        let txtFlipPointerCancelHandler = null;
        let txtFlipStartX = 0;
        let txtFlipStartY = 0;
        let txtFlipStartAt = 0;
        let txtFlipPointerId = null;

        let simDragState = null;
        function cleanupSimDragState() {
            if (!simDragState) return;
            try {
                const { surface, turn, cur, next } = simDragState;
                if (cur) cur.style.opacity = '1';
                if (next) next.innerHTML = '';
                if (turn && turn.parentElement) turn.parentElement.removeChild(turn);
                if (surface) surface.style.perspective = '';
            } catch (e) {}
            simDragState = null;
            txtPagedTurnLock = false;
        }

        function detachTxtFlipGestureHandlers() {
            const layer = document.getElementById('readerInteractionLayer');
            if (!layer) return;
            if (txtFlipTouchStartHandler) layer.removeEventListener('touchstart', txtFlipTouchStartHandler);
            if (txtFlipTouchEndHandler) layer.removeEventListener('touchend', txtFlipTouchEndHandler);
            if (txtFlipTouchMoveHandler) layer.removeEventListener('touchmove', txtFlipTouchMoveHandler);
            if (txtFlipTouchCancelHandler) layer.removeEventListener('touchcancel', txtFlipTouchCancelHandler);
            if (txtFlipPointerDownHandler) layer.removeEventListener('pointerdown', txtFlipPointerDownHandler);
            if (txtFlipPointerMoveHandler) layer.removeEventListener('pointermove', txtFlipPointerMoveHandler);
            if (txtFlipPointerUpHandler) layer.removeEventListener('pointerup', txtFlipPointerUpHandler);
            if (txtFlipPointerCancelHandler) layer.removeEventListener('pointercancel', txtFlipPointerCancelHandler);
            txtFlipTouchStartHandler = null;
            txtFlipTouchEndHandler = null;
            txtFlipTouchMoveHandler = null;
            txtFlipTouchCancelHandler = null;
            txtFlipPointerDownHandler = null;
            txtFlipPointerMoveHandler = null;
            txtFlipPointerUpHandler = null;
            txtFlipPointerCancelHandler = null;
            txtFlipPointerId = null;
            cleanupSimDragState();
        }

        function attachTxtFlipGestureHandlers(session = txtSessionId) {
            const contentArea = document.getElementById('readerContent');
            const layer = document.getElementById('readerInteractionLayer');
            if (!contentArea || !layer) return;
            detachTxtFlipGestureHandlers();
            const begin = (x, y, t) => {
                txtFlipStartX = x;
                txtFlipStartY = y;
                txtFlipStartAt = t;
            };
            const maybeTurn = (endX, endY, endT) => {
                if (session !== txtSessionId) return;
                if (!currentTxtContent) return;
                if (currentFlipMode !== 'slide' && currentFlipMode !== 'simulation') return;
                if (hasAnyReaderPanelOpen()) return;
                if (simDragState) return;
                const dx = endX - txtFlipStartX;
                const dy = endY - txtFlipStartY;
                const dt = Math.max(1, endT - txtFlipStartAt);
                if (Math.abs(dx) < 44) return;
                if (Math.abs(dx) < Math.abs(dy) * 1.3) return;
                if (dt > 650) return;
                const direction = dx < 0 ? 1 : -1;
                lastFlipGestureAt = Date.now();
                turnTxtPaged(direction);
            };

            const ensureSimDrag = (direction) => {
                if (simDragState) return true;
                if (currentFlipMode !== 'simulation') return false;
                if (txtPagedTurnLock) return false;
                const surface = contentArea.querySelector('.sim-surface');
                const cur = surface ? surface.querySelector('.sim-current') : null;
                const next = surface ? surface.querySelector('.sim-next') : null;
                if (!surface || !cur || !next) return false;
                const nextIndex = txtPagedIndex + (direction > 0 ? 1 : -1);
                if (nextIndex < 0 || nextIndex >= txtPagedPages.length) return false;
                txtPagedTurnLock = true;
                next.innerHTML = `<div class="paged-page">${txtPagedPages[nextIndex] || ''}</div>`;
                const pageHtml = cur.innerHTML || '';
                const safePageHtml = pageHtml.replace(/\sid="txt-[^"]+"/g, '');
                const turn = document.createElement('div');
                turn.className = 'sim-turn';
                turn.classList.add(direction > 0 ? 'turn-forward' : 'turn-backward');
                turn.innerHTML = `<div class="sim-sheet"><div class="sim-front">${safePageHtml}</div><div class="sim-back">${safePageHtml}</div><div class="sim-shadow"></div></div>`;
                turn.style.transition = 'none';
                turn.style.transformOrigin = direction > 0 ? 'left center' : 'right center';
                turn.style.transform = 'rotateY(0deg)';
                surface.appendChild(turn);
                cur.style.opacity = '0';
                simDragState = {
                    surface,
                    cur,
                    next,
                    turn,
                    direction,
                    nextIndex,
                    lastX: txtFlipStartX,
                    lastT: txtFlipStartAt,
                    startX: txtFlipStartX
                };
                return true;
            };

            const updateSimDrag = (x) => {
                if (!simDragState) return;
                const w = contentArea.clientWidth || 1;
                const dx = x - simDragState.startX;
                const progress = Math.max(0, Math.min(1, Math.abs(dx) / Math.max(1, w)));
                const deg = (simDragState.direction > 0 ? -180 : 180) * progress;
                simDragState.turn.style.transform = `rotateY(${deg}deg)`;
                try {
                    const sh = simDragState.turn.querySelector('.sim-shadow');
                    if (sh) sh.style.opacity = String(Math.min(1, 0.15 + progress * 0.9));
                } catch (e) {}
                simDragState.lastX = x;
                simDragState.lastT = Date.now();
                simDragState.progress = progress;
            };

            const finishSimDrag = (x) => {
                if (!simDragState) return false;
                const w = contentArea.clientWidth || 1;
                const dx = x - simDragState.startX;
                const progress = Math.max(0, Math.min(1, Math.abs(dx) / Math.max(1, w)));
                const now = Date.now();
                const dt = Math.max(1, now - (simDragState.lastT || txtFlipStartAt));
                const vx = (x - (simDragState.lastX || x)) / dt;
                const commit = progress > 0.42 || (simDragState.direction > 0 ? vx < -0.85 : vx > 0.85);
                const finalDeg = commit ? (simDragState.direction > 0 ? -180 : 180) : 0;
                simDragState.turn.style.transition = commit
                    ? 'transform 520ms cubic-bezier(0.2, 0.8, 0.2, 1)'
                    : 'transform 360ms cubic-bezier(0.2, 0.8, 0.2, 1)';
                simDragState.turn.style.transform = `rotateY(${finalDeg}deg)`;
                setTimeout(() => {
                    const st = simDragState;
                    if (!st) return;
                    if (commit) {
                        txtPagedIndex = st.nextIndex;
                        st.cur.innerHTML = st.next.innerHTML;
                        st.cur.style.opacity = '1';
                        st.next.innerHTML = '';
                        if (st.turn.parentElement) st.turn.parentElement.removeChild(st.turn);
                        simDragState = null;
                        txtPagedTurnLock = false;
                        lastFlipGestureAt = Date.now();
                        setTxtActiveFromPagedIndex();
                        schedulePersistTxtAnchorProgress('auto');
                    } else {
                        cleanupSimDragState();
                    }
                }, commit ? 560 : 420);
                return true;
            };

            const maybeStartSimByMove = (x, y) => {
                if (session !== txtSessionId) return;
                if (!currentTxtContent) return;
                if (currentFlipMode !== 'simulation') return;
                if (hasAnyReaderPanelOpen()) return;
                if (simDragState) return;
                const dx = x - txtFlipStartX;
                const dy = y - txtFlipStartY;
                if (Math.abs(dx) < 10) return;
                if (Math.abs(dx) < Math.abs(dy) * 1.15) return;
                const w = contentArea.clientWidth || 1;
                const dir = dx < 0 ? 1 : -1;
                const edgeOk = dir > 0 ? (txtFlipStartX > w * 0.70) : (txtFlipStartX < w * 0.30);
                if (!edgeOk) return;
                if (!ensureSimDrag(dir)) return;
                updateSimDrag(x);
            };
            txtFlipTouchStartHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e || !e.touches || !e.touches[0]) return;
                const t = e.touches[0];
                begin(t.clientX || 0, t.clientY || 0, Date.now());
            };
            txtFlipTouchMoveHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e || !e.touches || !e.touches[0]) return;
                const t = e.touches[0];
                if (currentFlipMode === 'simulation') {
                    if (!simDragState) maybeStartSimByMove(t.clientX || 0, t.clientY || 0);
                    else updateSimDrag(t.clientX || 0);
                }
            };
            txtFlipTouchEndHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e || !e.changedTouches || !e.changedTouches[0]) return;
                const t = e.changedTouches[0];
                if (currentFlipMode === 'simulation' && simDragState) {
                    finishSimDrag(t.clientX || 0);
                    return;
                }
                maybeTurn(t.clientX || 0, t.clientY || 0, Date.now());
            };
            txtFlipTouchCancelHandler = () => {
                cleanupSimDragState();
            };
            txtFlipPointerDownHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e) return;
                if (e.pointerType === 'mouse' && e.buttons !== 1) return;
                txtFlipPointerId = e.pointerId;
                begin(e.clientX || 0, e.clientY || 0, Date.now());
                try { contentArea.setPointerCapture(e.pointerId); } catch (err) {}
            };
            txtFlipPointerMoveHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e) return;
                if (txtFlipPointerId !== null && e.pointerId !== txtFlipPointerId) return;
                if (e.pointerType === 'mouse' && e.buttons !== 1) {
                    txtFlipPointerId = null;
                    cleanupSimDragState();
                    return;
                }
                if (currentFlipMode === 'simulation') {
                    if (!simDragState) maybeStartSimByMove(e.clientX || 0, e.clientY || 0);
                    else updateSimDrag(e.clientX || 0);
                }
            };
            txtFlipPointerUpHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e) return;
                if (txtFlipPointerId !== null && e.pointerId !== txtFlipPointerId) return;
                txtFlipPointerId = null;
                try { layer.releasePointerCapture(e.pointerId); } catch (err) {}
                if (currentFlipMode === 'simulation' && simDragState) {
                    finishSimDrag(e.clientX || 0);
                    return;
                }
                maybeTurn(e.clientX || 0, e.clientY || 0, Date.now());
            };
            txtFlipPointerCancelHandler = () => {
                txtFlipPointerId = null;
                cleanupSimDragState();
            };
            layer.addEventListener('touchstart', txtFlipTouchStartHandler, { passive: true });
            layer.addEventListener('touchmove', txtFlipTouchMoveHandler, { passive: true });
            layer.addEventListener('touchend', txtFlipTouchEndHandler, { passive: true });
            layer.addEventListener('touchcancel', txtFlipTouchCancelHandler, { passive: true });
            layer.addEventListener('pointerdown', txtFlipPointerDownHandler, { passive: true });
            layer.addEventListener('pointermove', txtFlipPointerMoveHandler, { passive: true });
            layer.addEventListener('pointerup', txtFlipPointerUpHandler, { passive: true });
            layer.addEventListener('pointercancel', txtFlipPointerCancelHandler, { passive: true });
        }

        function escapeHtml(s) {
            const str = String(s ?? '');
            return str.replace(/[&<>"']/g, (c) => {
                if (c === '&') return '&amp;';
                if (c === '<') return '&lt;';
                if (c === '>') return '&gt;';
                if (c === '"') return '&quot;';
                return '&#39;';
            });
        }

        function absPosFromAnchorId(anchorId) {
            if (!anchorId) return NaN;
            const m = /-a(\d+)$/.exec(String(anchorId));
            if (!m) return NaN;
            const n = parseInt(m[1], 10);
            return Number.isFinite(n) ? n : NaN;
        }

        function txtAnchorIdForAbsPos(bookId, absPos) {
            return `txt-${bookId}-a${absPos}`;
        }

        function computeTxtChapterIndexByAbsPos(absPos) {
            if (!currentTxtToc || currentTxtToc.length === 0) return 0;
            if (!Number.isFinite(absPos) || absPos < 0) return 0;
            let lo = 0;
            let hi = currentTxtToc.length - 1;
            let ans = 0;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const p = currentTxtToc[mid] && Number.isFinite(currentTxtToc[mid].position) ? currentTxtToc[mid].position : 0;
                if (p <= absPos) {
                    ans = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            return ans;
        }

        function teardownTxtObservers() {
            if (txtParagraphObserver) {
                try { txtParagraphObserver.disconnect(); } catch (e) {}
                txtParagraphObserver = null;
            }
            if (txtSentinelObserver) {
                try { txtSentinelObserver.disconnect(); } catch (e) {}
                txtSentinelObserver = null;
            }
            if (txtTopSentinelObserver) {
                try { txtTopSentinelObserver.disconnect(); } catch (e) {}
                txtTopSentinelObserver = null;
            }
            if (txtProgressPersistTimer) {
                clearTimeout(txtProgressPersistTimer);
                txtProgressPersistTimer = null;
            }
            txtActiveAnchorId = null;
            txtActiveAbsPos = NaN;
            txtIntersecting = new Map();
            txtObserved = new WeakSet();
            txtLastAppendStart = null;
            txtLastAppendAt = 0;
            isPrependingTxt = false;
            txtLastPrependStart = null;
            txtLastPrependAt = 0;
        }

        function scrollParagraphIntoView(el, options = null) {
            const contentArea = document.getElementById('readerContent');
            if (!el || !contentArea) return;
            const opts = options || {};
            if (currentFlipMode === 'slide') {
                try { el.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'start' }); } catch (e) {}
                return;
            }
            try {
                const cs = window.getComputedStyle(contentArea);
                const padTop = parseFloat(cs.paddingTop) || 0;
                const base = Math.max(0, (el.offsetTop || 0) - padTop);
                const extra = Number.isFinite(opts.anchorOffset) ? opts.anchorOffset : 0;
                const maxScroll = Math.max(0, contentArea.scrollHeight - contentArea.clientHeight);
                contentArea.scrollTop = Math.max(0, Math.min(maxScroll, base + Math.max(0, extra)));
            } catch (e) {
                try { el.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' }); } catch (err) {}
            }
        }

        function schedulePersistTxtAnchorProgress(reason = 'auto') {
            if (reason === 'auto' && hasAnyReaderPanelOpen()) return;
            if (isRestoringTxt) return;
            if (isClosingReader && reason === 'auto') return;
            if (!currentBookId || !currentTxtContent) return;
            if (!txtActiveAnchorId || !Number.isFinite(txtActiveAbsPos)) return;
            if (txtProgressPersistTimer) clearTimeout(txtProgressPersistTimer);
            txtProgressPersistTimer = setTimeout(() => persistTxtAnchorProgress(reason), 250);
        }

        async function persistTxtAnchorProgress(reason = 'auto') {
            if (!currentBookId || !currentTxtContent) return;
            if (!txtActiveAnchorId || !Number.isFinite(txtActiveAbsPos)) return;
            const CHUNK_SIZE = 15000;
            const absPos = Math.max(0, Math.min(currentTxtContent.length - 1, txtActiveAbsPos));
            const ratio = currentTxtContent.length > 0 ? (absPos / currentTxtContent.length) : 0;
            const percent = absPos > 0 ? Math.min(100, Math.max(1, Math.round(ratio * 100))) : 0;
            const chapterIndex = computeTxtChapterIndexByAbsPos(absPos);
            const chunkStart = Math.max(0, Math.floor(absPos / CHUNK_SIZE) * CHUNK_SIZE);
            const contentArea = document.getElementById('readerContent');
            const isSlide = currentFlipMode === 'slide';
            const scrollPos = contentArea ? (isSlide ? contentArea.scrollLeft : contentArea.scrollTop) : 0;
            const nearEdge = contentArea ? (scrollPos <= 80) : false;
            const padTop = (!isSlide && contentArea) ? getContentPaddingTopPx(contentArea) : 0;
            const lineIndex = (!isSlide && contentArea) ? getScrollLineIndex(scrollPos, padTop, LINE_HEIGHT) : null;
            let anchorOffset = 0;
            if (!isSlide && contentArea && txtActiveAnchorId) {
                try {
                    const el = document.getElementById(txtActiveAnchorId);
                    if (el && contentArea.contains(el)) {
                        const cs = window.getComputedStyle(contentArea);
                        const padTop = parseFloat(cs.paddingTop) || 0;
                        const base = Math.max(0, (el.offsetTop || 0) - padTop);
                        anchorOffset = Math.max(0, Math.min((contentArea.scrollTop || 0) - base, Math.max(0, el.offsetHeight || 0)));
                    }
                } catch (e) {}
            }
            lastTxtProgress = { absolutePos: absPos, percent, chunkStart, ratio, chapterIndex, activeElementId: txtActiveAnchorId, anchorOffset, lineIndex };
            setActiveTxtTocIndex(chapterIndex);
            updatePageIndicatorByTxtPos(absPos);
            debugLog('saveTxtProgressFromView', { reason, data: lastTxtProgress });
            await storage.saveProgress(
                currentBookId,
                String(absPos),
                percent,
                scrollPos,
                chunkStart,
                { kind: 'txt', ratio, chapterIndex, activeElementId: txtActiveAnchorId, anchorOffset, lineIndex, reason, nearEdge, flipMode: currentFlipMode }
            );
        }

        function ensureTxtObservers(session = txtSessionId) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            if (!txtParagraphObserver) {
                txtParagraphObserver = new IntersectionObserver((entries) => {
                    if (session !== txtSessionId) return;
                    if (isClosingReader) return;
                    const rootRect = contentArea.getBoundingClientRect();
                    for (const entry of entries) {
                        const el = entry.target;
                        if (!el || el.getAttribute('data-anchor') === '1') continue;
                        const id = el.id || null;
                        if (!id) continue;
                        if (!entry.isIntersecting) {
                            txtIntersecting.delete(id);
                            continue;
                        }
                        const relPrimary = currentFlipMode === 'slide'
                            ? (entry.boundingClientRect.left - rootRect.left)
                            : (entry.boundingClientRect.top - rootRect.top);
                        txtIntersecting.set(id, { ratio: entry.intersectionRatio || 0, relPrimary, el });
                    }
                    if (txtIntersecting.size === 0) return;
                    let best = null;
                    const targetPrimary = currentFlipMode === 'slide'
                        ? ((contentArea.clientWidth || 1) * 0.2)
                        : ((contentArea.clientHeight || 1) * 0.35);
                    for (const v of txtIntersecting.values()) {
                        if (!v || !v.el) continue;
                        if (!best) {
                            best = v;
                            continue;
                        }
                        const aDelta = Math.abs((v.relPrimary || 0) - targetPrimary);
                        const bDelta = Math.abs((best.relPrimary || 0) - targetPrimary);
                        if (aDelta < bDelta) {
                            best = v;
                            continue;
                        }
                        if (Math.abs(aDelta - bDelta) <= 0.5 && (v.ratio || 0) > (best.ratio || 0)) {
                            best = v;
                        }
                    }
                    if (!best || !best.el) return;
                    const abs = parseInt(best.el.getAttribute('data-abs') || 'NaN', 10);
                    if (!Number.isFinite(abs)) return;
                    const nextId = best.el.id || null;
                    if (!nextId || nextId === txtActiveAnchorId) return;
                    txtActiveAnchorId = nextId;
                    txtActiveAbsPos = abs;
                    updateActiveTxtTocByPos(abs);
                    schedulePersistTxtAnchorProgress('auto');
                }, {
                    root: contentArea,
                    rootMargin: '0px 0px 0px 0px',
                    threshold: [0, 0.01]
                });
            }
            if (!txtSentinelObserver) {
                txtSentinelObserver = new IntersectionObserver((entries) => {
                    if (session !== txtSessionId) return;
                    if (isRestoringTxt) return;
                    if (isClosingReader) return;
                    if (hasAnyReaderPanelOpen()) return;
                    for (const entry of entries) {
                        if (entry.isIntersecting) maybeAutoAppendTxt(true);
                    }
                }, { root: contentArea, threshold: 0.1 });
            }
            if (!txtTopSentinelObserver) {
                txtTopSentinelObserver = new IntersectionObserver((entries) => {
                    if (session !== txtSessionId) return;
                    if (isRestoringTxt) return;
                    if (isClosingReader) return;
                    if (hasAnyReaderPanelOpen()) return;
                    for (const entry of entries) {
                        if (entry.isIntersecting) maybeAutoPrependTxt(true);
                    }
                }, { root: contentArea, threshold: 0.1 });
            }
        }

        function observeTxtContainer(session = txtSessionId) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            ensureTxtObservers(session);
            if (txtParagraphObserver) {
                const paras = Array.from(contentArea.querySelectorAll('p[data-abs]'));
                for (const p of paras) {
                    if (!p || p.getAttribute('data-anchor') === '1') continue;
                    if (txtObserved.has(p)) continue;
                    txtObserved.add(p);
                    try { txtParagraphObserver.observe(p); } catch (e) {}
                }
            }
            if (txtSentinelObserver) {
                const sentinel = contentArea.querySelector('[data-txt-sentinel="1"]');
                if (sentinel) {
                    try { txtSentinelObserver.observe(sentinel); } catch (e) {}
                }
            }
            if (txtTopSentinelObserver) {
                const topSentinel = contentArea.querySelector('[data-txt-top-sentinel="1"]');
                if (topSentinel) {
                    try { txtTopSentinelObserver.observe(topSentinel); } catch (e) {}
                }
            }
        }

        function hasAnyReaderPanelOpen() {
            const tocPanel = document.getElementById('tocPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const queryPanel = document.getElementById('queryPanel');
            return (tocPanel && tocPanel.classList.contains('active'))
                || (settingsPanel && settingsPanel.classList.contains('active'))
                || (moreMenu && moreMenu.classList.contains('active'))
                || (queryPanel && queryPanel.classList.contains('active'));
        }

        let tocIsReverse = false;
        let currentTocKind = null;
        let tocScrollTimer = null;

        function updateTocOrderButtonLabel() {
            const btn = document.getElementById('tocOrderBtn');
            if (!btn) return;
            btn.textContent = tocIsReverse ? '倒序' : '正序';
        }

        function setTocScrolling(active) {
            const tocList = document.getElementById('tocList');
            if (!tocList) return;
            if (active) tocList.classList.add('scrolling');
            else tocList.classList.remove('scrolling');
        }

        function armTocScrollFade() {
            setTocScrolling(true);
            if (tocScrollTimer) {
                try { clearTimeout(tocScrollTimer); } catch (e) {}
            }
            tocScrollTimer = setTimeout(() => setTocScrolling(false), 3000);
        }

        function onTocListScroll() {
            armTocScrollFade();
        }

        function bindTocListSmartScroll() {
            const tocList = document.getElementById('tocList');
            if (!tocList) return;
            if (tocList.dataset && tocList.dataset.smartScrollBound === '1') return;
            tocList.addEventListener('scroll', onTocListScroll, { passive: true });
            if (tocList.dataset) tocList.dataset.smartScrollBound = '1';
        }

        function getTxtChapterWordCountByIndex(idx) {
            if (!currentTxtToc || currentTxtToc.length === 0) return 0;
            if (!currentTxtContent) return 0;
            const i = Math.max(0, Math.min(currentTxtToc.length - 1, Math.floor(idx)));
            const curPos = currentTxtToc[i] && Number.isFinite(Number(currentTxtToc[i].position)) ? Number(currentTxtToc[i].position) : 0;
            const nextPos = (i + 1 < currentTxtToc.length) && currentTxtToc[i + 1] && Number.isFinite(Number(currentTxtToc[i + 1].position))
                ? Number(currentTxtToc[i + 1].position)
                : currentTxtContent.length;
            return Math.max(0, Math.floor(nextPos - curPos));
        }

        function getEpubChapterWordCount(chapter) {
            if (!chapter) return 0;
            const wc = chapter.wordCount;
            if (Number.isFinite(Number(wc))) return Math.max(0, Math.floor(Number(wc)));
            const content = chapter.content;
            if (content && typeof content.length === 'number') return Math.max(0, Math.floor(content.length));
            return 0;
        }

        function renderTocList() {
            const tocList = document.getElementById('tocList');
            if (!tocList) return;
            bindTocListSmartScroll();
            const tocSubtitleEl = document.querySelector('#tocPanel .toc-subtitle');
            if (currentTocKind === 'epub') {
                const chapters = Array.isArray(currentEpubToc) ? currentEpubToc : [];
                if (tocSubtitleEl) tocSubtitleEl.textContent = `共 ${chapters.length} 章`;
                if (chapters.length === 0) {
                    tocList.innerHTML = '<div class="reader-message reader-message--pad-20">暂无目录</div>';
                    return;
                }
                const displayedChapters = tocIsReverse ? [...chapters].reverse() : chapters;
                tocList.innerHTML = displayedChapters.map((chapter) => {
                    const originalIndex = Number.isFinite(Number(chapter && chapter._index)) ? Number(chapter._index) : 0;
                    const href = String(chapter && chapter.href ? chapter.href : '').replace(/'/g, "\\'");
                    const label = String(chapter && chapter.label ? chapter.label : '');
                    const words = getEpubChapterWordCount(chapter);
                    return `
                            <div class="toc-item" data-epub-index="${originalIndex}" onclick="event.stopPropagation(); handleEpubTocClick(${originalIndex}, '${href}')">
                                <span>${label}</span>
                                <span class="toc-item-words">${words}字</span>
                            </div>
                        `;
                }).join('');
                if (Number.isFinite(currentEpubTocActiveIndex) && currentEpubTocActiveIndex >= 0) setActiveEpubTocIndex(currentEpubTocActiveIndex);
                return;
            }
            const chapters = Array.isArray(currentTxtToc) ? currentTxtToc : [];
            if (tocSubtitleEl) tocSubtitleEl.textContent = `共 ${chapters.length} 章`;
            if (chapters.length === 0) {
                tocList.innerHTML = '<div class="reader-message reader-message--pad-20">暂无目录</div>';
                return;
            }
            const displayedChapters = tocIsReverse ? [...chapters].reverse() : chapters;
            tocList.innerHTML = displayedChapters.map((item) => {
                const originalIndex = Number.isFinite(Number(item && item._index)) ? Number(item._index) : 0;
                const pos = item && Number.isFinite(Number(item.position)) ? Number(item.position) : 0;
                const label = String(item && item.label ? item.label : '');
                const words = (item && Number.isFinite(Number(item.wordCount))) ? Math.max(0, Math.floor(Number(item.wordCount))) : getTxtChapterWordCountByIndex(originalIndex);
                return `
                                <div class="toc-item" data-toc-index="${originalIndex}" onclick="event.stopPropagation(); handleTxtTocClick(${pos}, ${originalIndex})">
                                    <span>${label}</span>
                                    <span class="toc-item-words">${words}字</span>
                                </div>
                            `;
            }).join('');
            if (Number.isFinite(currentTxtTocActiveIndex) && currentTxtTocActiveIndex >= 0) setActiveTxtTocIndex(currentTxtTocActiveIndex);
        }

        function toggleTocOrder() {
            tocIsReverse = !tocIsReverse;
            updateTocOrderButtonLabel();
            renderTocList();
            const tocList = document.getElementById('tocList');
            if (tocList) tocList.scrollTop = 0;
        }

        function setActiveTxtTocIndex(idx) {
            if (!Number.isFinite(idx)) return;
            const i = Math.max(-1, Math.min((currentTxtToc ? currentTxtToc.length : 0) - 1, Math.floor(idx)));
            const tocList = document.getElementById('tocList');
            if (tocList) {
                const prev = tocList.querySelector('.toc-item.active');
                if (prev) {
                    const prevIdx = prev.getAttribute('data-toc-index');
                    if (Number.isFinite(Number(prevIdx)) && Number(prevIdx) === i) {
                        currentTxtTocActiveIndex = i;
                        return;
                    }
                    prev.classList.remove('active');
                }
                const next = tocList.querySelector(`.toc-item[data-toc-index="${i}"]`);
                if (next) next.classList.add('active');
            }
            currentTxtTocActiveIndex = i;
        }

        function normalizeEpubHref(href) {
            const s = String(href || '');
            const noHash = s.split('#')[0];
            return noHash.replace(/^\.\//, '');
        }

        function rebuildEpubTocHrefIndex() {
            epubHrefToTocIndex = new Map();
            if (!currentEpubToc || currentEpubToc.length === 0) return;
            for (let i = 0; i < currentEpubToc.length; i += 1) {
                const href = currentEpubToc[i] ? currentEpubToc[i].href : null;
                const key = normalizeEpubHref(href);
                if (key) epubHrefToTocIndex.set(key, i);
            }
        }

        function setActiveEpubTocIndex(idx) {
            if (!Number.isFinite(idx)) return;
            const i = Math.max(-1, Math.min((currentEpubToc ? currentEpubToc.length : 0) - 1, Math.floor(idx)));
            const tocList = document.getElementById('tocList');
            if (tocList) {
                const prev = tocList.querySelector('.toc-item.active');
                if (prev) {
                    const prevIdx = prev.getAttribute('data-epub-index');
                    if (Number.isFinite(Number(prevIdx)) && Number(prevIdx) === i) {
                        currentEpubTocActiveIndex = i;
                        return;
                    }
                    prev.classList.remove('active');
                }
                const next = tocList.querySelector(`.toc-item[data-epub-index="${i}"]`);
                if (next) next.classList.add('active');
            }
            currentEpubTocActiveIndex = i;
        }

        function updateActiveEpubTocByHref(href) {
            const key = normalizeEpubHref(href);
            if (!key) return;
            const idx = epubHrefToTocIndex && epubHrefToTocIndex.has(key) ? epubHrefToTocIndex.get(key) : null;
            if (!Number.isFinite(idx)) return;
            setActiveEpubTocIndex(idx);
        }

        function updateActiveEpubTocByLocation(location) {
            const href = location && location.start ? (location.start.href || location.start.url || location.start.path) : null;
            if (!href) return;
            lastEpubRelocatedHref = href;
            updateActiveEpubTocByHref(href);
        }

        function scrollTocActiveIntoView() {
            const tocList = document.getElementById('tocList');
            if (!tocList) return;
            const active = tocList.querySelector('.toc-item.active')
                || (currentTxtTocActiveIndex >= 0 ? tocList.querySelector(`.toc-item[data-toc-index="${currentTxtTocActiveIndex}"]`) : null)
                || (currentEpubTocActiveIndex >= 0 ? tocList.querySelector(`.toc-item[data-epub-index="${currentEpubTocActiveIndex}"]`) : null);
            if (!active || !active.scrollIntoView) return;
            active.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }

        function scrollTocToTop() {
            const el = document.getElementById('tocList');
            if (!el || !el.scrollTo) return;
            el.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function scrollTocToBottom() {
            const el = document.getElementById('tocList');
            if (!el || !el.scrollTo) return;
            el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
        }

        function updatePageIndicatorByTxtPos(absolutePos) {
            const el = document.getElementById('readerPageIndicator');
            const chapEl = document.getElementById('readerChapterPageIndicator');
            if (!el && !chapEl) return;
            if (!currentTxtContent || !Number.isFinite(absolutePos)) {
                if (lastEpubProgress && Number.isFinite(lastEpubProgress.percent)) {
                    if (el) el.textContent = `${lastEpubProgress.percent}%`;
                } else {
                    if (el) el.textContent = '';
                }
                if (chapEl) chapEl.textContent = '';
                try { updateReaderBottomStatusPage(); } catch (e) {}
                return;
            }
            const perPage = Math.max(1, getTxtCharsPerPage());
            const totalPages = Math.max(1, Math.ceil(currentTxtContent.length / perPage));
            const currentPage = Math.max(1, Math.min(totalPages, Math.floor(absolutePos / perPage) + 1));
            if (el) el.textContent = `${currentPage}/${totalPages}`;
            if (chapEl && currentTxtToc && currentTxtToc.length > 0) {
                const paging = getTxtChapterPagingByAbsPos(absolutePos);
                if (paging && Array.isArray(paging.starts) && paging.starts.length > 0) {
                    const starts = paging.starts;
                    const totalChapterPages = Math.max(1, starts.length - 1);
                    const abs = Math.max(paging.start, Math.min(paging.end, absolutePos));
                    let lo = 0;
                    let hi = starts.length - 1;
                    let ans = 0;
                    while (lo <= hi) {
                        const mid = (lo + hi) >> 1;
                        if ((starts[mid] || 0) <= abs) { ans = mid; lo = mid + 1; }
                        else hi = mid - 1;
                    }
                    const chapterPage = Math.max(1, Math.min(totalChapterPages, ans + 1));
                    chapEl.textContent = `第${chapterPage}/${totalChapterPages}页`;
                } else {
                    const chapterIndex = computeTxtChapterIndexByAbsPos(absolutePos);
                    const start = currentTxtToc[chapterIndex] && Number.isFinite(currentTxtToc[chapterIndex].position) ? currentTxtToc[chapterIndex].position : 0;
                    const end = (chapterIndex + 1 < currentTxtToc.length) && currentTxtToc[chapterIndex + 1] && Number.isFinite(currentTxtToc[chapterIndex + 1].position)
                        ? currentTxtToc[chapterIndex + 1].position
                        : currentTxtContent.length;
                    const totalChapterPages = Math.max(1, Math.ceil(Math.max(1, end - start) / perPage));
                    const chapterPage = Math.max(1, Math.min(totalChapterPages, Math.floor(Math.max(0, absolutePos - start) / perPage) + 1));
                    chapEl.textContent = `第${chapterPage}/${totalChapterPages}页`;
                }
            } else if (chapEl) {
                chapEl.textContent = `第${currentPage}/${totalPages}页`;
            }
            try { updateReaderBottomStatusPage(); } catch (e) {}
        }

        function updateActiveTxtTocByPos(absolutePos) {
            if (!currentTxtToc || currentTxtToc.length === 0) return;
            if (!Number.isFinite(absolutePos) || absolutePos < 0) return;
            let lo = 0;
            let hi = currentTxtToc.length - 1;
            let ans = 0;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const p = currentTxtToc[mid] && Number.isFinite(currentTxtToc[mid].position) ? currentTxtToc[mid].position : 0;
                if (p <= absolutePos) {
                    ans = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            setActiveTxtTocIndex(ans);
            updatePageIndicatorByTxtPos(absolutePos);
        }

        async function openBookFromId(id) {
            if (closeInFlight) {
                debugLog('openBookFromId wait close', { id });
                await closeInFlight;
            }
            const openSession = ++txtSessionId;
            currentBookId = id; // Set ID
            tocIsReverse = false;
            currentTocKind = null;
            updateTocOrderButtonLabel();
            lastTxtProgress = null;
            lastEpubProgress = null;
            lastEpubRelocatedHref = null;
            epubHrefToTocIndex = null;
            currentTxtToc = [];
            currentEpubToc = [];
            currentTxtTocActiveIndex = -1;
            currentEpubTocActiveIndex = -1;
            isRestoringTxt = true;
            isClosingReader = false;
            teardownTxtObservers();
            const bookData = await storage.getBook(id);
            if (!bookData) return;

            // Prepare Reader View
            document.getElementById('readerTitle').innerText = bookData.title;
            const contentArea = document.getElementById('readerContent');
            const inner = document.getElementById('readerContentInner');
            try { bindReaderInteractionLayer(); } catch (e) {}
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            if (txtScrollHandler && txtScrollHandler.cancel) txtScrollHandler.cancel();
            if (txtTouchHandler && txtTouchHandler.cancel) txtTouchHandler.cancel();
            if (txtPointerHandler && txtPointerHandler.cancel) txtPointerHandler.cancel();
            detachTxtFlipGestureHandlers();
            if (txtScrollHandler) contentArea.removeEventListener('scroll', txtScrollHandler);
            if (txtTouchHandler) contentArea.removeEventListener('touchend', txtTouchHandler);
            if (txtPointerHandler) contentArea.removeEventListener('pointerup', txtPointerHandler);
            if (inner) inner.innerHTML = '<div class="reader-message reader-message--pad-40 reader-message--tertiary">正在加载...</div>';
            document.getElementById('readerView').classList.remove('closing');
            document.getElementById('readerView').classList.remove('menu-visible');
            document.getElementById('settingsPanel').classList.remove('active');
            try { updateReaderBottomSheetOffset(); } catch (e) {}
            document.getElementById('tocPanel').classList.remove('active');
            document.getElementById('tocOverlay').classList.remove('active');
            document.getElementById('moreMenu').classList.remove('active');
            
            // Reset Flip Mode to Scroll for stability on open
            // currentFlipMode = 'scroll';
            // document.getElementById('flipModeText').innerText = '滚动';
            contentArea.classList.remove('mode-slide');
            contentArea.classList.remove('mode-sim');
            document.getElementById('readerView').classList.remove('flip-slide');
            
            lockBodyScroll(true);
            const readerViewEl = document.getElementById('readerView');
            readerViewEl.classList.add('active');
            readerViewEl.classList.add('menu-visible');
            setTimeout(() => {
                if (openSession !== txtSessionId) return;
                const settingsPanel = document.getElementById('settingsPanel');
                const tocPanel = document.getElementById('tocPanel');
                const moreMenu = document.getElementById('moreMenu');
                const hasPanelOpen = (settingsPanel && settingsPanel.classList.contains('active'))
                    || (tocPanel && tocPanel.classList.contains('active'))
                    || (moreMenu && moreMenu.classList.contains('active'));
                if (!hasPanelOpen) readerViewEl.classList.remove('menu-visible');
            }, 1200);

            // Delay processing to allow animation to start smoothly
            setTimeout(async () => {
                if (openSession !== txtSessionId) return;
                if (bookData.format === 'EPUB') {
                    // ... existing EPUB logic ...
                    try {
                        if (inner) inner.innerHTML = '';
                        currentBook = ePub(bookData.fileBlob);
                        rendition = currentBook.renderTo("readerContentInner", {
                            width: "100%",
                            height: "100%",
                            flow: "scrolled", // Always start scrolled for now
                            manager: "default"
                        });
                        
                        const savedProgress = await storage.getProgress(id);
                        if (savedProgress && savedProgress.cfi) {
                            lastEpubProgress = { cfi: savedProgress.cfi, percent: savedProgress.percentage || 0 };
                        }
                        await rendition.display(savedProgress ? savedProgress.cfi : undefined);
                        startProgressAutoSave(openSession);
                        try { attachEpubInteractionHandlers(rendition, openSession); } catch (e) {}
                        
                        rendition.on('relocated', (location) => {
                            const cfi = location && location.start ? location.start.cfi : null;
                            if (!cfi) return;
                            const rawPercent = currentBook.locations && currentBook.locations.length
                                ? currentBook.locations.percentageFromCfi(cfi)
                                : 0;
                            const percent = Number.isFinite(rawPercent) ? Math.floor(rawPercent * 100) : 0;
                            lastEpubProgress = { cfi, percent };
                            storage.saveProgress(id, cfi, percent);
                            try { updateActiveEpubTocByLocation(location); } catch (e) {}
                            updatePageIndicatorByTxtPos(NaN);
                        });

                        // Generate TOC
                        const navigation = await currentBook.loaded.navigation;
                        currentEpubToc = (navigation && navigation.toc ? navigation.toc : []).map((c, i) => ({ ...(c || {}), _index: i }));
                        currentTocKind = 'epub';
                        rebuildEpubTocHrefIndex();
                        renderTocList();
                        if (lastEpubRelocatedHref) updateActiveEpubTocByHref(lastEpubRelocatedHref);
                    } catch (err) {
                        console.error('EPUB render error:', err);
                        if (inner) inner.innerHTML = '<div class="reader-message reader-message--pad-20 reader-message--error">解析失败，请检查文件格式</div>';
                    }
                } else {
                    // Optimized TXT rendering
                    try {
                        const text = await parseTxt(bookData.fileBlob);
                        if (openSession !== txtSessionId) return;
                        currentTxtContent = text;
                        currentTxtToc = parseTxtToc(text).map((it, i) => ({ ...(it || {}), _index: i }));
                        currentTocKind = 'txt';
                        
                        // Render TOC
                        renderTocList();
                        
                        isRestoringTxt = true;
                        const savedProgress = await storage.getProgress(id);
                        debugLog('txt open: savedProgress', { id, savedProgress });
                        const desiredFlipMode = 'scroll';
                        const savedAnchorId = savedProgress && savedProgress.activeElementId ? String(savedProgress.activeElementId) : null;
                        const savedAnchorAbs = absPosFromAnchorId(savedAnchorId);
                        const savedAnchorOffset = savedProgress && savedProgress.anchorOffset !== undefined && savedProgress.anchorOffset !== null
                            ? Number(savedProgress.anchorOffset)
                            : NaN;
                        const savedLineIndex = savedProgress && savedProgress.lineIndex !== undefined && savedProgress.lineIndex !== null
                            ? parseInt(savedProgress.lineIndex)
                            : NaN;
                        const ratio = savedProgress && savedProgress.ratio !== undefined && savedProgress.ratio !== null
                            ? parseFloat(savedProgress.ratio)
                            : NaN;
                        const posFromRatio = Number.isFinite(ratio)
                            ? Math.max(0, Math.min(currentTxtContent.length - 1, Math.floor(ratio * currentTxtContent.length)))
                            : NaN;
                        const cfiPos = savedProgress && savedProgress.cfi !== undefined && savedProgress.cfi !== null
                            ? parseInt(savedProgress.cfi)
                            : NaN;
                        const posFromCfi = Number.isFinite(cfiPos) ? Math.max(0, Math.min(currentTxtContent.length - 1, cfiPos)) : NaN;
                        let absolutePos = Math.max(0, Number.isFinite(posFromCfi) ? posFromCfi : (Number.isFinite(posFromRatio) ? posFromRatio : 0));
                        if (Number.isFinite(savedAnchorAbs)) absolutePos = Math.max(0, Math.min(currentTxtContent.length - 1, savedAnchorAbs));
                        let anchorId = savedAnchorId;
                        if (!anchorId) anchorId = txtAnchorIdForAbsPos(currentBookId, absolutePos);
                        updateActiveTxtTocByPos(absolutePos);
                        const CHUNK_SIZE = 15000;
                        const maxChunkStart = Math.max(0, Math.floor(Math.max(0, currentTxtContent.length - 1) / CHUNK_SIZE) * CHUNK_SIZE);
                        const savedChunkStart = savedProgress && savedProgress.chunkStart !== undefined && savedProgress.chunkStart !== null
                            ? parseInt(savedProgress.chunkStart)
                            : NaN;
                        const derivedChunkStart = Math.max(0, Math.floor(absolutePos / CHUNK_SIZE) * CHUNK_SIZE);
                        const chunkStart = (Number.isFinite(savedLineIndex) && Number.isFinite(savedChunkStart))
                            ? Math.max(0, Math.min(maxChunkStart, savedChunkStart))
                            : Math.max(0, Math.min(maxChunkStart, derivedChunkStart));
                        debugLog('txt open: restore plan', { absolutePos, posFromCfi, posFromRatio, chunkStart, ratio });
                        currentFlipMode = desiredFlipMode;
                        renderTxtChunk(chunkStart);
                        const fontsReadyPromise = waitForFontsReady();
                        let restoreAttempts = 0;
                        let didLineRestore = false;
                        const tryRestore = () => {
                            if (openSession !== txtSessionId) return;
                            if (!contentArea || (contentArea.clientHeight || 0) <= 0) {
                                restoreAttempts += 1;
                                if (restoreAttempts < 12) setTimeout(tryRestore, 60);
                                return;
                            }
                            observeTxtContainer(openSession);
                            if (Number.isFinite(savedLineIndex)) {
                                if (!didLineRestore) {
                                    didLineRestore = true;
                                    setTimeout(() => {
                                        if (openSession !== txtSessionId) return;
                                        const padTop = getContentPaddingTopPx(contentArea);
                                        const targetTop = getScrollTopFromLineIndex(savedLineIndex, padTop, LINE_HEIGHT);
                                        const maxScroll = Math.max(0, (contentArea.scrollHeight || 0) - (contentArea.clientHeight || 0));
                                        contentArea.scrollTop = Math.max(0, Math.min(maxScroll, targetTop));
                                        isRestoringTxt = false;
                                        updateActiveTxtTocByPos(Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : absolutePos);
                                        startProgressAutoSave(openSession);
                                        setTimeout(() => {
                                            if (openSession !== txtSessionId) return;
                                            schedulePersistTxtAnchorProgress('auto');
                                        }, 0);
                                    }, 100);
                                }
                                return;
                            }
                            let target = null;
                            if (anchorId) {
                                const el = document.getElementById(anchorId);
                                if (el && contentArea.contains(el)) target = el;
                            }
                            const ps = Array.from(contentArea.querySelectorAll('p[data-abs]'));
                            if (!target && ps.length > 0) {
                                const want = Number.isFinite(absolutePos) ? absolutePos : 0;
                                for (const p of ps) {
                                    const a = parseInt(p.getAttribute('data-abs') || 'NaN', 10);
                                    if (!Number.isFinite(a)) continue;
                                    if (a <= want) target = p;
                                    else break;
                                }
                                if (!target) target = ps[0];
                            }
                            if (target) {
                                scrollParagraphIntoView(target, { anchorOffset: savedAnchorOffset });
                                const abs = parseInt(target.getAttribute('data-abs') || 'NaN', 10);
                                if (Number.isFinite(abs)) {
                                    txtActiveAbsPos = abs;
                                    txtActiveAnchorId = target.id || null;
                                }
                            }
                            restoreAttempts += 1;
                            if (restoreAttempts < 10 && !target) {
                                setTimeout(tryRestore, 80);
                            } else {
                                isRestoringTxt = false;
                                updateActiveTxtTocByPos(Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : absolutePos);
                                startProgressAutoSave(openSession);
                                setTimeout(() => {
                                    if (openSession !== txtSessionId) return;
                                    schedulePersistTxtAnchorProgress('auto');
                                }, 0);
                            }
                        };
                        setTimeout(async () => {
                            await fontsReadyPromise;
                            await nextFrame();
                            await nextFrame();
                            tryRestore();
                        }, 0);
                        
                        if (txtTouchHandler) contentArea.removeEventListener('touchend', txtTouchHandler);
                        if (txtPointerHandler) contentArea.removeEventListener('pointerup', txtPointerHandler);
                        txtTouchHandler = debounce(() => {
                            if (openSession !== txtSessionId) return;
                            if (currentFlipMode === 'slide') snapSlideToPage();
                            schedulePersistTxtAnchorProgress('auto');
                        }, 200);
                        txtPointerHandler = debounce(() => {
                            if (openSession !== txtSessionId) return;
                            if (currentFlipMode === 'slide') snapSlideToPage();
                            schedulePersistTxtAnchorProgress('auto');
                        }, 200);
                        contentArea.addEventListener('touchend', txtTouchHandler, { passive: true });
                        contentArea.addEventListener('pointerup', txtPointerHandler, { passive: true });
                        attachTxtFlipGestureHandlers(openSession);

                    } catch(e) {
                         console.error(e);
                         if (inner) inner.innerHTML = '<div class="reader-message reader-message--pad-20 reader-message--error">文件读取失败</div>';
                    }
                }
            }, 600);
        }
        
        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            function wrapped(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            }
            wrapped.cancel = () => {
                clearTimeout(timeout);
                timeout = null;
            };
            return wrapped;
        }

        function snapSlideToPage() {
            const content = document.getElementById('readerContent');
            if (!content) return;
            if (currentFlipMode !== 'slide') return;
            const pageWidth = content.clientWidth || 1;
            const nextLeft = Math.round(content.scrollLeft / pageWidth) * pageWidth;
            if (Math.abs(nextLeft - content.scrollLeft) < 2) return;
            content.scrollTo({ left: nextLeft, behavior: 'smooth' });
        }

        let txtScrollRaf = null;
        function attachTxtScrollHandler(session = txtSessionId) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            if (txtScrollHandler) contentArea.removeEventListener('scroll', txtScrollHandler);
            if (txtScrollRaf) {
                try { cancelAnimationFrame(txtScrollRaf); } catch (e) {}
                txtScrollRaf = null;
            }
            txtScrollHandler = () => {
                if (session !== txtSessionId) return;
                if (currentFlipMode !== 'scroll') return;
                if (isRestoringTxt) return;
                if (isClosingReader) return;
                if (hasAnyReaderPanelOpen()) return;
                if (txtScrollRaf) return;
                txtScrollRaf = requestAnimationFrame(() => {
                    txtScrollRaf = null;
                    try {
                        const snap = getTxtProgressData();
                        if (!snap || !Number.isFinite(snap.absolutePos)) return;
                        const abs = Math.max(0, Math.min(currentTxtContent.length - 1, snap.absolutePos));
                        if (!Number.isFinite(abs)) return;
                        if (abs === txtActiveAbsPos) return;
                        txtActiveAbsPos = abs;
                        txtActiveAnchorId = txtAnchorIdForAbsPos(currentBookId, abs);
                        updateActiveTxtTocByPos(abs);
                        schedulePersistTxtAnchorProgress('auto');
                    } catch (e) {}
                });
            };
            contentArea.addEventListener('scroll', txtScrollHandler, { passive: true });
        }

        let txtPagedResizeTimer = null;
        window.addEventListener('resize', () => {
            if (!currentTxtContent) return;
            if (currentFlipMode !== 'slide' && currentFlipMode !== 'simulation') return;
            if (isRestoringTxt) return;
            if (isClosingReader) return;
            if (txtPagedResizeTimer) clearTimeout(txtPagedResizeTimer);
            txtPagedResizeTimer = setTimeout(() => {
                if (!currentTxtContent) return;
                if (currentFlipMode !== 'slide' && currentFlipMode !== 'simulation') return;
                buildTxtPagedView(currentFlipMode, Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : null);
            }, 140);
        }, { passive: true });

        function startProgressAutoSave(session = txtSessionId) {
            stopProgressAutoSave();
            progressAutoSaveTimer = setInterval(() => {
                if (session !== txtSessionId) return;
                saveTxtProgressFromView('auto');
                saveEpubProgressFromView('auto');
            }, 1200);
        }

        function stopProgressAutoSave() {
            if (progressAutoSaveTimer) {
                clearInterval(progressAutoSaveTimer);
                progressAutoSaveTimer = null;
            }
        }

        function getTxtProgressData() {
            const contentArea = document.getElementById('readerContent');
            if (!currentTxtContent || !contentArea) return null;
            const CHUNK_SIZE = 15000;
            const currentStart = parseInt(contentArea.getAttribute('data-chunk-start') || '0');
            const renderLength = parseInt(contentArea.getAttribute('data-render-length') || '0');
            const isSlide = currentFlipMode === 'slide';
            const maxScroll = isSlide
                ? (contentArea.scrollWidth - contentArea.clientWidth)
                : (contentArea.scrollHeight - contentArea.clientHeight);
            const scrollPos = isSlide ? contentArea.scrollLeft : contentArea.scrollTop;
            const scrollRatio = maxScroll > 0 ? Math.min(1, Math.max(0, scrollPos / maxScroll)) : 0;
            const paragraphs = Array.from(contentArea.querySelectorAll('p[data-pos]'));
            let target = null;
            if (isSlide) {
                const rect = contentArea.getBoundingClientRect();
                const x = rect.left + rect.width * 0.2;
                const y = rect.top + rect.height * 0.3;
                const stack = document.elementsFromPoint ? document.elementsFromPoint(x, y) : [document.elementFromPoint(x, y)];
                for (const node of stack) {
                    const p = node && node.closest ? node.closest('p[data-pos]') : null;
                    if (p && p.getAttribute('data-anchor') !== '1') {
                        target = p;
                        break;
                    }
                }
            } else {
                const anchorTop = contentArea.scrollTop + (maxScroll > 0 ? Math.floor(contentArea.clientHeight * 0.25) : 1);
                for (const p of paragraphs) {
                    if (p.getAttribute('data-anchor') === '1') continue;
                    if (p.offsetTop <= anchorTop) target = p;
                    else break;
                }
            }
            if (!target && paragraphs.length > 0) target = paragraphs.find(p => p.getAttribute('data-anchor') !== '1') || paragraphs[0];
            const relativePos = target ? parseInt(target.getAttribute('data-pos') || '0') : 0;
            const absolutePosByParagraph = Math.min(currentTxtContent.length - 1, currentStart + relativePos);
            const absolutePos = absolutePosByParagraph;
            const ratio = currentTxtContent.length > 0 ? (absolutePos / currentTxtContent.length) : 0;
            const percent = absolutePos > 0
                ? Math.min(100, Math.max(1, Math.round(ratio * 100)))
                : 0;
            const loadedLength = parseInt(contentArea.getAttribute('data-render-length') || '0');
            const resumeStart = Math.max(0, Math.floor(absolutePos / CHUNK_SIZE) * CHUNK_SIZE);
            return { absolutePos, percent, scrollTop: scrollPos, chunkStart: currentStart, scrollRatio, ratio, loadedLength, resumeStart };
        }

        async function saveTxtProgressFromView(reason = 'auto') {
            if (!currentBookId || !currentTxtContent) return;
            if (isRestoringTxt) return;
            if (isClosingReader && reason === 'auto') return;
            if (reason === 'auto' && hasAnyReaderPanelOpen()) return;
            const readerActive = document.getElementById('readerView').classList.contains('active');
            if (!readerActive && reason === 'auto') return;
            const contentArea = document.getElementById('readerContent');
            try {
                const snap = getTxtProgressData();
                if (snap && Number.isFinite(snap.absolutePos)) {
                    const abs = Math.max(0, Math.min(currentTxtContent.length - 1, snap.absolutePos));
                    txtActiveAbsPos = abs;
                    const id = txtAnchorIdForAbsPos(currentBookId, abs);
                    txtActiveAnchorId = id || txtActiveAnchorId;
                } else if ((!txtActiveAnchorId || !Number.isFinite(txtActiveAbsPos)) && contentArea) {
                    const first = contentArea.querySelector('p[data-abs]');
                    if (first) {
                        const abs = parseInt(first.getAttribute('data-abs') || 'NaN', 10);
                        if (Number.isFinite(abs)) {
                            txtActiveAbsPos = abs;
                            txtActiveAnchorId = first.id || null;
                        }
                    }
                }
            } catch (e) {}
            await persistTxtAnchorProgress(reason);
        }

        async function saveEpubProgressFromView(reason = 'auto') {
            if (!currentBookId || !rendition || !currentBook || !currentBook.locations) return;
            if (isClosingReader && reason === 'auto') return;
            const location = rendition.currentLocation();
            if (!location || !location.start || !location.start.cfi) return;
            const percent = currentBook.locations.percentageFromCfi(location.start.cfi);
            lastEpubProgress = { cfi: location.start.cfi, percent: Math.floor(percent * 100) };
            await storage.saveProgress(currentBookId, location.start.cfi, Math.floor(percent * 100), 0);
        }
        
        function renderTxtChunk(startPos) {
            const CHUNK_SIZE = 15000;
            const contentArea = document.getElementById('readerContent');
            const inner = document.getElementById('readerContentInner');
            if (!contentArea || !inner) return;
            const chunk = currentTxtContent.slice(startPos, startPos + CHUNK_SIZE);
            
            contentArea.setAttribute('data-chunk-start', startPos);
            contentArea.setAttribute('data-render-length', chunk.length);
            if (startPos + CHUNK_SIZE < currentTxtContent.length) {
                contentArea.setAttribute('data-next-start', startPos + CHUNK_SIZE);
            } else {
                contentArea.removeAttribute('data-next-start');
            }
            
            let pos = 0;
            const html = chunk.split('\n').map(line => {
                const currentPos = pos;
                pos += line.length + 1;
                const abs = startPos + currentPos;
                const display = String(line || '').replace(/\r$/, '');
                const id = txtAnchorIdForAbsPos(currentBookId, abs);
                return display.trim() ? `<p id="${id}" data-abs="${abs}" data-pos="${currentPos}" class="reader-txt-paragraph">${escapeHtml(display)}</p>` : '';
            }).join('');
            
            inner.innerHTML = html;
            contentArea.scrollTop = 0;
            contentArea.scrollLeft = 0;
            let anchorRef = null;
            const topSentinel = document.createElement('div');
            topSentinel.setAttribute('data-txt-top-sentinel', '1');
            topSentinel.style.height = '1px';
            inner.insertAdjacentElement('afterbegin', topSentinel);
            const sentinel = document.createElement('div');
            sentinel.setAttribute('data-txt-sentinel', '1');
            sentinel.style.height = '1px';
            inner.appendChild(sentinel);
        
            const anchor = document.createElement('p');
            anchor.setAttribute('data-pos', '0');
            anchor.setAttribute('data-anchor', '1');
            anchor.style.cssText = 'margin:0;height:0;';
            if (anchorRef) anchorRef.insertAdjacentElement('afterend', anchor);
            else topSentinel.insertAdjacentElement('afterend', anchor);
            observeTxtContainer();
            attachTxtScrollHandler();
            try { syncReaderInteractionLayerPosition(); } catch (e) {}
        }
        
        
        function renderTxtChunkAppend(startPos) {
             const CHUNK_SIZE = 15000;
             if (startPos >= currentTxtContent.length) return;
             const container = document.getElementById('readerContent');
             const inner = document.getElementById('readerContentInner');
             if (!container || !inner) return;
             
             const chunk = currentTxtContent.slice(startPos, startPos + CHUNK_SIZE);
             let pos = 0;
             const html = chunk.split('\n').map(line => {
                 const currentPos = pos;
                 pos += line.length + 1;
                 const abs = startPos + currentPos;
                 const display = String(line || '').replace(/\r$/, '');
                 const id = txtAnchorIdForAbsPos(currentBookId, abs);
                 return display.trim() ? `<p id="${id}" data-abs="${abs}" data-pos="${currentPos}" class="reader-txt-paragraph">${escapeHtml(display)}</p>` : '';
             }).join('');
             
             const range = document.createRange();
             range.selectNodeContents(inner);
             const fragment = range.createContextualFragment(html);
             const combined = document.createDocumentFragment();
             const anchor = document.createElement('p');
             anchor.setAttribute('data-pos', '0');
             anchor.setAttribute('data-anchor', '1');
             anchor.style.cssText = 'margin:0;height:0;';
             combined.appendChild(anchor);
             combined.appendChild(fragment);
             const sentinel = inner.querySelector('[data-txt-sentinel="1"]');
             if (sentinel) {
                 inner.insertBefore(combined, sentinel);
             } else {
                 inner.appendChild(combined);
             }
             
             const currentLength = parseInt(container.getAttribute('data-render-length') || '0');
             container.setAttribute('data-render-length', currentLength + chunk.length);
             if (startPos + CHUNK_SIZE < currentTxtContent.length) {
                 container.setAttribute('data-next-start', startPos + CHUNK_SIZE);
             } else {
                 container.removeAttribute('data-next-start');
             }
             observeTxtContainer();
        }

        function renderTxtChunkPrepend(startPos) {
            const CHUNK_SIZE = 15000;
            if (!currentTxtContent) return;
            if (startPos < 0) return;
            const container = document.getElementById('readerContent');
            if (!container) return;
            const chunk = currentTxtContent.slice(startPos, startPos + CHUNK_SIZE);
            let pos = 0;
            const html = chunk.split('\n').map(line => {
                const currentPos = pos;
                pos += line.length + 1;
                const abs = startPos + currentPos;
                const display = String(line || '').replace(/\r$/, '');
                const id = txtAnchorIdForAbsPos(currentBookId, abs);
                return display.trim() ? `<p id="${id}" data-abs="${abs}" data-pos="${currentPos}" class="reader-txt-paragraph">${escapeHtml(display)}</p>` : '';
            }).join('');
            const range = document.createRange();
            range.selectNodeContents(container);
            const fragment = range.createContextualFragment(html);
            const combined = document.createDocumentFragment();
            const anchor = document.createElement('p');
            anchor.setAttribute('data-pos', '0');
            anchor.setAttribute('data-anchor', '1');
            anchor.style.cssText = 'margin:0;height:0;';
            combined.appendChild(anchor);
            combined.appendChild(fragment);
            let topSentinel = container.querySelector('[data-txt-top-sentinel="1"]');
            if (!topSentinel) {
                topSentinel = document.createElement('div');
                topSentinel.setAttribute('data-txt-top-sentinel', '1');
                topSentinel.style.height = '1px';
                container.insertAdjacentElement('afterbegin', topSentinel);
            }
            const insertBeforeNode = topSentinel.nextSibling;
            if (insertBeforeNode) container.insertBefore(combined, insertBeforeNode);
            else container.appendChild(combined);
            const currentLength = parseInt(container.getAttribute('data-render-length') || '0');
            container.setAttribute('data-render-length', currentLength + chunk.length);
            container.setAttribute('data-chunk-start', startPos);
            observeTxtContainer();
        }

        function maybeAutoAppendTxt(force = false) {
            if (!currentTxtContent) return;
            if (isRestoringTxt) return;
            if (isClosingReader) return;
            if (hasAnyReaderPanelOpen()) return;
            const readerActive = document.getElementById('readerView').classList.contains('active');
            if (!readerActive) return;
            const container = document.getElementById('readerContent');
            if (!container) return;
            if (isAppendingTxt) return;
            const nextStart = parseInt(container.getAttribute('data-next-start') || 'NaN');
            if (!Number.isFinite(nextStart) || nextStart >= currentTxtContent.length) return;
            if (!force) {
                const distanceToBottom = container.scrollHeight - (container.scrollTop + container.clientHeight);
                if (distanceToBottom > 1000) return;
            }
            const now = Date.now();
            if (txtLastAppendStart === nextStart && (now - txtLastAppendAt) < 800) return;
            isAppendingTxt = true;
            try {
                renderTxtChunkAppend(nextStart);
                txtLastAppendStart = nextStart;
                txtLastAppendAt = now;
            } finally {
                isAppendingTxt = false;
            }
        }

        function maybeAutoPrependTxt(force = false) {
            if (!currentTxtContent) return;
            if (isRestoringTxt) return;
            if (isClosingReader) return;
            if (hasAnyReaderPanelOpen()) return;
            const readerActive = document.getElementById('readerView').classList.contains('active');
            if (!readerActive) return;
            const container = document.getElementById('readerContent');
            if (!container) return;
            if (isPrependingTxt) return;
            const CHUNK_SIZE = 15000;
            const currentStart = parseInt(container.getAttribute('data-chunk-start') || '0');
            if (!Number.isFinite(currentStart) || currentStart <= 0) return;
            const prevStart = Math.max(0, currentStart - CHUNK_SIZE);
            if (prevStart === currentStart) return;
            if (!force) {
                if (container.scrollTop > 1000) return;
            }
            const now = Date.now();
            if (txtLastPrependStart === prevStart && (now - txtLastPrependAt) < 800) return;
            const oldScrollHeight = container.scrollHeight;
            const oldScrollTop = container.scrollTop;
            isPrependingTxt = true;
            try {
                renderTxtChunkPrepend(prevStart);
                const newScrollHeight = container.scrollHeight;
                const offset = newScrollHeight - oldScrollHeight;
                container.scrollTop = oldScrollTop + offset;
                txtLastPrependStart = prevStart;
                txtLastPrependAt = now;
            } finally {
                isPrependingTxt = false;
            }
        }

        function clearAllSelections() {
            try {
                const sel = window.getSelection ? window.getSelection() : null;
                if (sel && sel.removeAllRanges) sel.removeAllRanges();
            } catch (e) {}
            try {
                const iframes = Array.from(document.querySelectorAll('#readerContent iframe'));
                for (const iframe of iframes) {
                    try {
                        const w = iframe && iframe.contentWindow ? iframe.contentWindow : null;
                        const sel = w && w.getSelection ? w.getSelection() : null;
                        if (sel && sel.removeAllRanges) sel.removeAllRanges();
                    } catch (e) {}
                }
            } catch (e) {}
        }

        function forceCloseSettingsPanel() {
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel) settingsPanel.classList.remove('active');
            try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
        }

        function forceCloseSelectionQueryPanel() {
            try { hideSelectionQueryPanel(); } catch (e) {}
            try { hideSelectionQueryBtn(); } catch (e) {}
            try { selectionQueryText = ''; } catch (e) {}
            try { epubSelectionInfo = null; } catch (e) {}
        }

        function handleTxtTocClick(pos, tocIdx) {
            clearAllSelections();
            forceCloseSelectionQueryPanel();
            forceCloseSettingsPanel();
            jumpToTxtPosition(pos, tocIdx);
        }

        function handleEpubTocClick(idx, href) {
            clearAllSelections();
            forceCloseSelectionQueryPanel();
            forceCloseSettingsPanel();
            try { setActiveEpubTocIndex(idx); } catch (e) {}
            try { if (rendition && rendition.display) rendition.display(href); } catch (e) {}
            try { closeTOC(); } catch (e) {}
        }

        function jumpToTxtPosition(pos, tocIdx = null) {
            const session = txtSessionId;
            const readerView = document.getElementById('readerView');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            clearAllSelections();
            forceCloseSelectionQueryPanel();
            if (settingsPanel) settingsPanel.classList.remove('active');
            if (moreMenu) moreMenu.classList.remove('active');
            if (readerView) readerView.classList.add('menu-visible');
            const CHUNK_SIZE = 15000;
            const startPos = Math.max(0, Math.floor(pos / CHUNK_SIZE) * CHUNK_SIZE);
            const contentArea = document.getElementById('readerContent');
            if (contentArea && (currentFlipMode === 'slide' || currentFlipMode === 'simulation')) {
                contentArea.setAttribute('data-chunk-start', String(startPos));
                contentArea.setAttribute('data-render-length', String(Math.min(CHUNK_SIZE, currentTxtContent.length - startPos)));
                if (startPos + CHUNK_SIZE < currentTxtContent.length) contentArea.setAttribute('data-next-start', String(startPos + CHUNK_SIZE));
                else contentArea.removeAttribute('data-next-start');
                buildTxtPagedView(currentFlipMode, pos);
                closeTOC();
                if (Number.isFinite(tocIdx)) setActiveTxtTocIndex(tocIdx);
                else updateActiveTxtTocByPos(pos);
                schedulePersistTxtAnchorProgress('auto');
                return;
            }
            renderTxtChunk(startPos);
            closeTOC();
            const anchorId = txtAnchorIdForAbsPos(currentBookId, pos);
            setTimeout(() => {
                if (session !== txtSessionId) return;
                observeTxtContainer(session);
                let target = null;
                const el = document.getElementById(anchorId);
                if (el && contentArea.contains(el)) target = el;
                if (!target) {
                    const ps = Array.from(contentArea.querySelectorAll('p[data-abs]'));
                    for (const p of ps) {
                        const a = parseInt(p.getAttribute('data-abs') || 'NaN', 10);
                        if (!Number.isFinite(a)) continue;
                        if (a <= pos) target = p;
                        else break;
                    }
                    if (!target && ps.length > 0) target = ps[0];
                }
                if (target) {
                    scrollParagraphIntoView(target);
                    const abs = parseInt(target.getAttribute('data-abs') || 'NaN', 10);
                    if (Number.isFinite(abs)) {
                        txtActiveAbsPos = abs;
                        txtActiveAnchorId = target.id || null;
                    }
                }
                schedulePersistTxtAnchorProgress('auto');
            }, 0);
            if (Number.isFinite(tocIdx)) setActiveTxtTocIndex(tocIdx);
            else updateActiveTxtTocByPos(pos);
            setTimeout(() => {
                if (session !== txtSessionId) return;
                saveTxtProgressFromView('auto');
            }, 0);
        }

        function playOpenAnimation(coverEl, title) {

            const rect = coverEl.getBoundingClientRect();
            const animLayer = document.getElementById('animLayer');
            animLayer.classList.add('active');
            animLayer.innerHTML = ''; 

            const flyer = document.createElement('div');
            flyer.classList.add('flying-book');
            flyer.style.left = rect.left + 'px';
            flyer.style.top = rect.top + 'px';
            flyer.style.width = rect.width + 'px';
            flyer.style.height = rect.height + 'px';
            flyer.style.transform = 'translateZ(0) scale(0.75) rotateX(10deg)';
            
            const cover = document.createElement('div');
            cover.classList.add('flying-cover');
            cover.style.backgroundImage = coverEl.style.backgroundImage;
            cover.style.backgroundSize = coverEl.style.backgroundSize;
            cover.style.backgroundPosition = coverEl.style.backgroundPosition;
            cover.style.backgroundColor = coverEl.style.backgroundColor;
            cover.innerHTML = coverEl.innerHTML;
            
            const bgClass = Array.from(coverEl.classList).find(c => c.startsWith('cover-'));
            if (bgClass) cover.classList.add(bgClass);

            const page = document.createElement('div');
            page.classList.add('flying-page');
            page.innerHTML = `<div class="reader-flying-page-content reader-flying-page-content--open"><h2>${title}</h2><p>...</p></div>`;
            
            flyer.appendChild(page);
            flyer.appendChild(cover);
            animLayer.appendChild(flyer);

            requestAnimationFrame(() => {
                flyer.style.left = '0px';
                flyer.style.top = '0px';
                flyer.style.width = window.innerWidth + 'px';
                flyer.style.height = window.innerHeight + 'px';
                flyer.style.transform = 'translateZ(0) scale(1) rotateX(0deg)';
                flyer.classList.add('open');
            });

            setTimeout(() => {
                lockBodyScroll(true);
                document.getElementById('readerView').classList.add('active');
                setTimeout(() => {
                    animLayer.classList.remove('active');
                    animLayer.innerHTML = ''; 
                }, 950);
            }, 700); 
        }

        function playCloseAnimation(coverEl, title) {
            const rect = coverEl.getBoundingClientRect();
            const animLayer = document.getElementById('animLayer');
            animLayer.classList.add('active');
            animLayer.innerHTML = '';

            const flyer = document.createElement('div');
            flyer.classList.add('flying-book', 'open');
            flyer.style.left = '0px';
            flyer.style.top = '0px';
            flyer.style.width = window.innerWidth + 'px';
            flyer.style.height = window.innerHeight + 'px';
            flyer.style.transform = 'translateZ(0) scale(1) rotateX(0deg)';

            const cover = document.createElement('div');
            cover.classList.add('flying-cover');
            cover.style.backgroundImage = coverEl.style.backgroundImage;
            cover.style.backgroundSize = coverEl.style.backgroundSize;
            cover.style.backgroundPosition = coverEl.style.backgroundPosition;
            cover.style.backgroundColor = coverEl.style.backgroundColor;
            cover.innerHTML = coverEl.innerHTML;

            const bgClass = Array.from(coverEl.classList).find(c => c.startsWith('cover-'));
            if (bgClass) cover.classList.add(bgClass);

            const page = document.createElement('div');
            page.classList.add('flying-page');
            page.innerHTML = `<div class="reader-flying-page-content reader-flying-page-content--close"><h2>${title}</h2><p>...</p></div>`;

            flyer.appendChild(page);
            flyer.appendChild(cover);
            animLayer.appendChild(flyer);

            requestAnimationFrame(() => {
                flyer.classList.remove('open');
                flyer.style.left = rect.left + 'px';
                flyer.style.top = rect.top + 'px';
                flyer.style.width = rect.width + 'px';
                flyer.style.height = rect.height + 'px';
                flyer.style.transform = 'translateZ(0) scale(0.75) rotateX(10deg)';
            });

            return new Promise(resolve => {
                setTimeout(() => {
                    animLayer.classList.remove('active');
                    animLayer.innerHTML = '';
                    resolve();
                }, 980);
            });
        }

        function closeTOC() {
            document.getElementById('tocPanel').classList.remove('active');
            document.getElementById('tocOverlay').classList.remove('active');
        }

        function openBook(card) {
            // Replaced by openBookFromId
        }

        async function closeBook() {
            if (closeInFlight) return closeInFlight;
            isClosingReader = true;
            txtSessionId += 1;
            debugLog('closeBook start', { bookId: currentBookId });
            closeInFlight = (async () => {
                try {
                    stopProgressAutoSave();
                    try { ensureSettingsPanelMountPoint(); } catch (e) {}
                    const contentArea = document.getElementById('readerContent');
                    await waitForScrollSettle(contentArea, 360);
                    if (txtScrollHandler && txtScrollHandler.cancel) txtScrollHandler.cancel();
                    if (txtTouchHandler && txtTouchHandler.cancel) txtTouchHandler.cancel();
                    if (txtPointerHandler && txtPointerHandler.cancel) txtPointerHandler.cancel();
                    if (contentArea) {
                        if (txtTouchHandler) contentArea.removeEventListener('touchend', txtTouchHandler);
                        if (txtPointerHandler) contentArea.removeEventListener('pointerup', txtPointerHandler);
                    }
                    detachTxtFlipGestureHandlers();
                    const settingsPanel = document.getElementById('settingsPanel');
                    const tocPanel = document.getElementById('tocPanel');
                    const tocOverlay = document.getElementById('tocOverlay');
                    const moreMenu = document.getElementById('moreMenu');
                    const queryOverlay = document.getElementById('queryOverlay');
                    const queryPanel = document.getElementById('queryPanel');
                    const queryBtn = document.getElementById('selectionQueryBtn');
                    if (settingsPanel) settingsPanel.classList.remove('active');
                    if (tocPanel) tocPanel.classList.remove('active');
                    if (tocOverlay) tocOverlay.classList.remove('active');
                    if (moreMenu) moreMenu.classList.remove('active');
                    if (queryOverlay) queryOverlay.classList.remove('active');
                    if (queryPanel) queryPanel.classList.remove('active');
                    if (queryBtn) queryBtn.classList.remove('active');
                    try { unmountSelectionQueryDom(); } catch (e) {}
                    try { selectionQueryText = ''; } catch (e) {}
                    try { epubSelectionInfo = null; } catch (e) {}
                    await saveTxtProgressFromView('close');
                    await saveEpubProgressFromView('close');
                    teardownTxtObservers();
                    isRestoringTxt = false;
                    const readerViewEl = document.getElementById('readerView');
                    readerViewEl.classList.remove('menu-visible');
                    readerViewEl.classList.add('closing');
                    await new Promise(r => setTimeout(r, 280));
                    readerViewEl.classList.remove('active');
                    readerViewEl.classList.remove('closing');
                    lockBodyScroll(false);
                    try {
                        const shelfView = document.getElementById('view-bookshelf');
                        if (!shelfView || shelfView.classList.contains('active')) await renderBookshelf();
                    } catch (e) {}
                    
                    if (rendition) {
                        rendition.destroy();
                        rendition = null;
                    }
                    if (currentBook) {
                        currentBook.destroy();
                        currentBook = null;
                    }
                    debugLog('closeBook end', { bookId: currentBookId });
                } finally {
                    isClosingReader = false;
                    closeInFlight = null;
                }
            })();
            return closeInFlight;
        }

        
        // --- Reader Features ---
        let selectionQueryText = '';
        let selectionQueryFetchSeq = 0;
        const selectionQueryCache = new Map();
        let epubSelectionInfo = null;
        let selectionQueryOverlayNode = null;
        let selectionQueryPanelNode = null;
        let selectionQueryDomParent = null;

        function stashSelectionQueryDomIfNeeded() {
            if (selectionQueryOverlayNode && selectionQueryPanelNode) return;
            const overlay = document.getElementById('queryOverlay');
            const panel = document.getElementById('queryPanel');
            if (!overlay || !panel) return;
            selectionQueryDomParent = overlay.parentNode || panel.parentNode || null;
            selectionQueryOverlayNode = overlay;
            selectionQueryPanelNode = panel;
            try { overlay.remove(); } catch (e) { try { overlay.parentNode && overlay.parentNode.removeChild(overlay); } catch (e2) {} }
            try { panel.remove(); } catch (e) { try { panel.parentNode && panel.parentNode.removeChild(panel); } catch (e2) {} }
        }

        function ensureSelectionQueryDomMounted() {
            if (!selectionQueryDomParent) {
                const readerView = document.getElementById('readerView');
                selectionQueryDomParent = readerView ? readerView : document.body;
            }
            if (selectionQueryOverlayNode && !selectionQueryOverlayNode.isConnected) selectionQueryDomParent.appendChild(selectionQueryOverlayNode);
            if (selectionQueryPanelNode && !selectionQueryPanelNode.isConnected) selectionQueryDomParent.appendChild(selectionQueryPanelNode);
        }

        function unmountSelectionQueryDom() {
            if (selectionQueryOverlayNode && selectionQueryOverlayNode.isConnected) selectionQueryOverlayNode.remove();
            if (selectionQueryPanelNode && selectionQueryPanelNode.isConnected) selectionQueryPanelNode.remove();
        }

        stashSelectionQueryDomIfNeeded();

        function hideSelectionQueryBtn() {
            const btn = document.getElementById('selectionQueryBtn');
            if (!btn) return;
            btn.classList.remove('active');
        }

        function clearQueryResult() {
            const el = document.getElementById('queryResult');
            if (!el) return;
            el.innerHTML = '';
        }

        function setQueryResultHtml(html) {
            const el = document.getElementById('queryResult');
            if (!el) return;
            el.innerHTML = html || '';
        }

        function showSelectionQueryBtnAtRect(text, rect) {
            const btn = document.getElementById('selectionQueryBtn');
            const panel = document.getElementById('queryPanel');
            const readerView = document.getElementById('readerView');
            if (!btn || !readerView) return;
            if (panel && panel.classList.contains('active')) {
                hideSelectionQueryBtn();
                return;
            }
            if (!text || !rect || hasAnyReaderPanelOpen()) {
                selectionQueryText = '';
                hideSelectionQueryBtn();
                return;
            }
            selectionQueryText = String(text || '').trim();
            if (!selectionQueryText) {
                hideSelectionQueryBtn();
                return;
            }
            const rvRect = readerView.getBoundingClientRect();
            const x = (rect.left - rvRect.left) + (rect.width || 0) / 2;
            const y = (rect.top - rvRect.top);
            const btnW = btn.offsetWidth || 56;
            const left = Math.max(8, Math.min((rvRect.width || 0) - btnW - 8, x - btnW / 2));
            const top = Math.max(8, Math.min((rvRect.height || 0) - 48, y - 42));
            btn.style.left = `${Math.round(left)}px`;
            btn.style.top = `${Math.round(top)}px`;
            btn.classList.add('active');
        }

        function getReaderSelectionInfo() {
            const readerView = document.getElementById('readerView');
            const contentArea = document.getElementById('readerContent');
            if (!readerView || !readerView.classList.contains('active')) return null;
            if (!contentArea) return null;
            const sel = window.getSelection ? window.getSelection() : null;
            if (!sel || sel.rangeCount <= 0 || sel.isCollapsed) return null;
            const text = String(sel.toString() || '').trim();
            if (!text) return null;
            const a = sel.anchorNode;
            const f = sel.focusNode;
            const aEl = a && a.nodeType === 1 ? a : (a && a.parentElement ? a.parentElement : null);
            const fEl = f && f.nodeType === 1 ? f : (f && f.parentElement ? f.parentElement : null);
            if (!aEl || !fEl) return null;
            if (!contentArea.contains(aEl) || !contentArea.contains(fEl)) return null;
            let rect = null;
            try { rect = sel.getRangeAt(0).getBoundingClientRect(); } catch (e) {}
            if (!rect || (!rect.width && !rect.height)) {
                try { rect = aEl.getBoundingClientRect(); } catch (e) {}
            }
            if (!rect) return null;
            return { text, rect };
        }

        function updateSelectionQueryBtnFromSelection() {
            const panel = document.getElementById('queryPanel');
            const readerView = document.getElementById('readerView');
            if (!readerView) return;
            if (panel && panel.classList.contains('active')) {
                hideSelectionQueryBtn();
                return;
            }
            const info = getReaderSelectionInfo() || epubSelectionInfo;
            if (!info || hasAnyReaderPanelOpen()) {
                selectionQueryText = '';
                hideSelectionQueryBtn();
                return;
            }
            showSelectionQueryBtnAtRect(info.text, info.rect);
        }

        document.addEventListener('selectionchange', () => {
            try { updateSelectionQueryBtnFromSelection(); } catch (e) {}
        }, { passive: true });

        function normalizeQueryText(text) {
            const t = String(text || '').trim().replace(/\s+/g, ' ');
            if (!t) return '';
            if (t.length > 32) return t.slice(0, 32);
            return t;
        }

        function buildQueryResultHtml(queryText, data) {
            const q = escapeHtml(queryText);
            const pinyin = data && data.pinyin ? escapeHtml(data.pinyin) : '';
            const defs = Array.isArray(data && data.definitions) ? data.definitions : [];
            const origin = data && data.origin ? escapeHtml(data.origin) : '';
            const sourceUrl = data && data.sourceUrl ? String(data.sourceUrl) : '';
            const safeUrl = sourceUrl ? escapeHtml(sourceUrl) : '';

            const defItems = defs.slice(0, 10).map((d, i) => `<div class="query-result-item">${escapeHtml(`${i + 1}. ${d}`)}</div>`).join('');
            const metaBits = [];
            if (pinyin) metaBits.push(`拼音：${pinyin}`);
            if (safeUrl) metaBits.push(`数据：<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">百度</a>`);
            const meta = metaBits.length ? metaBits.join('　') : '';

            let html = `<div class="query-result-title">${q}</div>`;
            if (meta) html += `<div class="query-result-meta">${meta}</div>`;
            if (defItems) {
                html += `<div class="query-result-section"><div class="query-result-section-title">释义</div><div class="query-result-list">${defItems}</div></div>`;
            } else {
                html += `<div class="query-result-hint">未识别到释义内容，可尝试下方链接继续查询。</div>`;
            }
            if (origin) {
                html += `<div class="query-result-section"><div class="query-result-section-title">来源</div><div class="query-result-item">${origin}</div></div>`;
            }
            return html;
        }

        function parseBaiduMobileMarkdown(markdown) {
            const contentIdx = markdown.indexOf('Markdown Content:');
            const body = contentIdx >= 0 ? markdown.slice(contentIdx + 'Markdown Content:'.length) : markdown;
            const lines = body.split(/\r?\n/).map(l => String(l || '').trim()).filter(Boolean);

            const toneLineRe = /^[a-zA-Zāáǎàēéěèīíǐìōóǒòūúǔùüǖǘǚǜńňǹḿm̀·\s-]+$/;
            let pinyin = '';
            for (const line of lines) {
                if (!toneLineRe.test(line)) continue;
                if (!/[a-zA-Z]/.test(line)) continue;
                if (line.length > 32) continue;
                pinyin = line.replace(/\s+/g, ' ').trim();
                break;
            }

            const findLineIndex = (keys) => {
                for (let i = 0; i < lines.length; i += 1) {
                    const line = lines[i];
                    for (const k of keys) {
                        if (line.includes(k)) return i;
                    }
                }
                return -1;
            };

            const defStart = findLineIndex(['释义', '解释', '基本释义', '含义']);
            const defEnd = (() => {
                if (defStart < 0) return -1;
                for (let i = defStart + 1; i < lines.length; i += 1) {
                    const l = lines[i];
                    if (l.includes('组词') || l.includes('近义') || l.includes('反义') || l.includes('相关') || l.includes('词语') || l.includes('成语')) return i;
                }
                return lines.length;
            })();

            const defLines = (defStart >= 0 && defEnd > defStart) ? lines.slice(defStart + 1, defEnd) : [];
            const defs = [];
            for (const l of defLines) {
                const m = /^\s*(\d+)\.\s*(.+)\s*$/.exec(l);
                if (m && m[2]) defs.push(m[2].trim());
            }
            if (defs.length === 0) {
                const combined = defLines.join(' ').replace(/\s+/g, ' ').trim();
                if (combined) defs.push(combined);
            }

            const originStart = findLineIndex(['出处', '来源', '词源']);
            let origin = '';
            if (originStart >= 0) {
                const chunk = lines.slice(originStart, Math.min(lines.length, originStart + 6)).join(' ').replace(/\s+/g, ' ').trim();
                origin = chunk.replace(/^(出处|来源|词源)\s*[:：]?\s*/g, '').trim();
            }

            return { pinyin, definitions: defs, origin };
        }

        async function fetchSelectionExplanation(queryText) {
            const q = normalizeQueryText(queryText);
            if (!q) return null;
            if (selectionQueryCache.has(q)) return selectionQueryCache.get(q);
            const url = `https://r.jina.ai/https://m.baidu.com/s?word=${encodeURIComponent(q + ' 拼音 释义')}`;
            const res = await fetch(url, { method: 'GET', mode: 'cors', credentials: 'omit', cache: 'no-store' });
            const text = await res.text();
            const data = parseBaiduMobileMarkdown(text);
            const out = { ...data, sourceUrl: `https://hanyu.baidu.com/s?wd=${encodeURIComponent(q)}` };
            selectionQueryCache.set(q, out);
            return out;
        }

        async function startSelectionQueryFetch(text) {
            const q = normalizeQueryText(text);
            if (!q) {
                clearQueryResult();
                return;
            }
            const seq = ++selectionQueryFetchSeq;
            setQueryResultHtml('<div class="query-result-hint">正在查询…</div>');
            try {
                const data = await fetchSelectionExplanation(q);
                if (seq !== selectionQueryFetchSeq) return;
                setQueryResultHtml(buildQueryResultHtml(q, data));
            } catch (e) {
                if (seq !== selectionQueryFetchSeq) return;
                setQueryResultHtml('<div class="query-result-hint">查询失败，可使用下方链接继续查询。</div>');
            }
        }

        function openSelectionQueryPanel() {
            const info = getReaderSelectionInfo() || epubSelectionInfo;
            const text = normalizeQueryText(selectionQueryText || (info ? info.text : '') || '');
            if (!text) return;
            selectionQueryText = text;
            ensureSelectionQueryDomMounted();
            forceCloseSettingsPanel();
            try { closeTOC(); } catch (e) {}
            try {
                const moreMenu = document.getElementById('moreMenu');
                if (moreMenu) moreMenu.classList.remove('active');
            } catch (e) {}
            const panelText = document.getElementById('queryPanelText');
            if (panelText) panelText.textContent = text;
            const overlay = document.getElementById('queryOverlay');
            const panel = document.getElementById('queryPanel');
            if (overlay) overlay.classList.add('active');
            if (panel) panel.classList.add('active');
            hideSelectionQueryBtn();
            startSelectionQueryFetch(text);
        }

        function hideSelectionQueryPanel() {
            const overlay = document.getElementById('queryOverlay');
            const panel = document.getElementById('queryPanel');
            if (overlay) overlay.classList.remove('active');
            if (panel) panel.classList.remove('active');
            unmountSelectionQueryDom();
            try { updateSelectionQueryBtnFromSelection(); } catch (e) {}
        }

        function openSelectionQuery(kind) {
            const text = String(selectionQueryText || '').trim();
            if (!text) return;
            const q = encodeURIComponent(text);
            let url = '';
            if (kind === 'youdao') url = `https://www.youdao.com/result?word=${q}&lang=zh`;
            else if (kind === 'baidu_hanyu') url = `https://hanyu.baidu.com/s?wd=${q}`;
            else if (kind === 'baidu_baike') url = `https://baike.baidu.com/item/${q}`;
            else if (kind === 'wiki') url = `https://zh.wikipedia.org/wiki/${q}`;
            if (!url) return;
            try {
                const w = window.open(url, '_blank');
                if (!w) location.href = url;
            } catch (e) {
                location.href = url;
            }
        }

        function attachEpubInteractionHandlers(renditionInstance, session) {
            if (!renditionInstance) return;

            try {
                renditionInstance.on('selected', (cfiRange, contents) => {
                    if (session !== txtSessionId) return;
                    if (!contents || !contents.window) return;
                    const sel = contents.window.getSelection ? contents.window.getSelection() : null;
                    if (!sel || sel.rangeCount <= 0 || sel.isCollapsed) return;
                    const text = normalizeQueryText(sel.toString());
                    if (!text) return;
                    let rect = null;
                    try { rect = sel.getRangeAt(0).getBoundingClientRect(); } catch (e) {}
                    if (!rect) return;
                    const iframe = contents.iframe || (contents.document && contents.document.defaultView ? contents.document.defaultView.frameElement : null);
                    if (!iframe || !iframe.getBoundingClientRect) return;
                    const iframeRect = iframe.getBoundingClientRect();
                    const mergedRect = {
                        left: iframeRect.left + (rect.left || 0),
                        top: iframeRect.top + (rect.top || 0),
                        width: rect.width || 0,
                        height: rect.height || 0
                    };
                    epubSelectionInfo = { text, rect: mergedRect };
                    showSelectionQueryBtnAtRect(text, mergedRect);
                });
            } catch (e) {}

            try {
                renditionInstance.on('rendered', (section, contents) => {
                    if (session !== txtSessionId) return;
                    if (!contents || !contents.document || !contents.window) return;
                    const doc = contents.document;
                    const root = doc.documentElement;
                    if (root && root.getAttribute('data-mozi-epub-bind') === '1') return;
                    if (root) root.setAttribute('data-mozi-epub-bind', '1');

                    let startX = 0;
                    let startY = 0;
                    let startAt = 0;
                    let edgeCandidate = false;
                    let edgeMoved = false;
                    const isSwipeBack = (dx, dy, dt) => {
                        if (dt > 650) return false;
                        if (dx < 78) return false;
                        if (Math.abs(dy) > 44) return false;
                        if (Math.abs(dx) < Math.abs(dy) * 1.35) return false;
                        return true;
                    };
                    doc.addEventListener('touchstart', (e) => {
                        if (session !== txtSessionId) return;
                        if (!e || !e.touches || !e.touches[0]) return;
                        const t = e.touches[0];
                        startX = t.clientX || 0;
                        startY = t.clientY || 0;
                        startAt = Date.now();
                        edgeCandidate = startX <= 16;
                        edgeMoved = false;
                    }, { passive: true });

                    doc.addEventListener('touchmove', (e) => {
                        if (session !== txtSessionId) return;
                        if (!e || !e.touches || !e.touches[0]) return;
                        const t = e.touches[0];
                        const dx = (t.clientX || 0) - startX;
                        const dy = (t.clientY || 0) - startY;
                        if (edgeCandidate && !edgeMoved && (Math.abs(dx) > 10 || Math.abs(dy) > 10)) edgeMoved = true;
                    }, { passive: true });

                    doc.addEventListener('touchend', (e) => {
                        if (session !== txtSessionId) return;
                        if (!e || !e.changedTouches || !e.changedTouches[0]) return;
                        const t = e.changedTouches[0];
                        const dx = (t.clientX || 0) - startX;
                        const dy = (t.clientY || 0) - startY;
                        const dt = Math.max(1, Date.now() - startAt);
                        if (edgeCandidate && edgeMoved && isSwipeBack(dx, dy, dt)) {
                            suppressNextContentClickUntil = Date.now() + 700;
                            if (hasAnyReaderPanelOpen()) {
                                toggleMenu({ event: e, ignoreGuard: true });
                                return;
                            }
                            closeBook();
                            return;
                        }
                    }, { passive: true });

                    doc.addEventListener('selectionchange', () => {
                        if (session !== txtSessionId) return;
                        try {
                            const sel = contents.window.getSelection ? contents.window.getSelection() : null;
                            const txt = sel ? normalizeQueryText(sel.toString()) : '';
                            if (!txt) {
                                epubSelectionInfo = null;
                                if (!hasAnyReaderPanelOpen()) hideSelectionQueryBtn();
                            }
                        } catch (e) {}
                    });
                });
            } catch (e) {}
        }

        function shouldIgnoreMenuToggleTarget(target) {
            if (!target) return false;
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const queryPanel = document.getElementById('queryPanel');
            const queryOverlay = document.getElementById('queryOverlay');
            const queryBtn = document.getElementById('selectionQueryBtn');
            const tocButton = document.getElementById('tocButton');
            const settingsButton = document.getElementById('settingsButton');
            const moreButton = document.getElementById('moreButton');
            const closeButton = document.getElementById('closeButton');
            if (tocPanel && tocPanel.contains(target)) return true;
            if (tocOverlay && tocOverlay.contains(target)) return true;
            if (settingsPanel && settingsPanel.contains(target)) return true;
            if (moreMenu && moreMenu.contains(target)) return true;
            if (queryPanel && queryPanel.contains(target)) return true;
            if (queryOverlay && queryOverlay.contains(target)) return true;
            if (queryBtn && queryBtn.contains(target)) return true;
            if (tocButton && tocButton.contains(target)) return true;
            if (settingsButton && settingsButton.contains(target)) return true;
            if (moreButton && moreButton.contains(target)) return true;
            if (closeButton && closeButton.contains(target)) return true;
            const topBar = document.querySelector('.reader-top-bar');
            const bottomBar = document.querySelector('.reader-bottom-bar');
            if (topBar && topBar.contains(target)) return true;
            if (bottomBar && bottomBar.contains(target)) return true;
            return false;
        }

        function toggleMenu(options = null) {
            const ignoreGuard = !!(options && options.ignoreGuard);
            const eventTarget = options && options.event ? options.event.target : null;
            const target = eventTarget || lastPointerTarget;
            if (!ignoreGuard && shouldIgnoreMenuToggleTarget(target)) return;
            if (!ignoreGuard && (Date.now() - lastFlipGestureAt) < 320) return;
            const reader = document.getElementById('readerView');
            // Close panels if open
            const settings = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const queryOverlay = document.getElementById('queryOverlay');
            const queryPanel = document.getElementById('queryPanel');
            
            if (settings.classList.contains('active')) {
                settings.classList.remove('active');
                try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
                return;
            }
            if (moreMenu.classList.contains('active')) {
                moreMenu.classList.remove('active');
                return;
            }
            if (tocPanel.classList.contains('active')) {
                tocPanel.classList.remove('active');
                tocOverlay.classList.remove('active');
                return;
            }
            if ((queryOverlay && queryOverlay.classList.contains('active')) || (queryPanel && queryPanel.classList.contains('active'))) {
                hideSelectionQueryPanel();
                return;
            }
            
            reader.classList.toggle('menu-visible');
        }
        
        function toggleNightMode() {
            const body = document.body;
            const icon = document.getElementById('nightModeIcon');
            const text = document.getElementById('nightModeText');
            
            body.classList.toggle('night-mode');
            
            if (body.classList.contains('night-mode')) {
                // Change to Sun icon
                icon.innerHTML = '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>';
                text.innerText = "日间";
            } else {
                // Change to Moon icon
                icon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>';
                text.innerText = "夜间";
            }
        }
        
        function toggleSettings() {
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            try {
                const settingsButton = document.getElementById('settingsButton');
                if (settingsButton && lastPointerTarget && !settingsButton.contains(lastPointerTarget)) return;
            } catch (e) {}
            try { forceCloseSelectionQueryPanel(); } catch (e) {}
            const panel = document.getElementById('settingsPanel');
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const moreMenu = document.getElementById('moreMenu');
            const reader = document.getElementById('readerView');
            if (tocPanel) tocPanel.classList.remove('active');
            if (tocOverlay) tocOverlay.classList.remove('active');
            if (moreMenu) moreMenu.classList.remove('active');
            if (reader) reader.classList.add('menu-visible');
            panel.classList.toggle('active');
            try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
        }
        
        function toggleMoreMenu() {
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            try { forceCloseSelectionQueryPanel(); } catch (e) {}
            const moreMenu = document.getElementById('moreMenu');
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const settingsPanel = document.getElementById('settingsPanel');
            const reader = document.getElementById('readerView');
            if (tocPanel) tocPanel.classList.remove('active');
            if (tocOverlay) tocOverlay.classList.remove('active');
            if (settingsPanel) settingsPanel.classList.remove('active');
            try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
            if (reader) reader.classList.add('menu-visible');
            moreMenu.classList.toggle('active');
        }
        
        function setReaderTheme(theme, el) {
            const body = document.body;
            body.classList.remove('night-mode'); // Reset
            
            // UI Selection State
            document.querySelectorAll('.theme-circle').forEach(c => c.classList.remove('active'));
            el.classList.add('active');
            
            if (theme === 'dark') {
                body.classList.add('night-mode');
                document.documentElement.style.removeProperty('--reader-hud-text');
                document.documentElement.style.removeProperty('--reader-hud-shadow');
            } else if (theme === 'sepia') {
                document.documentElement.style.setProperty('--reader-bg', '#f4ecd8');
                document.documentElement.style.setProperty('--reader-text', '#5b4636');
                document.documentElement.style.setProperty('--reader-menu-bg', '#f4ecd8');
                document.documentElement.style.setProperty('--reader-menu-text', '#5b4636');
                document.documentElement.style.setProperty('--reader-hud-text', 'rgba(91,70,54,0.5)');
                document.documentElement.style.setProperty('--reader-hud-shadow', 'rgba(244,236,216,0.28)');
            } else if (theme === 'green') {
                document.documentElement.style.setProperty('--reader-bg', '#dcedc8');
                document.documentElement.style.setProperty('--reader-text', '#33691e');
                document.documentElement.style.setProperty('--reader-menu-bg', '#dcedc8');
                document.documentElement.style.setProperty('--reader-menu-text', '#33691e');
                document.documentElement.style.setProperty('--reader-hud-text', 'rgba(51,105,30,0.5)');
                document.documentElement.style.setProperty('--reader-hud-shadow', 'rgba(220,237,200,0.28)');
            } else {
                // White/Default
                document.documentElement.style.removeProperty('--reader-bg');
                document.documentElement.style.removeProperty('--reader-text');
                document.documentElement.style.removeProperty('--reader-menu-bg');
                document.documentElement.style.removeProperty('--reader-menu-text');
                document.documentElement.style.removeProperty('--reader-hud-text');
                document.documentElement.style.removeProperty('--reader-hud-shadow');
            }
        }
        
        function updateFontSize(val) {
            document.documentElement.style.setProperty('--reader-font-size', val + 'px');
            document.getElementById('fontSizeDisplay').innerText = val;
            try {
                invalidateTxtCharsPerPage();
                if (currentTxtContent) {
                    if (currentFlipMode === 'slide') buildTxtPagedView('slide', Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : null);
                    else updatePageIndicatorByTxtPos(txtActiveAbsPos);
                }
                updateReaderBottomSheetOffset();
            } catch (e) {}
        }
        
        function updateLineHeight(val) {
            document.documentElement.style.setProperty('--reader-line-height', val / 10);
            try {
                invalidateTxtCharsPerPage();
                if (currentTxtContent) {
                    if (currentFlipMode === 'slide') buildTxtPagedView('slide', Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : null);
                    else updatePageIndicatorByTxtPos(txtActiveAbsPos);
                }
                updateReaderBottomSheetOffset();
            } catch (e) {}
        }
        
        function toggleToc() {
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            try { forceCloseSelectionQueryPanel(); } catch (e) {}
            const panel = document.getElementById('tocPanel');
            const overlay = document.getElementById('tocOverlay');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const reader = document.getElementById('readerView');
            const willOpen = !panel.classList.contains('active');
            if (settingsPanel) settingsPanel.classList.remove('active');
            try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
            if (moreMenu) moreMenu.classList.remove('active');
            if (willOpen && reader) reader.classList.add('menu-visible');
            panel.classList.toggle('active');
            overlay.classList.toggle('active');
            if (willOpen) {
                setTimeout(() => {
                    if (!panel.classList.contains('active')) return;
                    bindTocListSmartScroll();
                    armTocScrollFade();
                    scrollTocActiveIntoView();
                }, 0);
            }
        }
        
        function jumpToChapter(idx) {
            const el = document.getElementById('chap-' + idx);
            if(el) {
                el.scrollIntoView({ behavior: 'smooth' });
                toggleToc(); // Close menu
                toggleMenu({ ignoreGuard: true }); // Hide bars for immersion
            }
        }
        
        function scrollPage(direction) {
            const content = document.getElementById('readerContent');
            if (!content) return;
            const cs = window.getComputedStyle(content);
            const padT = parseFloat(cs.paddingTop || '0') || 0;
            const padB = parseFloat(cs.paddingBottom || '0') || 0;
            const visibleH = Math.max(160, (content.clientHeight || window.innerHeight) - padT - padB);
            const amount = visibleH * 0.92;
            const nextTop = (content.scrollTop || 0) + amount * direction;
            content.scrollTo({ top: nextTop, behavior: 'smooth' });
        }

    </script>

</body>
</html>
</toolcall_result>
