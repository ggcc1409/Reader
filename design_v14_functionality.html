<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- iOS PWA Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MOZI">
    <link rel="apple-touch-icon" id="appleTouchIcon" sizes="180x180" href="./icon/mozi_icon_180.png?v=2">
    <link rel="apple-touch-icon-precomposed" id="appleTouchIconPre" sizes="180x180" href="./icon/mozi_icon_180.png?v=2">
    <link rel="icon" type="image/svg+xml" href="./icon.svg?v=9">
    <meta name="theme-color" content="#141218">

    <!-- Libraries -->
    <script src="./libs/jszip.min.js"></script>
    <script src="./libs/epub.min.js"></script>

    <title>MOZI</title>
    <style>
        :root {
            /* V5 Color Scheme */
            --bg-color: #141218;
            --surface-color: #211f26;
            --surface-active: #2b2930;
            
            --primary-purple: #D0BCFF;
            --accent-purple: #7F5AF0;
            --muted-purple: #4a4458;
            
            --text-primary: #E6E1E5;
            --text-secondary: #CAC4D0;
            --text-tertiary: #938F99;
            
            /* Reader Theme Vars (Default Day) */
            --reader-bg: #f5f5f5;
            --reader-text: #333333;
            --reader-menu-bg: #ffffff;
            --reader-menu-text: #333333;
            --reader-font-size: 18px;
            --reader-line-height: 1.8;
            --tabbar-gap: 30px;
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
        }
        
        /* Night Mode Override */
        body.night-mode {
            --reader-bg: #1a1a1a;
            --reader-text: #cccccc;
            --reader-menu-bg: #2c2c2e;
            --reader-menu-text: #ffffff;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        input,
        textarea,
        [contenteditable="true"],
        .reader-content,
        .reader-content * {
            user-select: text;
            -webkit-user-select: text;
        }

        .debug-mode,
        .debug-mode * {
            user-select: text !important;
            -webkit-user-select: text !important;
        }

        body {
            background-color: #000;
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            perspective: 1500px;
        }

        /* Phone Simulator Frame (Desktop) */
        .phone-frame {
            width: 428px;
            height: 926px;
            background-color: var(--bg-color);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 60px rgba(127, 90, 240, 0.15);
            border-radius: 44px;
            border: 8px solid #222;
            transform: scale(var(--frame-scale, 1));
            transform-origin: center;
        }

        /* Mobile/PWA Mode Overrides */
        @media (max-width: 600px) {
            body {
                background-color: var(--bg-color);
                display: flex; /* Changed from block to flex to ensure centering if needed, but mostly to reset */
                flex-direction: column;
                height: 100vh;
                height: 100dvh;
                min-height: 100vh;
                overflow: hidden; 
                margin: 0;
                padding: 0;
            }
            .phone-frame {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                min-height: 100vh;
                border: none;
                border-radius: 0;
                box-shadow: none;
                position: absolute;
                top: 0; left: 0;
                transform: none;
            }
            @supports (-webkit-touch-callout: none) {
                body { height: -webkit-fill-available; }
                .phone-frame { height: -webkit-fill-available; }
            }
            /* Request 2: Remove Status Bar in Mobile */
            .status-bar { display: none !important; }
            .header-container { padding-top: max(20px, env(safe-area-inset-top)); }
        }

        /* --- UI Components --- */
        .status-bar {
            height: 47px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 26px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10;
            color: var(--text-primary);
            flex-shrink: 0;
        }

        /* View Container for Tabs */
        .view-section {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: absolute;
            top: 0; left: 0;
            background-color: var(--bg-color);
            transition: opacity 0.3s ease;
        }
        .view-section.hidden {
            opacity: 0;
            pointer-events: none;
            z-index: -1;
            visibility: hidden; /* Ensure it doesn't block clicks */
        }
        .view-section.active {
            opacity: 1;
            pointer-events: auto;
            z-index: 1;
            visibility: visible;
        }

        /* Scrollable Content Area */
        .scroll-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 24px 100px 24px; /* Bottom padding for tab bar */
            scrollbar-width: none;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        .scroll-content::-webkit-scrollbar { display: none; }

        .header-container {
            padding: 20px 24px 20px 24px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            min-height: 120px;
            position: relative;
            z-index: 5;
            flex-shrink: 0;
        }
        
        .header-glow {
            position: absolute;
            top: -50px; right: -50px;
            width: 200px; height: 200px;
            background: radial-gradient(circle, rgba(208, 188, 255, 0.15) 0%, rgba(20, 18, 24, 0) 70%);
            pointer-events: none;
        }

        .header-top-row {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;
        }
        .date-display { font-size: 13px; text-transform: uppercase; letter-spacing: 1px; color: var(--primary-purple); font-weight: 600; }
        .header-title { font-size: 38px; font-weight: 800; letter-spacing: -0.5px; color: var(--text-primary); margin-bottom: 8px; }
        .header-subtitle { font-size: 16px; color: var(--text-secondary); }
        .avatar-btn {
            width: 40px; height: 40px; border-radius: 20px;
            background-color: var(--surface-color); border: 1px solid var(--muted-purple);
            display: flex; align-items: center; justify-content: center; color: var(--primary-purple);
            overflow: hidden;
        }
        .avatar-btn img { width: 100%; height: 100%; object-fit: cover; }

        /* Quick Actions */
        .quick-actions { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 24px; }
        .action-card {
            background-color: var(--surface-color); padding: 16px; border-radius: 16px;
            display: flex; align-items: center; gap: 12px; cursor: pointer;
        }
        .action-card:active { background-color: var(--surface-active); transform: scale(0.98); }
        .action-icon {
            width: 36px; height: 36px; border-radius: 10px;
            background-color: rgba(208, 188, 255, 0.1); color: var(--primary-purple);
            display: flex; align-items: center; justify-content: center;
        }
        .action-text { font-size: 15px; font-weight: 600; }

        /* Section Header */
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-top: 24px; margin-bottom: 16px; }
        .section-title { font-size: 20px; font-weight: 700; color: var(--text-primary); }
        .view-toggle-btn {
            background: none; border: none; color: var(--primary-purple); cursor: pointer;
            display: flex; align-items: center; gap: 6px; padding: 8px; border-radius: 8px;
        }

        /* Book Cards */
        .books-container { display: flex; flex-direction: column; gap: 16px; transition: all 0.3s ease; padding-bottom: 20px; }
        .book-card {
            display: flex; background-color: var(--surface-color); padding: 16px;
            border-radius: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            position: relative; overflow: hidden;
            transition: transform 0.2s, background-color 0.2s; cursor: pointer;
        }
        .book-card:active { transform: scale(0.98); background-color: var(--surface-active); }
        .book-cover {
            width: 70px; height: 105px; border-radius: 8px; margin-right: 18px;
            flex-shrink: 0; box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            background-size: cover; background-position: center; position: relative;
            background-color: #333;
        }
        /* Dynamic Cover Generator Styles */
        .dynamic-cover {
            display: flex; align-items: center; justify-content: center;
            background: linear-gradient(135deg, #4b6cb7 0%, #182848 100%);
            color: white; padding: 5px; text-align: center;
        }
        .cover-1 { background: linear-gradient(135deg, #2b1f42 0%, #5e4b85 100%); }
        .cover-2 { background: linear-gradient(135deg, #1f2b42 0%, #4b6cb7 100%); }
        .cover-3 { background: linear-gradient(135deg, #421f1f 0%, #b74b4b 100%); }
        
        .cover-text {
            position: absolute; bottom: 6px; left: 6px; right: 6px;
            font-size: 10px; color: rgba(255,255,255,0.8); font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
        }
        .book-info { flex: 1; display: flex; flex-direction: column; justify-content: center; }
        .book-title { font-size: 18px; font-weight: 600; margin-bottom: 6px; color: var(--text-primary); line-height: 1.3; }
        .book-meta { font-size: 14px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .format-badge {
            font-size: 10px; padding: 2px 6px; border-radius: 4px;
            background-color: var(--muted-purple); color: var(--text-secondary); font-weight: 600;
        }
        .progress-container { display: flex; align-items: center; gap: 12px; margin-bottom: 6px; }
        .progress-track { flex: 1; height: 6px; background-color: #35313d; border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary-purple), var(--accent-purple)); border-radius: 3px; }
        .progress-text { font-size: 13px; color: var(--primary-purple); font-weight: 600; width: 35px; text-align: right; }
        .book-stats { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--text-tertiary); }
        .edit-btn {
            padding: 4px 8px; background: rgba(255,255,255,0.05); border-radius: 4px;
            color: var(--text-secondary); border: none; cursor: pointer; z-index: 5;
        }
        
        /* Grid View Overrides */
        .books-container.grid-view { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
        .books-container.grid-view .book-card { flex-direction: column; padding: 10px; gap: 8px; height: 100%; }
        .books-container.grid-view .book-cover { width: 100%; height: auto; aspect-ratio: 2/3; margin-right: 0; border-radius: 6px; }
        .books-container.grid-view .book-info { justify-content: flex-start; gap: 4px; }
        .books-container.grid-view .book-title {
            font-size: 13px; margin-bottom: 0; display: -webkit-box; -webkit-line-clamp: 2;
            -webkit-box-orient: vertical; overflow: hidden; height: 32px;
        }
        .books-container.grid-view .book-meta,
        .books-container.grid-view .progress-container,
        .books-container.grid-view .book-stats { display: none; }
        
        /* Tab Bar */
        .tab-bar {
            position: absolute; bottom: 30px; left: 24px; right: 24px; height: 80px;
            background-color: rgba(33, 31, 38, 0.9); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border-radius: 24px; display: flex; justify-content: space-around;
            align-items: center; padding: 0 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.05);
            z-index: 50;
            padding-bottom: 0;
        }
        @media (max-width: 600px) {
            .tab-bar {
                position: fixed;
                left: 16px; right: 16px;
                bottom: calc(var(--tabbar-gap) + env(safe-area-inset-bottom));
                border-radius: 20px;
                height: 64px;
                padding-bottom: 0;
                margin-bottom: 0;
            }
            .scroll-content { padding-bottom: calc(100px + var(--tabbar-gap) + env(safe-area-inset-bottom)); }
        }
        .tab-item {
            flex: 1; display: flex; flex-direction: column; align-items: center;
            justify-content: center; gap: 4px; color: var(--text-tertiary);
            transition: all 0.3s ease; cursor: pointer; height: 100%;
        }
        .tab-item.active { color: var(--primary-purple); }
        .tab-icon { width: 26px; height: 26px; stroke-width: 2px; }
        .tab-text { font-size: 11px; font-weight: 500; }

        /* --- Discover View Styles --- */
        .search-container {
            margin-bottom: 24px;
            position: relative;
        }
        .search-input {
            width: 100%;
            height: 50px;
            background: var(--surface-color);
            border: 1px solid var(--muted-purple);
            border-radius: 16px;
            padding: 0 20px 0 50px;
            color: white;
            font-size: 16px;
            outline: none;
        }
        .search-input:focus { border-color: var(--primary-purple); }
        .search-icon {
            position: absolute; left: 16px; top: 50%; transform: translateY(-50%);
            color: var(--text-tertiary);
        }
        .search-results {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;
            min-height: 200px;
        }
        .search-item {
            display: flex; flex-direction: column; gap: 8px; cursor: pointer;
        }
        .search-cover {
            width: 100%; aspect-ratio: 2/3; background: #333; border-radius: 8px;
            background-size: cover; background-position: center;
        }
        .search-title { font-size: 12px; font-weight: 600; color: var(--text-primary); line-height: 1.3; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .search-author { font-size: 10px; color: var(--text-secondary); }

        /* --- Me View Styles --- */
        .profile-header {
            display: flex; flex-direction: column; align-items: center; padding: 20px 0;
        }
        .profile-avatar {
            width: 100px; height: 100px; border-radius: 50%;
            background: var(--surface-color); border: 2px solid var(--accent-purple);
            margin-bottom: 16px; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        .profile-name { font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 4px; }
        .profile-bio { font-size: 14px; color: var(--text-secondary); }
        
        .stats-row {
            display: flex; justify-content: space-around; width: 100%; margin: 30px 0;
            background: var(--surface-color); padding: 20px; border-radius: 20px;
        }
        .stat-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .stat-val { font-size: 20px; font-weight: 800; color: var(--primary-purple); }
        .stat-label { font-size: 12px; color: var(--text-tertiary); }

        .menu-list { display: flex; flex-direction: column; gap: 12px; }
        .menu-item {
            display: flex; align-items: center; justify-content: space-between;
            background: var(--surface-color); padding: 16px 20px; border-radius: 16px;
            cursor: pointer;
        }
        .menu-item-left { display: flex; align-items: center; gap: 16px; font-weight: 600; font-size: 15px; }
        .menu-icon { color: var(--text-tertiary); }

        /* --- LAYERS (Animation & Reader) --- */
        
        /* Animation Layer */
        .animation-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 400; perspective: 1500px;
            visibility: hidden; pointer-events: none;
        }
        .animation-layer.active { visibility: visible; }

        .flying-book {
            position: absolute; transform-style: preserve-3d;
            transition: left 0.95s cubic-bezier(0.2, 0.8, 0.2, 1), top 0.95s cubic-bezier(0.2, 0.8, 0.2, 1), width 0.95s cubic-bezier(0.2, 0.8, 0.2, 1), height 0.95s cubic-bezier(0.2, 0.8, 0.2, 1), transform 0.95s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .flying-cover {
            position: absolute; width: 100%; height: 100%;
            border-radius: 6px; backface-visibility: hidden;
            background-size: cover; background-position: center;
            transform-origin: left center;
            transition: transform 1.05s cubic-bezier(0.2, 0.8, 0.2, 1), border-radius 0.3s;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.5);
        }
        .flying-cover::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #eee; transform: rotateY(180deg); backface-visibility: hidden;
        }
        .flying-page {
            position: absolute; width: 100%; height: 100%;
            background: var(--reader-bg); color: var(--reader-text); top: 0; left: 0;
            z-index: -1; box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
            border-radius: 2px 6px 6px 2px; opacity: 0;
            transition: opacity 0.55s ease; padding: 20px; overflow: hidden;
            display: flex; flex-direction: column; justify-content: flex-start;
        }
        .flying-book.open .flying-cover { transform: rotateY(-160deg); border-radius: 2px 0 0 2px; }
        .flying-book.open .flying-page { opacity: 1; }

        /* Reader View */
        .reader-view {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--reader-bg); color: var(--reader-text);
            z-index: 300; display: flex; flex-direction: column;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transform: translateX(100%);
            transition: transform 260ms cubic-bezier(0.2, 0.8, 0.2, 1), opacity 260ms ease, visibility 0s linear 260ms;
            --reader-bottom-sheet: 0px;
        }
        .reader-view.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transform: translateX(0);
            transition: transform 260ms cubic-bezier(0.2, 0.8, 0.2, 1), opacity 260ms ease;
        }
        .reader-view.closing { opacity: 0; visibility: visible; pointer-events: none; transform: translateX(100%); }

        /* Fanqie-like Reader Menu */
        .reader-top-bar {
            position: absolute; top: 0; left: 0; right: 0;
            height: 56px;
            padding-top: env(safe-area-inset-top);
            padding-bottom: 6px;
            padding-left: 14px; padding-right: 14px;
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.45);
            color: #fff;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
            transition: transform 220ms cubic-bezier(0.2, 0.8, 0.2, 1), opacity 180ms ease;
            z-index: 310;
        }
        
        .reader-bottom-bar {
            position: absolute; left: 0; right: 0; bottom: 0;
            padding-top: 0;
            padding-left: 16px; padding-right: 16px;
            padding-bottom: env(safe-area-inset-bottom);
            margin-bottom: 0;
            background: rgba(0,0,0,0.45);
            color: #fff;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transform: translateY(100%);
            opacity: 0;
            pointer-events: none;
            transition: transform 220ms cubic-bezier(0.2, 0.8, 0.2, 1), opacity 180ms ease;
            z-index: 310;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            height: calc(82px + env(safe-area-inset-bottom));
        }
        .reader-bottom-bar-inner {
            width: 100%;
            height: 82px;
            display: flex;
            align-items: center;
            justify-content: space-evenly;
            gap: 10px;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .reader-view.menu-visible .reader-top-bar { transform: translateY(0); opacity: 1; pointer-events: auto; }
        .reader-view.menu-visible .reader-bottom-bar { transform: translateY(0); opacity: 1; pointer-events: auto; }

        .reader-content {
            flex: 1;
            padding: calc(56px + env(safe-area-inset-top) + 18px) 24px calc(82px + env(safe-area-inset-bottom) + 18px + var(--reader-bottom-sheet)) 24px;
            font-family: "Georgia", serif; 
            font-size: var(--reader-font-size); 
            line-height: var(--reader-line-height);
            background-color: var(--reader-bg);
            overflow-y: auto; -webkit-overflow-scrolling: touch;
            overflow-x: hidden;
            overscroll-behavior-x: none;
            width: 100%;
            scrollbar-width: none;
            -ms-overflow-style: none;
            word-break: break-word;
            overflow-wrap: anywhere;
        }
        .reader-content::-webkit-scrollbar { width: 0; height: 0; display: none; }
        .reader-content * { max-width: 100%; }
        .reader-content p { scroll-margin-top: 72px; }
        .reader-content div,
        .reader-content h1,
        .reader-content h2,
        .reader-content h3 { scroll-margin-top: 20px; }

        .reader-view.menu-visible .reader-content {
            padding: calc(56px + env(safe-area-inset-top) + 18px) 24px calc(82px + env(safe-area-inset-bottom) + 18px + var(--reader-bottom-sheet)) 24px;
        }
        
        /* Flip Mode Styles */
        .mode-scroll { overflow-y: auto; overflow-x: hidden; touch-action: pan-y; }
        .flip-segment {
            position: relative;
            background: rgba(128,128,128,0.14);
            border-radius: 12px;
            padding: 4px;
            display: flex;
            gap: 0;
            user-select: none;
            -webkit-user-select: none;
        }
        .flip-indicator {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            width: calc((100% - 8px) / 2);
            border-radius: 8px;
            background: rgba(255,255,255,0.16);
            box-shadow: 0 8px 22px rgba(0,0,0,0.18);
            transform: translateX(0%);
            transition: transform 220ms cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .flip-option {
            position: relative;
            z-index: 1;
            flex: 1;
            text-align: center;
            padding: 8px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            opacity: 0.72;
            transition: opacity 160ms ease;
        }
        .flip-option.active { opacity: 1; font-weight: 600; }
        .mode-slide { 
            overflow-x: auto; 
            overflow-y: hidden;
            height: 100%;
            padding: 0;
            display: flex;
            scroll-snap-type: x mandatory;
            scroll-snap-stop: normal;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-x;
        }
        .mode-slide .paged-page { position: relative; }
        .mode-slide .paged-page::after {
            content: "";
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 1px;
            background: rgba(0,0,0,0.08);
            pointer-events: none;
        }
        .mode-sim {
            overflow: hidden;
            height: 100%;
            padding: 0;
            position: relative;
            touch-action: pan-x;
        }
        .paged-page {
            flex: 0 0 100%;
            width: 100%;
            height: 100%;
            scroll-snap-align: start;
            box-sizing: border-box;
            padding: calc(56px + env(safe-area-inset-top) + 18px) 24px calc(82px + env(safe-area-inset-bottom) + 18px + var(--reader-bottom-sheet)) 24px;
            overflow: hidden;
        }
        .paged-text { white-space: pre-wrap; word-break: break-word; line-height: var(--reader-line-height); }
        .paged-line { line-height: var(--reader-line-height); }
        .paged-gap { height: calc(var(--reader-font-size) * 0.6); }
        .sim-surface { position: absolute; inset: 0; perspective: 1600px; }
        .sim-current, .sim-next, .sim-turn {
            position: absolute;
            inset: 0;
        }
        .sim-next { opacity: 0.98; }
        .sim-turn {
            transform-style: preserve-3d;
            backface-visibility: visible;
            box-shadow: 0 20px 40px rgba(0,0,0,0.25);
            pointer-events: none;
        }
        .sim-sheet { position: absolute; inset: 0; transform-style: preserve-3d; }
        .sim-front, .sim-back { position: absolute; inset: 0; backface-visibility: hidden; }
        .sim-back { transform: rotateY(180deg) scaleX(-1); filter: brightness(0.98); }
        .sim-shadow {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 180ms ease;
        }
        .sim-turn.turn-forward .sim-shadow {
            opacity: 1;
            background: linear-gradient(90deg, rgba(0,0,0,0.25), rgba(0,0,0,0.12), rgba(0,0,0,0.02), rgba(0,0,0,0));
        }
        .sim-turn.turn-backward .sim-shadow {
            opacity: 1;
            background: linear-gradient(270deg, rgba(0,0,0,0.25), rgba(0,0,0,0.12), rgba(0,0,0,0.02), rgba(0,0,0,0));
        }
        
        .reader-btn {
            background: none; border: none; font-size: 12px;
            color: var(--reader-menu-text); cursor: pointer;
            display: flex; flex-direction: column; align-items: center; gap: 4px;
            width: 60px;
        }
        .reader-btn svg { width: 24px; height: 24px; }
        .reader-bottom-bar .reader-btn { height: 60px; padding: 0; justify-content: center; line-height: 1; }
        .reader-bottom-bar .reader-btn span { line-height: 1; }

        .reader-title-wrap { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .reader-page-indicator { font-size: 12px; opacity: 0.65; line-height: 1; }
        .reader-chapter-page-indicator {
            position: absolute;
            left: 50%;
            bottom: calc(82px + env(safe-area-inset-bottom) + 8px);
            transform: translateX(-50%);
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(0,0,0,0.45);
            color: #fff;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            font-size: 12px;
            line-height: 1;
            opacity: 0.75;
            pointer-events: none;
            z-index: 309;
        }

        /* Settings Bar (Slide up) */
        .settings-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 9999;
            height: auto;
            max-height: 50vh;
            padding: 20px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            background: var(--reader-menu-bg);
            color: var(--reader-menu-text);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
            pointer-events: none;
        }
        .settings-bar.active { transform: translateY(0); pointer-events: auto; }
        @media (max-width: 600px) {
            .settings-bar { max-height: calc(60vh + env(safe-area-inset-bottom)); }
        }
        
        .setting-row { margin-bottom: 24px; }
        .setting-label { font-size: 14px; margin-bottom: 10px; opacity: 0.7; font-weight: 600; }
        .theme-options { display: flex; gap: 16px; }
        .theme-circle {
            width: 48px; height: 48px; border-radius: 24px; border: 2px solid rgba(0,0,0,0.1);
            cursor: pointer; position: relative;
        }
        .theme-circle.active::after {
            content: ''; position: absolute; top: -4px; left: -4px; right: -4px; bottom: -4px;
            border-radius: 50%; border: 2px solid var(--accent-purple);
        }
        .theme-white { background: #f5f5f5; }
        .theme-sepia { background: #f4ecd8; }
        .theme-dark { background: #1a1a1a; border-color: #333; }
        .theme-green { background: #dcedc8; }
        
        .slider-container {
            display: flex; justify-content: space-between; align-items: center; 
            background: rgba(128,128,128,0.1); border-radius: 12px; padding: 12px 16px;
        }
        .slider-control {
            flex: 1; margin: 0 16px;
            -webkit-appearance: none; height: 4px; background: rgba(128,128,128,0.3); border-radius: 2px;
        }
        .slider-control::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; 
            background: var(--accent-purple); box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        /* Table of Contents (Slide Over) */
        .toc-panel {
            position: absolute; top: 0; left: 0; bottom: 0; width: 85%;
            background: var(--reader-menu-bg); color: var(--reader-menu-text);
            z-index: 330; transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 5px 0 20px rgba(0,0,0,0.2);
            padding: 0; display: flex; flex-direction: column;
            padding-top: env(safe-area-inset-top);
            overscroll-behavior: contain;
            touch-action: pan-y;
        }
        .toc-panel.active { transform: translateX(0); }
        
        .toc-header {
            padding: 50px 24px 20px 24px;
            border-bottom: 1px solid rgba(128,128,128,0.1);
        }
        .toc-title { font-size: 24px; font-weight: 800; }
        .toc-subtitle { font-size: 14px; opacity: 0.7; margin-top: 4px; }
        
        .toc-list { flex: 1; overflow-y: auto; padding: 0 24px; overscroll-behavior: contain; -webkit-overflow-scrolling: touch; }
        .toc-item { 
            padding: 20px 0; border-bottom: 1px solid rgba(128,128,128,0.1); 
            font-size: 16px; cursor: pointer; display: flex; justify-content: space-between;
        }
        .toc-item:active { opacity: 0.5; }
        .toc-item.active { color: var(--accent-purple); font-weight: 600; }

        .toc-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 325;
            opacity: 0; visibility: hidden; transition: opacity 0.3s;
        }
        .toc-overlay.active { opacity: 1; visibility: visible; }

        .selection-query-btn {
            position: absolute;
            z-index: 345;
            height: 32px;
            padding: 0 12px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.16);
            background: rgba(33, 31, 38, 0.95);
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transform: translateY(6px);
            transition: opacity 140ms ease, transform 180ms cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .selection-query-btn.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .query-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.45);
            z-index: 344;
            opacity: 0;
            visibility: hidden;
            transition: opacity 180ms ease;
            pointer-events: none;
        }
        .query-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .query-panel {
            position: absolute;
            left: 0; right: 0; bottom: 0;
            z-index: 346;
            max-height: 62vh;
            padding: 16px 16px calc(16px + env(safe-area-inset-bottom)) 16px;
            background: var(--reader-menu-bg);
            color: var(--reader-menu-text);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -8px 26px rgba(0,0,0,0.22);
            transform: translateY(100%);
            transition: transform 240ms cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .query-panel.active {
            transform: translateY(0);
            pointer-events: auto;
        }
        .query-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        .query-title {
            font-size: 15px;
            font-weight: 800;
        }
        .query-text {
            font-size: 13px;
            opacity: 0.75;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .query-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .query-action {
            height: 44px;
            border-radius: 12px;
            border: 1px solid rgba(128,128,128,0.18);
            background: rgba(128,128,128,0.08);
            color: inherit;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
        }
        .query-action:active { opacity: 0.7; }
        .query-result {
            flex: 1;
            min-height: 120px;
            border-radius: 14px;
            border: 1px solid rgba(128,128,128,0.14);
            background: rgba(128,128,128,0.06);
            padding: 12px;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }
        .query-result,
        .query-result * {
            user-select: text;
            -webkit-user-select: text;
        }
        .query-result-title { font-size: 14px; font-weight: 800; margin-bottom: 6px; }
        .query-result-meta { font-size: 12px; opacity: 0.75; margin-bottom: 10px; }
        .query-result-section { margin-top: 10px; }
        .query-result-section-title { font-size: 13px; font-weight: 800; margin-bottom: 6px; }
        .query-result-list { display: flex; flex-direction: column; gap: 6px; }
        .query-result-item { font-size: 13px; line-height: 1.55; opacity: 0.92; }
        .query-result-hint { font-size: 12px; opacity: 0.7; line-height: 1.55; }

        /* More Menu */
        .more-menu {
            position: absolute; top: 80px; right: 16px;
            width: 180px; background: var(--reader-menu-bg); color: var(--reader-menu-text);
            border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            padding: 8px; z-index: 340;
            opacity: 0; visibility: hidden; transform: scale(0.9); transform-origin: top right;
            transition: all 0.2s;
            top: calc(80px + env(safe-area-inset-top)); /* Adjust for notch */
        }
        .more-menu.active { opacity: 1; visibility: visible; transform: scale(1); }
        .more-item {
            padding: 12px 16px; display: flex; align-items: center; gap: 12px;
            font-size: 14px; border-radius: 8px; cursor: pointer;
        }
        .more-item:active { background: rgba(128,128,128,0.1); }

        /* Edit Modal */
        .modal-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            z-index: 400; opacity: 0; visibility: hidden; transition: opacity 0.2s;
        }
        .modal-overlay.active { opacity: 1; visibility: visible; pointer-events: auto; }
        .modal-card {
            width: 300px; background: var(--surface-color); border-radius: 20px;
            padding: 24px; border: 1px solid var(--muted-purple);
            transform: scale(0.9); transition: transform 0.2s;
        }
        .modal-overlay.active .modal-card { transform: scale(1); }
        .modal-title { font-size: 18px; font-weight: 700; margin-bottom: 16px; color: var(--text-primary); }
        .modal-input {
            width: 100%; background: rgba(0,0,0,0.3); border: 1px solid var(--muted-purple);
            color: white; padding: 12px; border-radius: 10px; font-size: 16px; margin-bottom: 20px; outline: none;
        }
        .modal-input:focus { border-color: var(--primary-purple); }
        .modal-actions { display: flex; justify-content: flex-end; gap: 12px; }
        .btn { padding: 10px 20px; border-radius: 10px; font-weight: 600; font-size: 14px; cursor: pointer; border: none; }
        .btn-cancel { background: transparent; color: var(--text-secondary); }
        .btn-save { background: var(--accent-purple); color: white; }

    </style>
</head>
<body>

    <div class="phone-frame">
        <!-- Status Bar (Hidden on Mobile) -->
        <div class="status-bar">
            <span>9:48</span>
            <div style="display: flex; gap: 6px;">
                <svg width="18" height="12" viewBox="0 0 18 12" fill="currentColor"><path d="M16 4h-2V2h2v2zm0 4h-2V6h2v2zm0 4h-2v-2h2v2zM2 12h2V0H2v12zm4 0h2V4H6v8zm4 0h2V6h-2v6z"/></svg>
                <svg width="24" height="12" viewBox="0 0 24 12" fill="currentColor"><path d="M20 3.5V0H0v12h20V8.5h1.5V11H24V1h-2.5v2.5H20zM18 10H2V2h16v8z"/></svg>
            </div>
        </div>

        <!-- Hidden File Input -->
        <input type="file" id="fileInput" hidden accept=".txt,.epub,.pdf">

        <!-- VIEW: BOOKSHELF -->
        <div id="view-bookshelf" class="view-section active">
            <div class="header-container">
                <div class="header-glow"></div>
                <div class="header-top-row">
                    <span class="date-display">WEDNESDAY, JAN 28</span>
                    <div class="avatar-btn" onclick="switchTab('me')">
                        <div style="width:100%;height:100%;background:#211f26;display:flex;align-items:center;justify-content:center;color:#D0BCFF;font-weight:bold;">U</div>
                    </div>
                </div>
                <h1 class="header-title">书架</h1>
                <div class="header-subtitle">最近阅读 3 本书</div>
            </div>

            <div class="scroll-content">
                <!-- Quick Actions -->
                <div class="quick-actions">
                    <div class="action-card" onclick="triggerImport()">
                        <div class="action-icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg></div>
                        <span class="action-text">导入书籍</span>
                    </div>
                    <div class="action-card" onclick="alert('Wi-Fi 传书功能演示')">
                        <div class="action-icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>
                        <span class="action-text">Wi-Fi 传书</span>
                    </div>
                </div>

                <div class="section-header">
                    <span class="section-title">我的书籍</span>
                    <button class="view-toggle-btn" onclick="toggleView()" id="toggleBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                        <span>视图</span>
                    </button>
                </div>

                <!-- Books Container -->
                <div class="books-container" id="booksContainer">
                    <!-- Book 1 -->
                    <div class="book-card" onclick="openBook(this)">
                        <div class="book-cover cover-1">
                            <div class="cover-text">三体：死神永生</div>
                            <div class="reading-dot"></div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">三体：死神永生</div>
                            <div class="book-meta"><span>刘慈欣</span><span class="format-badge">EPUB</span></div>
                            <div class="progress-container">
                                <div class="progress-track"><div class="progress-fill" style="width: 45%;"></div></div>
                                <span class="progress-text">45%</span>
                            </div>
                            <div class="book-stats"><span>52.4万字</span><button class="edit-btn" onclick="event.stopPropagation(); editBook(this)">编辑</button></div>
                        </div>
                    </div>
                    <!-- Book 2 -->
                    <div class="book-card" onclick="openBook(this)">
                        <div class="book-cover cover-2">
                            <div class="cover-text">Thinking Fast</div>
                            <div class="reading-dot"></div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">Thinking, Fast and Slow</div>
                            <div class="book-meta"><span>Daniel Kahneman</span><span class="format-badge">PDF</span></div>
                            <div class="progress-container">
                                <div class="progress-track"><div class="progress-fill" style="width: 12%;"></div></div>
                                <span class="progress-text">12%</span>
                            </div>
                            <div class="book-stats"><span>49.9万字</span><button class="edit-btn" onclick="event.stopPropagation(); editBook(this)">编辑</button></div>
                        </div>
                    </div>
                    <!-- Book 3 -->
                    <div class="book-card" onclick="openBook(this)">
                        <div class="book-cover cover-3">
                            <div class="cover-text">Steve Jobs</div>
                            <div class="reading-dot"></div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">Steve Jobs</div>
                            <div class="book-meta"><span>Walter Isaacson</span><span class="format-badge">TXT</span></div>
                            <div class="progress-container">
                                <div class="progress-track"><div class="progress-fill" style="width: 88%;"></div></div>
                                <span class="progress-text">88%</span>
                            </div>
                            <div class="book-stats"><span>65.1万字</span><button class="edit-btn" onclick="event.stopPropagation(); editBook(this)">编辑</button></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- VIEW: DISCOVER -->
        <div id="view-discover" class="view-section hidden">
            <div class="header-container">
                <div class="header-glow"></div>
                <h1 class="header-title">发现</h1>
                <div class="header-subtitle">探索百万好书</div>
            </div>
            <div class="scroll-content">
                <div class="search-container">
                    <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    <input type="text" class="search-input" id="searchInput" placeholder="搜索书名、作者..." onkeypress="handleSearch(event)">
                </div>
                
                <div class="section-header" style="margin-top:0;">
                    <span class="section-title">热门推荐</span>
                </div>
                
                <div class="search-results" id="searchResults">
                    <!-- Initial Placeholder Content -->
                    <div class="search-item" onclick="alert('点击了书籍')">
                        <div class="search-cover" style="background-color: #333;"></div>
                        <div class="search-title">Dune</div>
                        <div class="search-author">Frank Herbert</div>
                    </div>
                    <div class="search-item" onclick="alert('点击了书籍')">
                        <div class="search-cover" style="background-color: #333;"></div>
                        <div class="search-title">1984</div>
                        <div class="search-author">George Orwell</div>
                    </div>
                    <div class="search-item" onclick="alert('点击了书籍')">
                        <div class="search-cover" style="background-color: #333;"></div>
                        <div class="search-title">The Great Gatsby</div>
                        <div class="search-author">F. Scott Fitzgerald</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- VIEW: ME -->
        <div id="view-me" class="view-section hidden">
            <div class="header-container" style="min-height:80px;">
                <div class="header-glow"></div>
            </div>
            <div class="scroll-content">
                <div class="profile-header">
                    <div class="profile-avatar">
                        <div style="width:100%;height:100%;background:#211f26;display:flex;align-items:center;justify-content:center;color:#D0BCFF;font-weight:bold;font-size:40px;">U</div>
                    </div>
                    <div class="profile-name">Reader User</div>
                    <div class="profile-bio">热爱阅读，探索世界</div>
                </div>

                <div class="stats-row">
                    <div class="stat-item">
                        <span class="stat-val">32</span>
                        <span class="stat-label">读完书籍</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-val">128</span>
                        <span class="stat-label">阅读小时</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-val">15</span>
                        <span class="stat-label">连续打卡</span>
                    </div>
                </div>

                <div class="menu-list">
                    <div class="menu-item">
                        <div class="menu-item-left">
                            <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                            <span>个人信息</span>
                        </div>
                        <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </div>
                    <div class="menu-item">
                        <div class="menu-item-left">
                            <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>
                            <span>阅读偏好</span>
                        </div>
                        <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </div>
                    <div class="menu-item">
                        <div class="menu-item-left">
                            <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                            <span>设置</span>
                        </div>
                        <svg class="menu-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </div>
                </div>
            </div>
        </div>

        <!-- Floating Tab Bar -->
        <div class="tab-bar">
            <div class="tab-item active" onclick="switchTab('bookshelf')" id="tab-bookshelf">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
                <span class="tab-text">书架</span>
            </div>
            <div class="tab-item" onclick="switchTab('discover')" id="tab-discover">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7" rx="2" ry="2"></rect><rect x="14" y="3" width="7" height="7" rx="2" ry="2"></rect><rect x="14" y="14" width="7" height="7" rx="2" ry="2"></rect><rect x="3" y="14" width="7" height="7" rx="2" ry="2"></rect></svg>
                <span class="tab-text">发现</span>
            </div>
            <div class="tab-item" onclick="switchTab('me')" id="tab-me">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                <span class="tab-text">我的</span>
            </div>
        </div>

        <!-- Edit Modal -->
        <div class="modal-overlay" id="editModal">
            <div class="modal-card">
                <div class="modal-title">编辑书籍信息</div>
                <input type="text" class="modal-input" id="bookTitleInput" placeholder="输入书名">
                <div class="modal-actions">
                    <button class="btn btn-cancel" onclick="closeModal()">取消</button>
                    <button class="btn btn-save" onclick="saveBookTitle()">保存</button>
                </div>
            </div>
        </div>

        <!-- Animation Layer -->
        <div class="animation-layer" id="animLayer"></div>

        <!-- Reader View (Enhanced) -->
        <div class="reader-view" id="readerView">
            <!-- Top Bar -->
            <div class="reader-top-bar">
                <button class="reader-btn" id="closeButton" style="width:40px;" onpointerdown="isClosingReader=true; saveTxtProgressFromView('close'); saveEpubProgressFromView('close');" onclick="event.stopPropagation(); closeBook()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </button>
                <div class="reader-title-wrap">
                    <span style="font-size: 14px; font-weight:600;" id="readerTitle">正在阅读</span>
                    <span class="reader-page-indicator" id="readerPageIndicator"></span>
                </div>
                <button class="reader-btn" id="moreButton" style="width:40px;" onclick="event.stopPropagation(); toggleMoreMenu()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></svg>
                </button>
            </div>
            
            <!-- More Menu -->
            <div class="more-menu" id="moreMenu" onclick="event.stopPropagation()">
                <div class="more-item" onclick="event.stopPropagation(); alert('添加书签成功')">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>
                    <span>添加书签</span>
                </div>
                <div class="more-item" onclick="event.stopPropagation(); alert('分享功能')">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
                    <span>分享书籍</span>
                </div>
                <div class="more-item" onclick="event.stopPropagation(); alert('书籍详情')">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                    <span>书籍信息</span>
                </div>
                <div class="more-item" onclick="event.stopPropagation(); toggleReaderDebug()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"></path></svg>
                    <span>调试面板</span>
                </div>
            </div>

            <!-- Content -->
            <div class="reader-content" id="readerContent"></div>
            <div class="reader-chapter-page-indicator" id="readerChapterPageIndicator"></div>
            <button class="selection-query-btn" id="selectionQueryBtn" onclick="event.stopPropagation(); openSelectionQueryPanel()">
                查询
            </button>
            <div class="query-overlay" id="queryOverlay" onclick="event.stopPropagation(); hideSelectionQueryPanel()"></div>
            <div class="query-panel" id="queryPanel" onclick="event.stopPropagation()">
                <div class="query-header">
                    <div style="display:flex; flex-direction:column; gap:4px; min-width:0;">
                        <div class="query-title">查询</div>
                        <div class="query-text" id="queryPanelText"></div>
                    </div>
                    <button class="query-action" style="width:72px; height:36px;" onclick="event.stopPropagation(); hideSelectionQueryPanel()">关闭</button>
                </div>
                <div class="query-result" id="queryResult"></div>
                <div class="query-actions">
                    <button class="query-action" onclick="event.stopPropagation(); openSelectionQuery('youdao')">怎么读</button>
                    <button class="query-action" onclick="event.stopPropagation(); openSelectionQuery('baidu_hanyu')">百度汉语</button>
                    <button class="query-action" onclick="event.stopPropagation(); openSelectionQuery('baidu_baike')">百度百科</button>
                    <button class="query-action" onclick="event.stopPropagation(); openSelectionQuery('wiki')">维基百科</button>
                </div>
            </div>

            <!-- Bottom Bar (Fanqie Style: Catalog | Night | Settings) -->
            <div class="reader-bottom-bar">
                <div class="reader-bottom-bar-inner">
                    <button class="reader-btn" id="tocButton" onclick="event.stopPropagation(); toggleToc()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                        <span>目录</span>
                    </button>
                    <button class="reader-btn" id="nightButton" onclick="event.stopPropagation(); toggleNightMode()">
                        <svg id="nightModeIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                        <span id="nightModeText">夜间</span>
                    </button>
                    <button class="reader-btn" id="settingsButton" onclick="event.stopPropagation(); toggleSettings()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                        <span>设置</span>
                    </button>
                </div>
            </div>

            <!-- Settings Panel -->
            <div class="settings-panel settings-bar" id="settingsPanel" onclick="event.stopPropagation()">
                <div class="setting-row">
                    <div class="setting-label">背景颜色</div>
                    <div class="theme-options">
                        <div class="theme-circle theme-white active" onclick="event.stopPropagation(); setReaderTheme('white', this)"></div>
                        <div class="theme-circle theme-sepia" onclick="event.stopPropagation(); setReaderTheme('sepia', this)"></div>
                        <div class="theme-circle theme-green" onclick="event.stopPropagation(); setReaderTheme('green', this)"></div>
                        <div class="theme-circle theme-dark" onclick="event.stopPropagation(); setReaderTheme('dark', this)"></div>
                    </div>
                </div>
                <div class="setting-row">
                    <div class="setting-label">字体大小 <span id="fontSizeDisplay" style="float:right; opacity:0.5;">18</span></div>
                    <div class="slider-container">
                        <span style="font-size:14px;">A-</span>
                        <input type="range" class="slider-control" min="14" max="30" value="18" onclick="event.stopPropagation()" oninput="updateFontSize(this.value)">
                        <span style="font-size:20px;">A+</span>
                    </div>
                </div>
                <div class="setting-row">
                    <div class="setting-label">行间距</div>
                    <div class="slider-container">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 6h16M4 12h16M4 18h16"/></svg>
                        <input type="range" class="slider-control" min="12" max="24" value="18" onclick="event.stopPropagation()" oninput="updateLineHeight(this.value)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 3h16M4 12h16M4 21h16"/></svg>
                    </div>
                </div>
                
            </div>

            <!-- TOC Overlay -->
            <div class="toc-overlay" id="tocOverlay" onclick="event.stopPropagation(); toggleToc()"></div>
            <div class="toc-panel" id="tocPanel" onclick="event.stopPropagation()">
                <div class="toc-header">
                    <div class="toc-title">目录</div>
                    <div class="toc-subtitle">共 12 章</div>
                </div>
                <div class="toc-list" id="tocList">
                    <!-- Populated by JS -->
                </div>
            </div>

        </div>

    </div>

    <script>
        if ('scrollRestoration' in history) {
            try { history.scrollRestoration = 'manual'; } catch (e) {}
        }

        function updateFrameScale() {
            try {
                const isMobile = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
                const scale = isMobile ? 1 : Math.min(1, (window.innerWidth - 40) / 428, (window.innerHeight - 40) / 926);
                document.documentElement.style.setProperty('--frame-scale', String(Math.max(0.25, Number.isFinite(scale) ? scale : 1)));
            } catch (e) {}
        }

        updateFrameScale();
        window.addEventListener('resize', updateFrameScale, { passive: true });

        function updateReaderBottomSheetOffset() {
            try {
                const reader = document.getElementById('readerView');
                if (!reader) return;
                const panel = document.getElementById('settingsPanel');
                const bottomBar = document.querySelector('.reader-bottom-bar');
                const panelActive = !!(panel && panel.classList && panel.classList.contains('active'));
                if (!panelActive) {
                    reader.style.setProperty('--reader-bottom-sheet', '0px');
                    try { invalidateTxtCharsPerPage(); updatePageIndicatorByTxtPos(txtActiveAbsPos); } catch (e) {}
                    return;
                }
                const panelH = panel.getBoundingClientRect ? (panel.getBoundingClientRect().height || 0) : 0;
                const bottomH = bottomBar && bottomBar.getBoundingClientRect ? (bottomBar.getBoundingClientRect().height || 0) : 0;
                const extra = Math.max(0, panelH - bottomH);
                reader.style.setProperty('--reader-bottom-sheet', `${Math.round(extra)}px`);
                try { invalidateTxtCharsPerPage(); updatePageIndicatorByTxtPos(txtActiveAbsPos); } catch (e) {}
            } catch (e) {}
        }

        window.addEventListener('resize', updateReaderBottomSheetOffset, { passive: true });
        window.addEventListener('orientationchange', updateReaderBottomSheetOffset, { passive: true });

        // --- Storage Layer (IndexedDB) ---
        const DB_NAME = 'ReaderAppDB';
        const DB_VERSION = 2;
        const STORES = { BOOKS: 'books', PROGRESS: 'progress' };
        const debugEnabled = new URLSearchParams(location.search).get('debug') === '1' || localStorage.getItem('reader_debug') === '1';
        let debugPanelEl = null;
        let debugPanelContentEl = null;
        let debugPanelTimer = null;
        let debugLines = [];
        let debugEvents = [];
        let bodyScrollLockState = null;

        try {
            document.documentElement.classList.toggle('debug-mode', !!debugEnabled);
        } catch (e) {}

        function shouldShowDebugPanel() {
            try { return localStorage.getItem('reader_debug_panel') !== '0'; } catch (e) { return true; }
        }

        function closeDebugPanel() {
            try { localStorage.setItem('reader_debug_panel', '0'); } catch (e) {}
            try { if (debugPanelTimer) clearInterval(debugPanelTimer); } catch (e) {}
            debugPanelTimer = null;
            try { if (debugPanelEl && debugPanelEl.parentElement) debugPanelEl.parentElement.removeChild(debugPanelEl); } catch (e) {}
            debugPanelEl = null;
            debugPanelContentEl = null;
        }

        function ensureSettingsPanelMountPoint() {
            const el = document.getElementById('settingsPanel');
            const readerView = document.getElementById('readerView');
            if (!el || !readerView) return;
            try {
                if (el.parentElement !== readerView) readerView.appendChild(el);
            } catch (e) {}
        }

        try { ensureSettingsPanelMountPoint(); } catch (e) {}

        function toggleReaderDebug() {
            const next = localStorage.getItem('reader_debug') === '1' ? '0' : '1';
            localStorage.setItem('reader_debug', next);
            location.reload();
        }

        function debugLog(event, payload = null) {
            if (!debugEnabled) return;
            try {
                console.log('[reader-debug]', event, payload || '');
            } catch (e) {}
            try {
                const time = new Date().toISOString().slice(11, 19);
                const line = payload ? `${time} ${event} ${JSON.stringify(payload)}` : `${time} ${event}`;
                debugLines.push(line);
                if (debugLines.length > 200) debugLines.shift();
                debugEvents.push({ time, event, payload });
                if (debugEvents.length > 200) debugEvents.shift();
            } catch (e) {}
        }

        function formatDebugPanelText() {
            const contentArea = document.getElementById('readerContent');
            const docEl = document.scrollingElement;
            const lastTxt = typeof lastTxtProgress !== 'undefined' ? lastTxtProgress : null;
            const readerView = document.getElementById('readerView');
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const filtered = debugEvents.filter(e => {
                const ev = e.event || '';
                return (
                    ev.startsWith('txt open:') ||
                    ev === 'saveTxtProgressFromView' ||
                    ev === 'saveProgress' ||
                    ev.startsWith('skip saveProgress') ||
                    ev.startsWith('closeBook') ||
                    ev.startsWith('ui:') ||
                    ev.startsWith('openBookFromId wait close') ||
                    ev.startsWith('openBookFromId wait close')
                );
            }).slice(-60);

            const snap = {
                bookId: typeof currentBookId !== 'undefined' ? currentBookId : null,
                isRestoringTxt: typeof isRestoringTxt !== 'undefined' ? isRestoringTxt : null,
                isClosingReader: typeof isClosingReader !== 'undefined' ? isClosingReader : null,
                ui: {
                    readerView: readerView ? readerView.className : null,
                    tocPanel: tocPanel ? tocPanel.className : null,
                    tocOverlay: tocOverlay ? tocOverlay.className : null,
                    settingsPanel: settingsPanel ? settingsPanel.className : null,
                    moreMenu: moreMenu ? moreMenu.className : null
                },
                content: contentArea ? {
                    top: contentArea.scrollTop,
                    h: contentArea.scrollHeight,
                    ch: contentArea.clientHeight,
                    chunkStart: parseInt(contentArea.getAttribute('data-chunk-start') || '0'),
                    loadedLength: parseInt(contentArea.getAttribute('data-render-length') || '0'),
                    nextStart: contentArea.getAttribute('data-next-start')
                } : null,
                doc: docEl ? { top: docEl.scrollTop } : null,
                lastTxt: lastTxt ? {
                    absolutePos: lastTxt.absolutePos,
                    percent: lastTxt.percent,
                    chunkStart: lastTxt.chunkStart,
                    scrollTop: lastTxt.scrollTop,
                    scrollRatio: lastTxt.scrollRatio,
                    ratio: lastTxt.ratio,
                    loadedLength: lastTxt.loadedLength
                } : null
            };

            const lines = filtered.map(e => {
                if (e.payload === null || e.payload === undefined) return `${e.time} ${e.event}`;
                return `${e.time} ${e.event} ${JSON.stringify(e.payload)}`;
            });
            return JSON.stringify(snap, null, 2) + '\n\n' + lines.join('\n');
        }

        function ensureDebugPanel() {
            if (!debugEnabled || !shouldShowDebugPanel() || debugPanelEl) return;
            const wrap = document.createElement('div');
            wrap.style.position = 'fixed';
            wrap.style.left = '8px';
            wrap.style.right = '8px';
            wrap.style.bottom = '8px';
            wrap.style.maxHeight = '45vh';
            wrap.style.overflow = 'hidden';
            wrap.style.zIndex = '9999';
            wrap.style.background = 'rgba(0,0,0,0.75)';
            wrap.style.color = '#fff';
            wrap.style.borderRadius = '10px';
            wrap.style.fontSize = '12px';
            wrap.style.pointerEvents = 'auto';
            wrap.style.display = 'flex';
            wrap.style.flexDirection = 'column';

            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.padding = '8px 10px';
            header.style.borderBottom = '1px solid rgba(255,255,255,0.12)';
            header.style.userSelect = 'none';

            const title = document.createElement('div');
            title.textContent = 'Debug';
            title.style.opacity = '0.85';
            title.style.fontWeight = '600';

            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.textContent = '关闭';
            closeBtn.style.border = '1px solid rgba(255,255,255,0.25)';
            closeBtn.style.background = 'transparent';
            closeBtn.style.color = '#fff';
            closeBtn.style.borderRadius = '8px';
            closeBtn.style.padding = '4px 10px';
            closeBtn.style.fontSize = '12px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.onclick = (e) => { try { e.stopPropagation(); } catch (err) {} closeDebugPanel(); };

            header.appendChild(title);
            header.appendChild(closeBtn);

            const pre = document.createElement('pre');
            pre.style.margin = '0';
            pre.style.padding = '10px';
            pre.style.flex = '1';
            pre.style.overflow = 'auto';
            pre.style.whiteSpace = 'pre-wrap';
            pre.style.userSelect = 'text';
            pre.style.webkitUserSelect = 'text';

            wrap.appendChild(header);
            wrap.appendChild(pre);
            document.body.appendChild(wrap);
            debugPanelEl = wrap;
            debugPanelContentEl = pre;
            debugLog('debug enabled');
            window.addEventListener('error', (e) => {
                debugLog('ui:error', { message: e.message, filename: e.filename, lineno: e.lineno, colno: e.colno, stack: e.error && e.error.stack ? String(e.error.stack) : null });
            });
            window.addEventListener('unhandledrejection', (e) => {
                const reason = e && e.reason;
                debugLog('ui:unhandledrejection', { reason: reason && reason.stack ? String(reason.stack) : String(reason) });
            });
            debugPanelTimer = setInterval(() => {
                if (!debugPanelContentEl) return;
                debugPanelContentEl.textContent = formatDebugPanelText();
            }, 350);
        }

        function lockBodyScroll(lock) {
            if (lock) {
                if (bodyScrollLockState) return;
                const scrollY = window.scrollY || 0;
                bodyScrollLockState = {
                    scrollY,
                    overflow: document.body.style.overflow,
                    position: document.body.style.position,
                    top: document.body.style.top,
                    left: document.body.style.left,
                    right: document.body.style.right,
                    width: document.body.style.width
                };
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.top = `-${scrollY}px`;
                document.body.style.left = '0';
                document.body.style.right = '0';
                document.body.style.width = '100%';
            } else {
                if (!bodyScrollLockState) return;
                const { scrollY, overflow, position, top, left, right, width } = bodyScrollLockState;
                document.body.style.overflow = overflow;
                document.body.style.position = position;
                document.body.style.top = top;
                document.body.style.left = left;
                document.body.style.right = right;
                document.body.style.width = width;
                bodyScrollLockState = null;
                window.scrollTo(0, scrollY);
            }
        }

        class StorageManager {
            constructor() { this.dbPromise = this.initDB(); }
            progressKey(bookId) { return `reader_progress_${bookId}`; }
            legacyProgressKey(bookId) { return `reader_progress_cache_${bookId}`; }
            initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (e.oldVersion < 2) {
                            if (db.objectStoreNames.contains(STORES.PROGRESS)) db.deleteObjectStore(STORES.PROGRESS);
                        }
                        if (!db.objectStoreNames.contains(STORES.BOOKS)) db.createObjectStore(STORES.BOOKS, { keyPath: 'id' });
                        if (!db.objectStoreNames.contains(STORES.PROGRESS)) db.createObjectStore(STORES.PROGRESS, { keyPath: 'bookId' });
                    };
                    request.onsuccess = (e) => resolve(e.target.result);
                    request.onerror = (e) => reject(e.target.error);
                });
            }
            async getDB() { return this.dbPromise; }
            async addBook(book) {
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.BOOKS, 'readwrite');
                    tx.objectStore(STORES.BOOKS).put(book);
                    tx.oncomplete = () => resolve();
                });
            }
            async getAllBooks() {
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.BOOKS, 'readonly');
                    const request = tx.objectStore(STORES.BOOKS).getAll();
                    request.onsuccess = () => resolve(request.result.sort((a, b) => b.addedDate - a.addedDate));
                });
            }
            async getBook(id) {
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.BOOKS, 'readonly');
                    const request = tx.objectStore(STORES.BOOKS).get(id);
                    request.onsuccess = () => resolve(request.result);
                });
            }
            async deleteBook(id) {
                try {
                    localStorage.removeItem(this.progressKey(id));
                    localStorage.removeItem(this.legacyProgressKey(id));
                } catch (e) {}
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction([STORES.BOOKS, STORES.PROGRESS], 'readwrite');
                    tx.objectStore(STORES.BOOKS).delete(id);
                    tx.objectStore(STORES.PROGRESS).delete(id);
                    tx.oncomplete = () => resolve();
                });
            }
            async saveProgress(bookId, cfi, percentage, scrollTop = 0, chunkStart = null, extra = null) {
                debugLog('saveProgress', { bookId, cfi, percentage, scrollTop, chunkStart, extra });
                const isTxt = extra && extra.kind === 'txt';
                const newPos = isTxt ? parseInt(cfi) : NaN;
                if (isTxt && Number.isFinite(newPos)) {
                    try {
                        const raw = localStorage.getItem(this.progressKey(bookId)) || localStorage.getItem(this.legacyProgressKey(bookId));
                        const prev = raw ? JSON.parse(raw) : null;
                        const prevPos = prev && prev.cfi !== undefined && prev.cfi !== null ? parseInt(prev.cfi) : NaN;
                        const guardClose = extra && extra.reason === 'close' && !!extra.nearEdge;
                        if (guardClose && Number.isFinite(prevPos) && prevPos > newPos + 5000) {
                            debugLog('skip saveProgress (rollback guard)', { bookId, prevPos, newPos, scrollTop });
                            return;
                        }
                    } catch (e) {}
                }
                try {
                    localStorage.setItem(this.progressKey(bookId), JSON.stringify({ bookId, cfi, percentage, scrollTop, chunkStart, timestamp: Date.now(), ...(extra || {}) }));
                    try { localStorage.removeItem(this.legacyProgressKey(bookId)); } catch (e) {}
                } catch (e) {}
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.PROGRESS, 'readwrite');
                    tx.objectStore(STORES.PROGRESS).put({ bookId, cfi, percentage, scrollTop, chunkStart, timestamp: Date.now(), ...(extra || {}) });
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => resolve();
                });
            }
            async getProgress(bookId) {
                const db = await this.getDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORES.PROGRESS, 'readonly');
                    const request = tx.objectStore(STORES.PROGRESS).get(bookId);
                    request.onsuccess = () => {
                        let cachedNew = null;
                        let cachedLegacy = null;
                        try {
                            const rawNew = localStorage.getItem(this.progressKey(bookId));
                            cachedNew = rawNew ? JSON.parse(rawNew) : null;
                            const rawLegacy = localStorage.getItem(this.legacyProgressKey(bookId));
                            cachedLegacy = rawLegacy ? JSON.parse(rawLegacy) : null;
                        } catch (e) {}
                        const newTs = cachedNew && cachedNew.timestamp ? Number(cachedNew.timestamp) : 0;
                        const legacyTs = cachedLegacy && cachedLegacy.timestamp ? Number(cachedLegacy.timestamp) : 0;
                        const cached = (cachedNew && cachedLegacy) ? (newTs >= legacyTs ? cachedNew : cachedLegacy) : (cachedNew || cachedLegacy || null);

                        const idb = request.result || null;
                        const idbTs = idb && idb.timestamp ? Number(idb.timestamp) : 0;
                        const cacheTs = cached && cached.timestamp ? Number(cached.timestamp) : 0;

                        const result = (idb && cached) ? (idbTs >= cacheTs ? idb : cached) : (idb || cached || null);
                        debugLog('getProgress', { bookId, hasIdb: !!idb, hasCache: !!cached, idbTs, cacheTs, result });
                        resolve(result);
                    };
                    request.onerror = () => {
                        try {
                            const raw = localStorage.getItem(this.progressKey(bookId)) || localStorage.getItem(this.legacyProgressKey(bookId));
                            const fallback = raw ? JSON.parse(raw) : null;
                            debugLog('getProgress error', { bookId, fallback });
                            resolve(fallback);
                        } catch (e) {
                            debugLog('getProgress error', { bookId, fallback: null });
                            resolve(null);
                        }
                    };
                });
            }
        }
        const storage = new StorageManager();
        if (debugEnabled) ensureDebugPanel();
        window.addEventListener('pagehide', () => {
            isClosingReader = true;
            saveTxtProgressFromView('close');
            saveEpubProgressFromView('close');
        });
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                isClosingReader = true;
                saveTxtProgressFromView('close');
                saveEpubProgressFromView('close');
            } else {
                isClosingReader = false;
            }
        });

        // --- Tabs Logic ---
        function switchTab(tabName) {
            // Hide all views
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active', 'hidden'));
            document.querySelectorAll('.view-section').forEach(el => {
                if(el.id !== 'view-' + tabName) el.classList.add('hidden');
            });
            
            // Show target view
            document.getElementById('view-' + tabName).classList.add('active');
            
            // Update Tab Bar
            document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('active'));
            document.getElementById('tab-' + tabName).classList.add('active');
        }

        // --- Import Logic ---
        function triggerImport() {
            document.getElementById('fileInput').click();
        }
        
        document.getElementById('fileInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const ext = file.name.split('.').pop().toLowerCase();
            const bookId = 'book_' + Date.now();
            let bookData = {
                id: bookId,
                title: file.name.replace(/\.[^/.]+$/, ""),
                author: '未知作者',
                cover: '',
                fileBlob: file,
                addedDate: Date.now(),
                format: ext.toUpperCase()
            };

            if (ext === 'epub') {
                try {
                    const book = ePub(file);
                    const metadata = await book.loaded.metadata;
                    bookData.title = metadata.title;
                    bookData.author = metadata.creator;
                    
                    const coverUrl = await book.coverUrl();
                    if (coverUrl) {
                        // Convert cover to data URL for persistent storage
                        const resp = await fetch(coverUrl);
                        const blob = await resp.blob();
                        bookData.cover = await new Promise(r => {
                            const reader = new FileReader();
                            reader.onload = () => r(reader.result);
                            reader.readAsDataURL(blob);
                        });
                    }
                } catch (err) {
                    console.error('EPUB parse error:', err);
                }
            }

            await storage.addBook(bookData);
            renderBookshelf();
        });

        async function renderBookshelf() {
             const books = await storage.getAllBooks();
             const container = document.getElementById('booksContainer');
             
             if (books.length === 0) {
                 container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-tertiary);">书架空空如也，点击上方“导入”开始阅读</div>';
                 return;
             }

             const isGridView = container.classList.contains('grid-view');
             
             const bookItems = await Promise.all(books.map(async (book) => {
                 const progressData = await storage.getProgress(book.id);
                 const progress = progressData
                    ? (
                        Number.isFinite(Number(progressData.percentage)) ? Number(progressData.percentage)
                        : (progressData.ratio !== undefined && progressData.ratio !== null ? Math.max(1, Math.round(parseFloat(progressData.ratio) * 100)) : 0)
                    )
                    : 0;
                 return `
                     <div class="book-card" onclick="openBookFromId('${book.id}')">
                         ${book.cover 
                             ? `<div class="book-cover" style="background-image: url('${book.cover}')"></div>`
                             : `<div class="book-cover dynamic-cover cover-${(book.title.length % 3) + 1}"><div class="cover-text">${book.title}</div></div>`
                         }
                         <div class="book-info">
                             <div class="book-title">${book.title}</div>
                             <div class="book-meta"><span>${book.author}</span><span class="format-badge">${book.format}</span></div>
                             <div class="progress-container">
                                 <div class="progress-track"><div class="progress-fill" style="width: ${progress}%;"></div></div>
                                 <span class="progress-text">${progress}%</span>
                             </div>
                             <div class="book-stats">
                                 <span>${(book.fileBlob.size / 1024 / 1024).toFixed(2)} MB</span>
                                 <button class="edit-btn" onclick="event.stopPropagation(); deleteBook('${book.id}')">删除</button>
                             </div>
                         </div>
                     </div>
                 `;
             }));
             
             container.innerHTML = bookItems.join('');
         }

        async function deleteBook(id) {
            if (confirm('确定要删除这本书吗？')) {
                await storage.deleteBook(id);
                renderBookshelf();
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            renderBookshelf();
            updateAppleTouchIcon();
        });

        async function updateAppleTouchIcon() {
            const link = document.getElementById('appleTouchIcon');
            const pre = document.getElementById('appleTouchIconPre');
            if (!link && !pre) return;
            try {
                if (link) {
                    link.setAttribute('sizes', '180x180');
                    link.setAttribute('href', './icon/mozi_icon_180.png?v=2');
                }
                if (pre) {
                    pre.setAttribute('sizes', '180x180');
                    pre.setAttribute('href', './icon/mozi_icon_180.png?v=2');
                }
            } catch (e) {}
        }

        window.addEventListener('pagehide', async () => {
            if (document.getElementById('readerView').classList.contains('active')) {
                await saveTxtProgressFromView();
                await saveEpubProgressFromView();
            }
        });

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'hidden' && document.getElementById('readerView').classList.contains('active')) {
                await saveTxtProgressFromView();
                await saveEpubProgressFromView();
            }
        });

        // --- Search Logic (Google Books API) ---
        async function handleSearch(event) {
            if (event.key === 'Enter') {
                const query = event.target.value;
                if (!query) return;
                
                const resultsContainer = document.getElementById('searchResults');
                resultsContainer.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:20px; color:var(--text-secondary);">搜索中...</div>';
                
                try {
                    const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=9`);
                    const data = await response.json();
                    
                    if (data.items && data.items.length > 0) {
                        resultsContainer.innerHTML = '';
                        data.items.forEach(item => {
                            const info = item.volumeInfo;
                            const cover = info.imageLinks ? (info.imageLinks.thumbnail || info.imageLinks.smallThumbnail) : '';
                            const title = info.title || '无标题';
                            const authors = info.authors ? info.authors.join(', ') : '未知作者';
                            
                            const html = `
                                <div class="search-item" onclick="addBookFromSearch('${title.replace(/'/g, "\\'")}', '${authors.replace(/'/g, "\\'")}', '${cover}')">
                                    <div class="search-cover" style="background-image: url('${cover}'); ${!cover ? 'background-color:#333;' : ''}"></div>
                                    <div class="search-title">${title}</div>
                                    <div class="search-author">${authors}</div>
                                </div>
                            `;
                            resultsContainer.innerHTML += html;
                        });
                    } else {
                        resultsContainer.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:20px; color:var(--text-secondary);">未找到相关书籍</div>';
                    }
                } catch (e) {
                    console.error(e);
                    resultsContainer.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:20px; color:var(--text-secondary);">网络错误，请检查连接</div>';
                }
            }
        }
        
        function addBookFromSearch(title, author, coverUrl) {
            if(confirm(`要把《${title}》加入书架吗？`)) {
                const newBookHTML = `
                    <div class="book-card" onclick="openBook(this)">
                        <div class="book-cover" style="background-image: url('${coverUrl}'); background-size: cover; background-position: center;">
                            <div class="reading-dot"></div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">${title}</div>
                            <div class="book-meta"><span>${author}</span><span class="format-badge">网络</span></div>
                            <div class="progress-container">
                                <div class="progress-track"><div class="progress-fill" style="width: 0%;"></div></div>
                                <span class="progress-text">0%</span>
                            </div>
                            <div class="book-stats"><span>未知字数</span><button class="edit-btn" onclick="event.stopPropagation(); editBook(this)">编辑</button></div>
                        </div>
                    </div>
                `;
                document.getElementById('booksContainer').insertAdjacentHTML('afterbegin', newBookHTML);
                switchTab('bookshelf');
            }
        }

        // --- View Toggle Logic ---
        function toggleView() {
            const container = document.getElementById('booksContainer');
            const btn = document.getElementById('toggleBtn');
            const icon = btn.querySelector('svg');
            container.classList.toggle('grid-view');
            if (container.classList.contains('grid-view')) {
                icon.innerHTML = '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>';
            } else {
                icon.innerHTML = '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>';
            }
        }

        // --- Edit Modal Logic ---
        let currentEditingBook = null;
        function editBook(btn) {
            const card = btn.closest('.book-card');
            const titleEl = card.querySelector('.book-title');
            currentEditingBook = titleEl;
            document.getElementById('bookTitleInput').value = titleEl.innerText;
            document.getElementById('editModal').classList.add('active');
        }
        function closeModal() { document.getElementById('editModal').classList.remove('active'); currentEditingBook = null; }
        function saveBookTitle() {
            if (currentEditingBook) currentEditingBook.innerText = document.getElementById('bookTitleInput').value.trim();
            closeModal();
        }

        // --- Content Generator ---
        function generateChapter(title, index) {
            const paragraphs = [
                "那个年代，人们的心中充满了理想主义的火焰。叶文洁站在雷达峰顶，看着夕阳下的红岸基地，心中涌起一股难以言喻的复杂情感。",
                "天线巨大的抛物面在余晖中闪烁着冷冽的金属光泽，仿佛一只巨大的耳朵，倾听着宇宙深处的秘密。风从群山间呼啸而过，带来了远方森林的气息。",
                "这段信息穿越了数光年的距离，最终抵达了这颗蓝色的星球。命运的齿轮，在这一刻悄然转动。谁也没有想到，这短短的一句话，竟然改变了人类文明的进程。",
                "物理学不存在了。这是一个极其荒谬的结论，但在这个疯狂的年代，似乎没有什么是不可能的。汪淼看着眼前的倒计时，感到一种前所未有的恐惧。",
                "在那一瞬间，他仿佛看到了宇宙的终极真理，那是一种超越人类理解的宏大与冷漠。星空闪烁，仿佛无数双眼睛在注视着这颗微不足道的尘埃。",
                "生活依然在继续，但每个人都知道，一切都已经改变了。那种潜藏在平静表面下的危机感，像瘟疫一样蔓延开来。",
                "智子无处不在。它们监视着人类的一举一动，封锁了人类的基础科学。人类就像被困在玻璃罩里的虫子，无论如何挣扎，都无法逃脱命运的安排。",
                "然而，虫子从来没有被真正战胜过。史强吐出一口烟圈，脸上露出了那标志性的痞气笑容。既然我们是虫子，那就要像虫子一样活着，顽强地活着。"
            ];
            
            let content = `<h2 id="chap-${index}" style="margin: 40px 0 20px 0; font-weight:bold; color:var(--reader-text);">${title}</h2>`;
            for(let i=0; i<15; i++) {
                // Randomly select paragraphs to create length
                const p = paragraphs[Math.floor(Math.random() * paragraphs.length)];
                content += `<p style="margin-bottom:16px; text-align:justify;">${p}</p>`;
            }
            return content;
        }

        function setFlipMode(mode) {
            let nextMode = mode;
            nextMode = 'scroll';
            currentFlipMode = nextMode;
            try { localStorage.setItem('reader_flip_mode_last', String(currentFlipMode)); } catch (e) {}
            try { invalidateTxtCharsPerPage(); } catch (e) {}
            // Update UI
            document.querySelectorAll('.flip-option').forEach(el => el.classList.remove('active'));
            const opt = document.getElementById('opt-' + nextMode);
            if (opt) opt.classList.add('active');
            try {
                const indicator = document.getElementById('flipModeIndicator');
                if (indicator) {
                    const idx = nextMode === 'scroll' ? 0 : 1;
                    indicator.style.transform = `translateX(${idx * 100}%)`;
                }
            } catch (e) {}
            // Apply logic
            const contentArea = document.getElementById('readerContent');
            const readerView = document.getElementById('readerView');
            contentArea.classList.add('mode-scroll');
            contentArea.classList.remove('mode-slide');
            contentArea.classList.remove('mode-sim');
            readerView.classList.remove('flip-slide');
            destroyTxtPagedView(Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : null);
            if (contentArea.scrollLeft) contentArea.scrollLeft = 0;
            schedulePersistTxtAnchorProgress('auto');
        }

        let menuPinned = false;
        let txtPagedMode = null;
        let txtPagedPages = [];
        let txtPagedPageAbs = [];
        let txtPagedChunkStart = 0;
        let txtPagedIndex = 0;
        let txtPagedTurnLock = false;
        let txtPagedScrollTimer = null;
        let txtPagedScrollRaf = null;
        let txtMeasureCanvas = null;

        function getTxtAvgCharWidth(cs) {
            try {
                if (!txtMeasureCanvas) txtMeasureCanvas = document.createElement('canvas');
                const ctx = txtMeasureCanvas.getContext('2d');
                if (!ctx) return (parseFloat(cs.fontSize || '18') || 18) * 0.56;
                const font = cs.font || `${cs.fontWeight || '400'} ${cs.fontSize || '18px'} ${cs.fontFamily || 'serif'}`;
                ctx.font = font;
                const w1 = ctx.measureText('汉').width || 0;
                const w2 = ctx.measureText('M').width || 0;
                const avg = (w1 > 0 && w2 > 0) ? ((w1 + w2) / 2) : (w1 || w2);
                const fallback = (parseFloat(cs.fontSize || '18') || 18) * 0.56;
                return avg > 0 ? avg : fallback;
            } catch (e) {
                return (parseFloat(cs.fontSize || '18') || 18) * 0.56;
            }
        }

        function paginateTxtChunk(chunk, startPos, cs, contentArea, linesPerPage) {
            const pagePaddingX = 48;
            const usableWidth = Math.max(220, (contentArea.clientWidth || 360) - pagePaddingX);
            const avgCharWidth = getTxtAvgCharWidth(cs);
            const charsPerLine = Math.max(10, Math.floor(usableWidth / Math.max(6, avgCharWidth)));
            const charsPerPage = Math.max(200, charsPerLine * Math.max(6, linesPerPage));
            const pages = [];
            const pageAbs = [];
            const breakChars = new Set(['\n', '。', '！', '？', '.', '!', '?', '；', ';', '，', ',', '、', ' ', '\t']);
            let offset = 0;
            while (offset < chunk.length) {
                const abs = startPos + offset;
                const end = Math.min(chunk.length, offset + charsPerPage);
                const windowText = chunk.slice(offset, end);
                const lookBack = Math.max(40, Math.floor(charsPerPage * 0.22));
                let cut = windowText.length;
                for (let i = windowText.length - 1; i >= 0 && i >= windowText.length - lookBack; i--) {
                    const c = windowText[i];
                    if (breakChars.has(c)) { cut = i + 1; break; }
                }
                if (cut <= 0) cut = windowText.length;
                const pageText = chunk.slice(offset, offset + cut);
                pages.push(`<div class="paged-text" data-abs="${abs}">${escapeHtml(pageText)}</div>`);
                pageAbs.push(abs);
                offset += cut;
            }
            return { pages, pageAbs };
        }

        function buildTxtPagedView(mode, absHint = null) {
            if (!currentBookId || !currentTxtContent) return;
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            txtPagedMode = mode;
            const CHUNK_SIZE = 15000;
            const startPos = Math.max(0, parseInt(contentArea.getAttribute('data-chunk-start') || '0', 10) || 0);
            const chunk = currentTxtContent.slice(startPos, startPos + CHUNK_SIZE);
            const cs = window.getComputedStyle(contentArea);
            const fontSize = parseFloat(cs.fontSize || '18') || 18;
            const lineHeightPx = cs.lineHeight === 'normal' ? (fontSize * 1.6) : (parseFloat(cs.lineHeight) || fontSize * 1.6);
            const rootCs = window.getComputedStyle(document.documentElement);
            const safeTop = parseFloat(rootCs.getPropertyValue('--safe-top') || '0') || 0;
            const safeBottom = parseFloat(rootCs.getPropertyValue('--safe-bottom') || '0') || 0;
            const reader = document.getElementById('readerView');
            const bottomSheet = reader ? (parseFloat(window.getComputedStyle(reader).getPropertyValue('--reader-bottom-sheet') || '0') || 0) : 0;
            const padT = 56 + safeTop + 18;
            const padB = 82 + safeBottom + 18 + bottomSheet;
            const usableHeight = Math.max(200, (contentArea.clientHeight || 600) - padT - padB);
            const linesPerPage = Math.max(6, Math.floor(usableHeight / lineHeightPx));
            const paged = paginateTxtChunk(chunk, startPos, cs, contentArea, linesPerPage);
            txtPagedPages = paged.pages;
            txtPagedPageAbs = paged.pageAbs;
            txtPagedChunkStart = startPos;
            let targetAbs = absHint;
            if (!Number.isFinite(targetAbs)) targetAbs = Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : startPos;
            let idx = 0;
            for (let lo = 0, hi = txtPagedPageAbs.length - 1; lo <= hi;) {
                const mid = (lo + hi) >> 1;
                if ((txtPagedPageAbs[mid] || 0) <= targetAbs) { idx = mid; lo = mid + 1; }
                else hi = mid - 1;
            }
            txtPagedIndex = Math.max(0, Math.min(txtPagedPages.length - 1, idx));
            contentArea.innerHTML = '';
            if (mode === 'simulation') {
                contentArea.onscroll = null;
                contentArea.classList.add('mode-sim');
                contentArea.classList.remove('mode-slide');
                const surface = document.createElement('div');
                surface.className = 'sim-surface';
                const cur = document.createElement('div');
                cur.className = 'sim-current';
                const next = document.createElement('div');
                next.className = 'sim-next';
                cur.innerHTML = `<div class="paged-page">${txtPagedPages[txtPagedIndex] || ''}</div>`;
                next.innerHTML = '';
                surface.appendChild(next);
                surface.appendChild(cur);
                contentArea.appendChild(surface);
                setTxtActiveFromPagedIndex();
                schedulePersistTxtAnchorProgress('auto');
                return;
            }
            contentArea.classList.add('mode-slide');
            contentArea.classList.remove('mode-sim');
            for (let p = 0; p < txtPagedPages.length; p++) {
                const page = document.createElement('div');
                page.className = 'paged-page';
                page.setAttribute('data-page-index', String(p));
                page.innerHTML = txtPagedPages[p];
                contentArea.appendChild(page);
            }
            const pageWidth = contentArea.clientWidth || 1;
            contentArea.scrollLeft = txtPagedIndex * pageWidth;
            setTxtActiveFromPagedIndex();
            schedulePersistTxtAnchorProgress('auto');
            if (txtPagedScrollTimer) {
                clearTimeout(txtPagedScrollTimer);
                txtPagedScrollTimer = null;
            }
            contentArea.onscroll = () => {
                if (currentFlipMode !== 'slide') return;
                if (txtPagedScrollRaf) return;
                txtPagedScrollRaf = requestAnimationFrame(() => {
                    txtPagedScrollRaf = null;
                    if (currentFlipMode !== 'slide') return;
                    const w = contentArea.clientWidth || 1;
                    const nextIdx = Math.max(0, Math.min(txtPagedPages.length - 1, Math.round((contentArea.scrollLeft || 0) / w)));
                    if (nextIdx === txtPagedIndex) return;
                    txtPagedIndex = nextIdx;
                    setTxtActiveFromPagedIndex();
                    schedulePersistTxtAnchorProgress('auto');
                });
            };
        }

        function destroyTxtPagedView(absHint = null) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            if (!txtPagedMode) return;
            if (txtPagedScrollRaf) {
                try { cancelAnimationFrame(txtPagedScrollRaf); } catch (e) {}
                txtPagedScrollRaf = null;
            }
            const startPos = Math.max(0, parseInt(contentArea.getAttribute('data-chunk-start') || '0', 10) || 0);
            renderTxtChunk(startPos);
            contentArea.onscroll = null;
            txtPagedMode = null;
            txtPagedPages = [];
            txtPagedPageAbs = [];
            txtPagedChunkStart = 0;
            txtPagedIndex = 0;
            const abs = Number.isFinite(absHint) ? absHint : txtActiveAbsPos;
            if (Number.isFinite(abs)) {
                setTimeout(() => {
                    const ps = Array.from(contentArea.querySelectorAll('p[data-abs]'));
                    let target = null;
                    for (const p of ps) {
                        const a = parseInt(p.getAttribute('data-abs') || 'NaN', 10);
                        if (!Number.isFinite(a)) continue;
                        if (a <= abs) target = p;
                        else break;
                    }
                    if (!target && ps.length > 0) target = ps[0];
                    if (target) scrollParagraphIntoView(target);
                }, 0);
            }
        }

        function setTxtActiveFromPagedIndex() {
            if (!txtPagedPageAbs || txtPagedPageAbs.length === 0) return;
            const abs = txtPagedPageAbs[Math.max(0, Math.min(txtPagedPageAbs.length - 1, txtPagedIndex))];
            if (!Number.isFinite(abs)) return;
            txtActiveAbsPos = abs;
            txtActiveAnchorId = txtAnchorIdForAbsPos(currentBookId, abs);
            updateActiveTxtTocByPos(abs);
        }

        function turnTxtPaged(direction) {
            if (txtPagedTurnLock) return;
            if (!currentBookId || !currentTxtContent) return;
            if (currentFlipMode !== 'slide' && currentFlipMode !== 'simulation') return;
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            const CHUNK_SIZE = 15000;
            const nextIndex = txtPagedIndex + (direction > 0 ? 1 : -1);
            if (nextIndex < 0) {
                const prevStart = Math.max(0, txtPagedChunkStart - CHUNK_SIZE);
                if (prevStart === txtPagedChunkStart) return;
                contentArea.setAttribute('data-chunk-start', String(prevStart));
                contentArea.setAttribute('data-render-length', String(Math.min(CHUNK_SIZE, currentTxtContent.length - prevStart)));
                if (prevStart + CHUNK_SIZE < currentTxtContent.length) contentArea.setAttribute('data-next-start', String(prevStart + CHUNK_SIZE));
                else contentArea.removeAttribute('data-next-start');
                buildTxtPagedView(currentFlipMode, prevStart + CHUNK_SIZE - 1);
                return;
            }
            if (nextIndex >= txtPagedPages.length) {
                const nextStart = txtPagedChunkStart + CHUNK_SIZE;
                if (nextStart >= currentTxtContent.length) return;
                contentArea.setAttribute('data-chunk-start', String(nextStart));
                contentArea.setAttribute('data-render-length', String(Math.min(CHUNK_SIZE, currentTxtContent.length - nextStart)));
                if (nextStart + CHUNK_SIZE < currentTxtContent.length) contentArea.setAttribute('data-next-start', String(nextStart + CHUNK_SIZE));
                else contentArea.removeAttribute('data-next-start');
                buildTxtPagedView(currentFlipMode, nextStart);
                return;
            }
            if (currentFlipMode === 'slide') {
                const w = contentArea.clientWidth || 1;
                txtPagedIndex = nextIndex;
                contentArea.scrollTo({ left: w * nextIndex, behavior: 'smooth' });
                setTimeout(() => {
                    setTxtActiveFromPagedIndex();
                    schedulePersistTxtAnchorProgress('auto');
                }, 180);
                return;
            }
            const surface = contentArea.querySelector('.sim-surface');
            if (!surface) return;
            const cur = surface.querySelector('.sim-current');
            const next = surface.querySelector('.sim-next');
            if (!cur || !next) return;
            txtPagedTurnLock = true;
            next.innerHTML = `<div class="paged-page">${txtPagedPages[nextIndex] || ''}</div>`;
            const turn = document.createElement('div');
            turn.className = 'sim-turn';
            const pageHtml = cur.innerHTML || '';
            const safePageHtml = pageHtml.replace(/\sid="txt-[^"]+"/g, '');
            const forward = direction > 0;
            turn.classList.add(forward ? 'turn-forward' : 'turn-backward');
            turn.innerHTML = `<div class="sim-sheet"><div class="sim-front">${safePageHtml}</div><div class="sim-back">${safePageHtml}</div><div class="sim-shadow"></div></div>`;
            turn.style.transformOrigin = forward ? 'left center' : 'right center';
            turn.style.transform = 'rotateY(0deg)';
            surface.appendChild(turn);
            cur.style.opacity = '0';
            requestAnimationFrame(() => {
                turn.style.transition = 'transform 620ms cubic-bezier(0.2, 0.8, 0.2, 1)';
                turn.style.transform = forward ? 'rotateY(-180deg)' : 'rotateY(180deg)';
            });
            setTimeout(() => {
                txtPagedIndex = nextIndex;
                cur.innerHTML = next.innerHTML;
                cur.style.opacity = '1';
                next.innerHTML = '';
                if (turn.parentElement) turn.parentElement.removeChild(turn);
                txtPagedTurnLock = false;
                setTxtActiveFromPagedIndex();
                schedulePersistTxtAnchorProgress('auto');
            }, 680);
        }

        // --- TXT Processing Logic ---
        
        async function parseTxt(fileBlob) {
            // Detect encoding by reading first 1KB
            const chunk = fileBlob.slice(0, 1024);
            const buffer = await chunk.arrayBuffer();
            const decoder = new TextDecoder('utf-8', {fatal: true});
            let encoding = 'utf-8';
            try {
                decoder.decode(buffer);
            } catch(e) {
                encoding = 'gbk'; // Fallback to GBK for Chinese content
            }
            console.log('Detected encoding:', encoding);
            
            // Read full content with detected encoding
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsText(fileBlob, encoding);
            });
        }
        
        function parseTxtToc(content) {
            const toc = [];
            const MAX_TOC = 10000;
            const isRoman = (s) => /^[IVXLCDM]+$/i.test(s);
            const patterns = [
                /^\s*[【\[\(（《「『]*\s*(第[零一二三四五六七八九十百千两0-9]{1,8}\s*[章回卷节篇部])\s*[:：、.\-— ]*\s*([^\r\n]{0,60})/i,
                /^\s*[【\[\(（《「『]*\s*([Cc]hapter\s*\d{1,6})\s*[:：、.\-— ]*\s*([^\r\n]{0,60})/,
                /^\s*[【\[\(（《「『]*\s*([Pp]art\s*\d{1,6})\s*[:：、.\-— ]*\s*([^\r\n]{0,60})/,
                /^\s*[【\[\(（《「『]*\s*([IVXLCDM]{1,12})\s*[.\-— ]\s*([^\r\n]{0,60})/
            ];

            let i = 0;
            while (i <= content.length) {
                let lineEnd = content.indexOf('\n', i);
                if (lineEnd === -1) lineEnd = content.length;
                const rawLine = content.slice(i, lineEnd);
                const line = rawLine.replace(/\r$/, '');
                const trimmed = line.trim();
                if (trimmed) {
                    for (const re of patterns) {
                        const m = re.exec(line);
                        if (!m) continue;
                        const marker = String(m[1] || '').trim();
                        if (re === patterns[3] && !isRoman(marker)) break;
                        const suffix = String(m[2] || '').trim();
                        const label = (marker + (suffix ? (' ' + suffix) : '')).trim();
                        const offsetInLine = rawLine.indexOf(m[1]);
                        const pos = offsetInLine >= 0 ? (i + offsetInLine) : i;
                        toc.push({ label: label || trimmed, position: pos });
                        break;
                    }
                    if (toc.length >= MAX_TOC) break;
                }
                i = lineEnd + 1;
            }

            if (toc.length === 0) {
                const len = content.length;
                const chunkSize = 10000;
                for (let p = 0; p < len; p += chunkSize) {
                    toc.push({ label: `Page ${Math.floor(p / chunkSize) + 1}`, position: p });
                    if (toc.length >= MAX_TOC) break;
                }
            }
            return toc;
        }

        // --- 3D Open Book Animation & Reader Logic ---
        let rendition = null;
        let currentBook = null;
        let currentTxtContent = null;
        let currentTxtToc = [];
        let currentBookId = null;
        let lastTxtProgress = null;
        let lastEpubProgress = null;
        let txtScrollHandler = null;
        let txtTouchHandler = null;
        let txtPointerHandler = null;
        let progressAutoSaveTimer = null;
        let isRestoringTxt = false;
        let isClosingReader = false;
        let closeInFlight = null;
        let isAppendingTxt = false;
        let currentTxtTocActiveIndex = -1;
        let txtSessionId = 0;
        const TXT_PAGE_SIZE = 3000;
        let txtCharsPerPageCache = { perPage: TXT_PAGE_SIZE, w: 0, h: 0, fontSize: 0, lineHeightPx: 0, padL: 0, padR: 0, padT: 0, padB: 0 };
        let txtChapterPagingCache = { chapterIndex: -1, perPage: 0, start: 0, end: 0, starts: [] };

        function invalidateTxtCharsPerPage() {
            txtCharsPerPageCache = { perPage: TXT_PAGE_SIZE, w: 0, h: 0, fontSize: 0, lineHeightPx: 0, padL: 0, padR: 0, padT: 0, padB: 0 };
            txtChapterPagingCache = { chapterIndex: -1, perPage: 0, start: 0, end: 0, starts: [] };
        }

        function getTxtChapterPagingByAbsPos(absolutePos) {
            if (!currentTxtContent || !Number.isFinite(absolutePos)) return null;
            if (!currentTxtToc || currentTxtToc.length === 0) return null;
            const perPage = Math.max(1, getTxtCharsPerPage());
            const chapterIndex = computeTxtChapterIndexByAbsPos(absolutePos);
            const start = currentTxtToc[chapterIndex] && Number.isFinite(currentTxtToc[chapterIndex].position) ? currentTxtToc[chapterIndex].position : 0;
            const end = (chapterIndex + 1 < currentTxtToc.length) && currentTxtToc[chapterIndex + 1] && Number.isFinite(currentTxtToc[chapterIndex + 1].position)
                ? currentTxtToc[chapterIndex + 1].position
                : currentTxtContent.length;
            const cache = txtChapterPagingCache;
            if (
                cache
                && cache.chapterIndex === chapterIndex
                && cache.perPage === perPage
                && cache.start === start
                && cache.end === end
                && Array.isArray(cache.starts)
                && cache.starts.length > 0
            ) return cache;
            const starts = [Math.max(0, start)];
            const safeEnd = Math.max(starts[0], Math.min(currentTxtContent.length, end));
            const breakChars = new Set(['\n', '。', '！', '？', '.', '!', '?', '；', ';', '，', ',', '、', ' ', '\t']);
            const lookBack = Math.max(40, Math.floor(perPage * 0.22));
            let p = starts[0];
            while (p < safeEnd) {
                const windowEnd = Math.min(safeEnd, p + perPage);
                const windowText = currentTxtContent.slice(p, windowEnd);
                let cut = windowText.length;
                for (let i = windowText.length - 1; i >= 0 && i >= windowText.length - lookBack; i--) {
                    const c = windowText[i];
                    if (breakChars.has(c)) { cut = i + 1; break; }
                }
                if (cut <= 0) cut = windowText.length;
                let next = p + cut;
                if (next <= p) next = Math.min(safeEnd, p + Math.max(1, windowText.length));
                if (next <= p) break;
                starts.push(next);
                p = next;
            }
            if (starts[starts.length - 1] !== safeEnd) starts.push(safeEnd);
            txtChapterPagingCache = { chapterIndex, perPage, start: starts[0], end: safeEnd, starts };
            return txtChapterPagingCache;
        }

        function getTxtCharsPerPage() {
            try {
                const contentArea = document.getElementById('readerContent');
                if (!contentArea) return TXT_PAGE_SIZE;
                const cs = window.getComputedStyle(contentArea);
                const w = contentArea.clientWidth || 0;
                const h = contentArea.clientHeight || 0;
                const fontSize = parseFloat(cs.fontSize || '18') || 18;
                const lineHeightPx = cs.lineHeight === 'normal' ? (fontSize * 1.6) : (parseFloat(cs.lineHeight) || fontSize * 1.6);
                const isPaged = currentFlipMode === 'slide' || currentFlipMode === 'simulation' || currentFlipMode === 'sim';
                let padL = parseFloat(cs.paddingLeft || '0') || 0;
                let padR = parseFloat(cs.paddingRight || '0') || 0;
                let padT = parseFloat(cs.paddingTop || '0') || 0;
                let padB = parseFloat(cs.paddingBottom || '0') || 0;
                if (isPaged) {
                    const rootCs = window.getComputedStyle(document.documentElement);
                    const safeTop = parseFloat(rootCs.getPropertyValue('--safe-top') || '0') || 0;
                    const safeBottom = parseFloat(rootCs.getPropertyValue('--safe-bottom') || '0') || 0;
                    const reader = document.getElementById('readerView');
                    const bottomSheet = reader ? (parseFloat(window.getComputedStyle(reader).getPropertyValue('--reader-bottom-sheet') || '0') || 0) : 0;
                    padL = 24;
                    padR = 24;
                    padT = 56 + safeTop + 18;
                    padB = 82 + safeBottom + 18 + bottomSheet;
                }
                const cache = txtCharsPerPageCache;
                if (
                    cache
                    && cache.perPage
                    && cache.w === w
                    && cache.h === h
                    && cache.fontSize === fontSize
                    && cache.lineHeightPx === lineHeightPx
                    && cache.padL === padL
                    && cache.padR === padR
                    && cache.padT === padT
                    && cache.padB === padB
                ) return cache.perPage;

                const usableW = Math.max(200, w - padL - padR);
                const usableH = Math.max(200, h - padT - padB);
                const linesPerPage = Math.max(6, Math.floor(usableH / Math.max(1, lineHeightPx)));
                const avgCharW = Math.max(6, getTxtAvgCharWidth(cs));
                const charsPerLine = Math.max(10, Math.floor(usableW / avgCharW));
                const perPage = Math.max(300, Math.floor(charsPerLine * linesPerPage * 0.92));
                txtCharsPerPageCache = { perPage, w, h, fontSize, lineHeightPx, padL, padR, padT, padB };
                return perPage;
            } catch (e) {
                return TXT_PAGE_SIZE;
            }
        }
        let currentFlipMode = 'scroll';
        let lastFlipGestureAt = 0;
        let txtParagraphObserver = null;
        let txtSentinelObserver = null;
        let txtTopSentinelObserver = null;
        let txtActiveAnchorId = null;
        let txtActiveAbsPos = NaN;
        let txtProgressPersistTimer = null;
        let txtIntersecting = new Map();
        let txtObserved = new WeakSet();
        let txtLastAppendStart = null;
        let txtLastAppendAt = 0;
        let isPrependingTxt = false;
        let txtLastPrependStart = null;
        let txtLastPrependAt = 0;
        let lastPointerTarget = null;
        let suppressNextContentClickUntil = 0;

        function waitForFontsReady(maxWaitMs = 4500) {
            try {
                if (!document.fonts || !document.fonts.ready) return Promise.resolve();
                return Promise.race([
                    document.fonts.ready,
                    new Promise((resolve) => setTimeout(resolve, maxWaitMs))
                ]);
            } catch (e) {
                return Promise.resolve();
            }
        }

        function nextFrame() {
            return new Promise((resolve) => requestAnimationFrame(() => resolve()));
        }

        function trackLastPointerTarget(e) {
            lastPointerTarget = e && e.target ? e.target : null;
        }

        document.addEventListener('pointerdown', trackLastPointerTarget, { capture: true, passive: true });
        document.addEventListener('touchstart', trackLastPointerTarget, { capture: true, passive: true });
        document.addEventListener('mousedown', trackLastPointerTarget, { capture: true, passive: true });

        let txtFlipTouchStartHandler = null;
        let txtFlipTouchEndHandler = null;
        let txtFlipTouchMoveHandler = null;
        let txtFlipTouchCancelHandler = null;
        let txtFlipPointerDownHandler = null;
        let txtFlipPointerMoveHandler = null;
        let txtFlipPointerUpHandler = null;
        let txtFlipPointerCancelHandler = null;
        let txtFlipStartX = 0;
        let txtFlipStartY = 0;
        let txtFlipStartAt = 0;
        let txtFlipPointerId = null;

        let simDragState = null;
        function cleanupSimDragState() {
            if (!simDragState) return;
            try {
                const { surface, turn, cur, next } = simDragState;
                if (cur) cur.style.opacity = '1';
                if (next) next.innerHTML = '';
                if (turn && turn.parentElement) turn.parentElement.removeChild(turn);
                if (surface) surface.style.perspective = '';
            } catch (e) {}
            simDragState = null;
            txtPagedTurnLock = false;
        }

        function detachTxtFlipGestureHandlers() {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            if (txtFlipTouchStartHandler) contentArea.removeEventListener('touchstart', txtFlipTouchStartHandler);
            if (txtFlipTouchEndHandler) contentArea.removeEventListener('touchend', txtFlipTouchEndHandler);
            if (txtFlipTouchMoveHandler) contentArea.removeEventListener('touchmove', txtFlipTouchMoveHandler);
            if (txtFlipTouchCancelHandler) contentArea.removeEventListener('touchcancel', txtFlipTouchCancelHandler);
            if (txtFlipPointerDownHandler) contentArea.removeEventListener('pointerdown', txtFlipPointerDownHandler);
            if (txtFlipPointerMoveHandler) contentArea.removeEventListener('pointermove', txtFlipPointerMoveHandler);
            if (txtFlipPointerUpHandler) contentArea.removeEventListener('pointerup', txtFlipPointerUpHandler);
            if (txtFlipPointerCancelHandler) contentArea.removeEventListener('pointercancel', txtFlipPointerCancelHandler);
            txtFlipTouchStartHandler = null;
            txtFlipTouchEndHandler = null;
            txtFlipTouchMoveHandler = null;
            txtFlipTouchCancelHandler = null;
            txtFlipPointerDownHandler = null;
            txtFlipPointerMoveHandler = null;
            txtFlipPointerUpHandler = null;
            txtFlipPointerCancelHandler = null;
            txtFlipPointerId = null;
            cleanupSimDragState();
        }

        function attachTxtFlipGestureHandlers(session = txtSessionId) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            detachTxtFlipGestureHandlers();
            const begin = (x, y, t) => {
                txtFlipStartX = x;
                txtFlipStartY = y;
                txtFlipStartAt = t;
            };
            const resolveTapAction = (clientX, clientY) => {
                const rect = contentArea.getBoundingClientRect ? contentArea.getBoundingClientRect() : null;
                const w = rect ? (rect.width || contentArea.clientWidth || 1) : (contentArea.clientWidth || 1);
                const h = rect ? (rect.height || contentArea.clientHeight || 1) : (contentArea.clientHeight || 1);
                const x = rect ? ((clientX || 0) - rect.left) : (clientX || 0);
                const y = rect ? ((clientY || 0) - rect.top) : (clientY || 0);
                const cornerW = w * 0.30;
                const cornerH = h * 0.24;
                const inLeft = x <= cornerW;
                const inRight = x >= (w - cornerW);
                const inTop = y <= cornerH;
                const inBottom = y >= (h - cornerH);
                if (inTop && (inLeft || inRight)) return -1;
                if (inBottom && (inLeft || inRight)) return 1;
                return 0;
            };
            const maybeTurn = (endX, endY, endT) => {
                if (session !== txtSessionId) return;
                if (!currentTxtContent) return;
                if (currentFlipMode !== 'slide' && currentFlipMode !== 'simulation') return;
                if (hasAnyReaderPanelOpen()) return;
                if (simDragState) return;
                const dx = endX - txtFlipStartX;
                const dy = endY - txtFlipStartY;
                const dt = Math.max(1, endT - txtFlipStartAt);
                if (Math.abs(dx) < 44) return;
                if (Math.abs(dx) < Math.abs(dy) * 1.3) return;
                if (dt > 650) return;
                const direction = dx < 0 ? 1 : -1;
                lastFlipGestureAt = Date.now();
                turnTxtPaged(direction);
            };

            const ensureSimDrag = (direction) => {
                if (simDragState) return true;
                if (currentFlipMode !== 'simulation') return false;
                if (txtPagedTurnLock) return false;
                const surface = contentArea.querySelector('.sim-surface');
                const cur = surface ? surface.querySelector('.sim-current') : null;
                const next = surface ? surface.querySelector('.sim-next') : null;
                if (!surface || !cur || !next) return false;
                const nextIndex = txtPagedIndex + (direction > 0 ? 1 : -1);
                if (nextIndex < 0 || nextIndex >= txtPagedPages.length) return false;
                txtPagedTurnLock = true;
                next.innerHTML = `<div class="paged-page">${txtPagedPages[nextIndex] || ''}</div>`;
                const pageHtml = cur.innerHTML || '';
                const safePageHtml = pageHtml.replace(/\sid="txt-[^"]+"/g, '');
                const turn = document.createElement('div');
                turn.className = 'sim-turn';
                turn.classList.add(direction > 0 ? 'turn-forward' : 'turn-backward');
                turn.innerHTML = `<div class="sim-sheet"><div class="sim-front">${safePageHtml}</div><div class="sim-back">${safePageHtml}</div><div class="sim-shadow"></div></div>`;
                turn.style.transition = 'none';
                turn.style.transformOrigin = direction > 0 ? 'left center' : 'right center';
                turn.style.transform = 'rotateY(0deg)';
                surface.appendChild(turn);
                cur.style.opacity = '0';
                simDragState = {
                    surface,
                    cur,
                    next,
                    turn,
                    direction,
                    nextIndex,
                    lastX: txtFlipStartX,
                    lastT: txtFlipStartAt,
                    startX: txtFlipStartX
                };
                return true;
            };

            const updateSimDrag = (x) => {
                if (!simDragState) return;
                const w = contentArea.clientWidth || 1;
                const dx = x - simDragState.startX;
                const progress = Math.max(0, Math.min(1, Math.abs(dx) / Math.max(1, w)));
                const deg = (simDragState.direction > 0 ? -180 : 180) * progress;
                simDragState.turn.style.transform = `rotateY(${deg}deg)`;
                try {
                    const sh = simDragState.turn.querySelector('.sim-shadow');
                    if (sh) sh.style.opacity = String(Math.min(1, 0.15 + progress * 0.9));
                } catch (e) {}
                simDragState.lastX = x;
                simDragState.lastT = Date.now();
                simDragState.progress = progress;
            };

            const finishSimDrag = (x) => {
                if (!simDragState) return false;
                const w = contentArea.clientWidth || 1;
                const dx = x - simDragState.startX;
                const progress = Math.max(0, Math.min(1, Math.abs(dx) / Math.max(1, w)));
                const now = Date.now();
                const dt = Math.max(1, now - (simDragState.lastT || txtFlipStartAt));
                const vx = (x - (simDragState.lastX || x)) / dt;
                const commit = progress > 0.42 || (simDragState.direction > 0 ? vx < -0.85 : vx > 0.85);
                const finalDeg = commit ? (simDragState.direction > 0 ? -180 : 180) : 0;
                simDragState.turn.style.transition = commit
                    ? 'transform 520ms cubic-bezier(0.2, 0.8, 0.2, 1)'
                    : 'transform 360ms cubic-bezier(0.2, 0.8, 0.2, 1)';
                simDragState.turn.style.transform = `rotateY(${finalDeg}deg)`;
                setTimeout(() => {
                    const st = simDragState;
                    if (!st) return;
                    if (commit) {
                        txtPagedIndex = st.nextIndex;
                        st.cur.innerHTML = st.next.innerHTML;
                        st.cur.style.opacity = '1';
                        st.next.innerHTML = '';
                        if (st.turn.parentElement) st.turn.parentElement.removeChild(st.turn);
                        simDragState = null;
                        txtPagedTurnLock = false;
                        lastFlipGestureAt = Date.now();
                        setTxtActiveFromPagedIndex();
                        schedulePersistTxtAnchorProgress('auto');
                    } else {
                        cleanupSimDragState();
                    }
                }, commit ? 560 : 420);
                return true;
            };

            const maybeStartSimByMove = (x, y) => {
                if (session !== txtSessionId) return;
                if (!currentTxtContent) return;
                if (currentFlipMode !== 'simulation') return;
                if (hasAnyReaderPanelOpen()) return;
                if (simDragState) return;
                const dx = x - txtFlipStartX;
                const dy = y - txtFlipStartY;
                if (Math.abs(dx) < 10) return;
                if (Math.abs(dx) < Math.abs(dy) * 1.15) return;
                const w = contentArea.clientWidth || 1;
                const dir = dx < 0 ? 1 : -1;
                const edgeOk = dir > 0 ? (txtFlipStartX > w * 0.70) : (txtFlipStartX < w * 0.30);
                if (!edgeOk) return;
                if (!ensureSimDrag(dir)) return;
                updateSimDrag(x);
            };
            txtFlipTouchStartHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e || !e.touches || !e.touches[0]) return;
                const t = e.touches[0];
                begin(t.clientX || 0, t.clientY || 0, Date.now());
            };
            txtFlipTouchMoveHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e || !e.touches || !e.touches[0]) return;
                const t = e.touches[0];
                if (currentFlipMode === 'simulation') {
                    if (!simDragState) maybeStartSimByMove(t.clientX || 0, t.clientY || 0);
                    else updateSimDrag(t.clientX || 0);
                }
            };
            txtFlipTouchEndHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e || !e.changedTouches || !e.changedTouches[0]) return;
                const t = e.changedTouches[0];
                if (currentFlipMode === 'scroll') {
                    const dx = (t.clientX || 0) - txtFlipStartX;
                    const dy = (t.clientY || 0) - txtFlipStartY;
                    const dt = Math.max(1, Date.now() - txtFlipStartAt);
                    const click = Math.abs(dx) <= 10 && Math.abs(dy) <= 10 && dt <= 550;
                    if (click) {
                        if (shouldIgnoreMenuToggleTarget(e.target)) return;
                        suppressNextContentClickUntil = Date.now() + 480;
                        if (hasAnyReaderPanelOpen()) {
                            toggleMenu({ event: e, ignoreGuard: true });
                            return;
                        }
                        const action = resolveTapAction(t.clientX || 0, t.clientY || 0);
                        if (action < 0) {
                            lastFlipGestureAt = Date.now();
                            scrollPage(-1);
                            return;
                        }
                        if (action > 0) {
                            lastFlipGestureAt = Date.now();
                            scrollPage(1);
                            return;
                        }
                        toggleMenu({ event: e, ignoreGuard: true });
                        return;
                    }
                    return;
                }
                if (currentFlipMode === 'simulation' && !simDragState) {
                    const dx = (t.clientX || 0) - txtFlipStartX;
                    const dy = (t.clientY || 0) - txtFlipStartY;
                    const dt = Math.max(1, Date.now() - txtFlipStartAt);
                    const click = Math.abs(dx) <= 10 && Math.abs(dy) <= 10 && dt <= 550;
                    if (click) {
                        if (shouldIgnoreMenuToggleTarget(e.target)) return;
                        suppressNextContentClickUntil = Date.now() + 480;
                        if (hasAnyReaderPanelOpen()) {
                            toggleMenu({ event: e, ignoreGuard: true });
                            return;
                        }
                        const action = resolveTapAction(t.clientX || 0, t.clientY || 0);
                        if (action < 0) {
                            lastFlipGestureAt = Date.now();
                            turnTxtPaged(-1);
                            return;
                        }
                        if (action > 0) {
                            lastFlipGestureAt = Date.now();
                            turnTxtPaged(1);
                            return;
                        }
                        toggleMenu({ event: e, ignoreGuard: true });
                        return;
                    }
                    return;
                }
                if (currentFlipMode === 'simulation' && simDragState) {
                    finishSimDrag(t.clientX || 0);
                    return;
                }
                if (currentFlipMode === 'slide') {
                    const dx = (t.clientX || 0) - txtFlipStartX;
                    const dy = (t.clientY || 0) - txtFlipStartY;
                    const dt = Math.max(1, Date.now() - txtFlipStartAt);
                    const click = Math.abs(dx) <= 10 && Math.abs(dy) <= 10 && dt <= 550;
                    if (click) {
                        if (shouldIgnoreMenuToggleTarget(e.target)) return;
                        suppressNextContentClickUntil = Date.now() + 480;
                        if (hasAnyReaderPanelOpen()) {
                            toggleMenu({ event: e, ignoreGuard: true });
                            return;
                        }
                        toggleMenu({ event: e, ignoreGuard: true });
                        return;
                    }
                }
                maybeTurn(t.clientX || 0, t.clientY || 0, Date.now());
            };
            txtFlipTouchCancelHandler = () => {
                cleanupSimDragState();
            };
            txtFlipPointerDownHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e) return;
                if (e.pointerType === 'mouse' && e.buttons !== 1) return;
                txtFlipPointerId = e.pointerId;
                begin(e.clientX || 0, e.clientY || 0, Date.now());
                try { contentArea.setPointerCapture(e.pointerId); } catch (err) {}
            };
            txtFlipPointerMoveHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e) return;
                if (txtFlipPointerId !== null && e.pointerId !== txtFlipPointerId) return;
                if (e.pointerType === 'mouse' && e.buttons !== 1) {
                    txtFlipPointerId = null;
                    cleanupSimDragState();
                    return;
                }
                if (currentFlipMode === 'simulation') {
                    if (!simDragState) maybeStartSimByMove(e.clientX || 0, e.clientY || 0);
                    else updateSimDrag(e.clientX || 0);
                }
            };
            txtFlipPointerUpHandler = (e) => {
                if (session !== txtSessionId) return;
                if (!e) return;
                if (txtFlipPointerId !== null && e.pointerId !== txtFlipPointerId) return;
                txtFlipPointerId = null;
                try { contentArea.releasePointerCapture(e.pointerId); } catch (err) {}
                if (currentFlipMode === 'scroll') {
                    const dx = (e.clientX || 0) - txtFlipStartX;
                    const dy = (e.clientY || 0) - txtFlipStartY;
                    const dt = Math.max(1, Date.now() - txtFlipStartAt);
                    const click = Math.abs(dx) <= 10 && Math.abs(dy) <= 10 && dt <= 550;
                    if (click) {
                        if (shouldIgnoreMenuToggleTarget(e.target)) return;
                        suppressNextContentClickUntil = Date.now() + 480;
                        if (hasAnyReaderPanelOpen()) {
                            toggleMenu({ event: e, ignoreGuard: true });
                            return;
                        }
                        const action = resolveTapAction(e.clientX || 0, e.clientY || 0);
                        if (action < 0) {
                            lastFlipGestureAt = Date.now();
                            scrollPage(-1);
                            return;
                        }
                        if (action > 0) {
                            lastFlipGestureAt = Date.now();
                            scrollPage(1);
                            return;
                        }
                        toggleMenu({ event: e, ignoreGuard: true });
                        return;
                    }
                }
                if (currentFlipMode === 'simulation' && simDragState) {
                    finishSimDrag(e.clientX || 0);
                    return;
                }
                if (currentFlipMode === 'simulation') {
                    const dx = (e.clientX || 0) - txtFlipStartX;
                    const dy = (e.clientY || 0) - txtFlipStartY;
                    const dt = Math.max(1, Date.now() - txtFlipStartAt);
                    const click = Math.abs(dx) <= 10 && Math.abs(dy) <= 10 && dt <= 550;
                    if (click) {
                        const action = resolveTapAction(e.clientX || 0, e.clientY || 0);
                        if (action < 0) {
                            lastFlipGestureAt = Date.now();
                            turnTxtPaged(-1);
                            return;
                        }
                        if (action > 0) {
                            lastFlipGestureAt = Date.now();
                            turnTxtPaged(1);
                            return;
                        }
                        suppressNextContentClickUntil = Date.now() + 480;
                        toggleMenu({ event: e, ignoreGuard: true });
                        return;
                    }
                }
                if (currentFlipMode === 'slide') {
                    const dx = (e.clientX || 0) - txtFlipStartX;
                    const dy = (e.clientY || 0) - txtFlipStartY;
                    const dt = Math.max(1, Date.now() - txtFlipStartAt);
                    const click = Math.abs(dx) <= 10 && Math.abs(dy) <= 10 && dt <= 550;
                    if (click) {
                        if (shouldIgnoreMenuToggleTarget(e.target)) return;
                        suppressNextContentClickUntil = Date.now() + 480;
                        if (hasAnyReaderPanelOpen()) {
                            toggleMenu({ event: e, ignoreGuard: true });
                            return;
                        }
                        toggleMenu({ event: e, ignoreGuard: true });
                        return;
                    }
                }
                maybeTurn(e.clientX || 0, e.clientY || 0, Date.now());
            };
            txtFlipPointerCancelHandler = () => {
                txtFlipPointerId = null;
                cleanupSimDragState();
            };
            contentArea.addEventListener('touchstart', txtFlipTouchStartHandler, { passive: true });
            contentArea.addEventListener('touchmove', txtFlipTouchMoveHandler, { passive: true });
            contentArea.addEventListener('touchend', txtFlipTouchEndHandler, { passive: true });
            contentArea.addEventListener('touchcancel', txtFlipTouchCancelHandler, { passive: true });
            contentArea.addEventListener('pointerdown', txtFlipPointerDownHandler, { passive: true });
            contentArea.addEventListener('pointermove', txtFlipPointerMoveHandler, { passive: true });
            contentArea.addEventListener('pointerup', txtFlipPointerUpHandler, { passive: true });
            contentArea.addEventListener('pointercancel', txtFlipPointerCancelHandler, { passive: true });
        }

        function escapeHtml(s) {
            const str = String(s ?? '');
            return str.replace(/[&<>"']/g, (c) => {
                if (c === '&') return '&amp;';
                if (c === '<') return '&lt;';
                if (c === '>') return '&gt;';
                if (c === '"') return '&quot;';
                return '&#39;';
            });
        }

        function absPosFromAnchorId(anchorId) {
            if (!anchorId) return NaN;
            const m = /-a(\d+)$/.exec(String(anchorId));
            if (!m) return NaN;
            const n = parseInt(m[1], 10);
            return Number.isFinite(n) ? n : NaN;
        }

        function txtAnchorIdForAbsPos(bookId, absPos) {
            return `txt-${bookId}-a${absPos}`;
        }

        function computeTxtChapterIndexByAbsPos(absPos) {
            if (!currentTxtToc || currentTxtToc.length === 0) return 0;
            if (!Number.isFinite(absPos) || absPos < 0) return 0;
            let lo = 0;
            let hi = currentTxtToc.length - 1;
            let ans = 0;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const p = currentTxtToc[mid] && Number.isFinite(currentTxtToc[mid].position) ? currentTxtToc[mid].position : 0;
                if (p <= absPos) {
                    ans = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            return ans;
        }

        function teardownTxtObservers() {
            if (txtParagraphObserver) {
                try { txtParagraphObserver.disconnect(); } catch (e) {}
                txtParagraphObserver = null;
            }
            if (txtSentinelObserver) {
                try { txtSentinelObserver.disconnect(); } catch (e) {}
                txtSentinelObserver = null;
            }
            if (txtTopSentinelObserver) {
                try { txtTopSentinelObserver.disconnect(); } catch (e) {}
                txtTopSentinelObserver = null;
            }
            if (txtProgressPersistTimer) {
                clearTimeout(txtProgressPersistTimer);
                txtProgressPersistTimer = null;
            }
            txtActiveAnchorId = null;
            txtActiveAbsPos = NaN;
            txtIntersecting = new Map();
            txtObserved = new WeakSet();
            txtLastAppendStart = null;
            txtLastAppendAt = 0;
            isPrependingTxt = false;
            txtLastPrependStart = null;
            txtLastPrependAt = 0;
        }

        function scrollParagraphIntoView(el, options = null) {
            const contentArea = document.getElementById('readerContent');
            if (!el || !contentArea) return;
            const opts = options || {};
            if (currentFlipMode === 'slide') {
                try { el.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'start' }); } catch (e) {}
                return;
            }
            try {
                const cs = window.getComputedStyle(contentArea);
                const padTop = parseFloat(cs.paddingTop) || 0;
                const base = Math.max(0, (el.offsetTop || 0) - padTop);
                const extra = Number.isFinite(opts.anchorOffset) ? opts.anchorOffset : 0;
                const maxScroll = Math.max(0, contentArea.scrollHeight - contentArea.clientHeight);
                contentArea.scrollTop = Math.max(0, Math.min(maxScroll, base + Math.max(0, extra)));
            } catch (e) {
                try { el.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' }); } catch (err) {}
            }
        }

        function schedulePersistTxtAnchorProgress(reason = 'auto') {
            if (reason === 'auto' && hasAnyReaderPanelOpen()) return;
            if (isRestoringTxt) return;
            if (isClosingReader && reason === 'auto') return;
            if (!currentBookId || !currentTxtContent) return;
            if (!txtActiveAnchorId || !Number.isFinite(txtActiveAbsPos)) return;
            if (txtProgressPersistTimer) clearTimeout(txtProgressPersistTimer);
            txtProgressPersistTimer = setTimeout(() => persistTxtAnchorProgress(reason), 250);
        }

        async function persistTxtAnchorProgress(reason = 'auto') {
            if (!currentBookId || !currentTxtContent) return;
            if (!txtActiveAnchorId || !Number.isFinite(txtActiveAbsPos)) return;
            const CHUNK_SIZE = 15000;
            const absPos = Math.max(0, Math.min(currentTxtContent.length - 1, txtActiveAbsPos));
            const ratio = currentTxtContent.length > 0 ? (absPos / currentTxtContent.length) : 0;
            const percent = absPos > 0 ? Math.min(100, Math.max(1, Math.round(ratio * 100))) : 0;
            const chapterIndex = computeTxtChapterIndexByAbsPos(absPos);
            const chunkStart = Math.max(0, Math.floor(absPos / CHUNK_SIZE) * CHUNK_SIZE);
            const contentArea = document.getElementById('readerContent');
            const isSlide = currentFlipMode === 'slide';
            const scrollPos = contentArea ? (isSlide ? contentArea.scrollLeft : contentArea.scrollTop) : 0;
            const nearEdge = contentArea ? (scrollPos <= 80) : false;
            let anchorOffset = 0;
            if (!isSlide && contentArea && txtActiveAnchorId) {
                try {
                    const el = document.getElementById(txtActiveAnchorId);
                    if (el && contentArea.contains(el)) {
                        const cs = window.getComputedStyle(contentArea);
                        const padTop = parseFloat(cs.paddingTop) || 0;
                        const base = Math.max(0, (el.offsetTop || 0) - padTop);
                        anchorOffset = Math.max(0, Math.min((contentArea.scrollTop || 0) - base, Math.max(0, el.offsetHeight || 0)));
                    }
                } catch (e) {}
            }
            lastTxtProgress = { absolutePos: absPos, percent, chunkStart, ratio, chapterIndex, activeElementId: txtActiveAnchorId, anchorOffset };
            setActiveTxtTocIndex(chapterIndex);
            updatePageIndicatorByTxtPos(absPos);
            debugLog('saveTxtProgressFromView', { reason, data: lastTxtProgress });
            await storage.saveProgress(
                currentBookId,
                String(absPos),
                percent,
                scrollPos,
                chunkStart,
                { kind: 'txt', ratio, chapterIndex, activeElementId: txtActiveAnchorId, anchorOffset, reason, nearEdge, flipMode: currentFlipMode }
            );
        }

        function ensureTxtObservers(session = txtSessionId) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            if (!txtParagraphObserver) {
                txtParagraphObserver = new IntersectionObserver((entries) => {
                    if (session !== txtSessionId) return;
                    if (isClosingReader) return;
                    const rootRect = contentArea.getBoundingClientRect();
                    for (const entry of entries) {
                        const el = entry.target;
                        if (!el || el.getAttribute('data-anchor') === '1') continue;
                        const id = el.id || null;
                        if (!id) continue;
                        if (!entry.isIntersecting) {
                            txtIntersecting.delete(id);
                            continue;
                        }
                        const relPrimary = currentFlipMode === 'slide'
                            ? (entry.boundingClientRect.left - rootRect.left)
                            : (entry.boundingClientRect.top - rootRect.top);
                        txtIntersecting.set(id, { ratio: entry.intersectionRatio || 0, relPrimary, el });
                    }
                    if (txtIntersecting.size === 0) return;
                    let best = null;
                    const targetPrimary = currentFlipMode === 'slide'
                        ? ((contentArea.clientWidth || 1) * 0.2)
                        : ((contentArea.clientHeight || 1) * 0.35);
                    for (const v of txtIntersecting.values()) {
                        if (!v || !v.el) continue;
                        if (!best) {
                            best = v;
                            continue;
                        }
                        const aDelta = Math.abs((v.relPrimary || 0) - targetPrimary);
                        const bDelta = Math.abs((best.relPrimary || 0) - targetPrimary);
                        if (aDelta < bDelta) {
                            best = v;
                            continue;
                        }
                        if (Math.abs(aDelta - bDelta) <= 0.5 && (v.ratio || 0) > (best.ratio || 0)) {
                            best = v;
                        }
                    }
                    if (!best || !best.el) return;
                    const abs = parseInt(best.el.getAttribute('data-abs') || 'NaN', 10);
                    if (!Number.isFinite(abs)) return;
                    const nextId = best.el.id || null;
                    if (!nextId || nextId === txtActiveAnchorId) return;
                    txtActiveAnchorId = nextId;
                    txtActiveAbsPos = abs;
                    schedulePersistTxtAnchorProgress('auto');
                }, {
                    root: contentArea,
                    rootMargin: '0px 0px 0px 0px',
                    threshold: [0, 0.01]
                });
            }
            if (!txtSentinelObserver) {
                txtSentinelObserver = new IntersectionObserver((entries) => {
                    if (session !== txtSessionId) return;
                    if (isRestoringTxt) return;
                    if (isClosingReader) return;
                    if (hasAnyReaderPanelOpen()) return;
                    for (const entry of entries) {
                        if (entry.isIntersecting) maybeAutoAppendTxt(true);
                    }
                }, { root: contentArea, threshold: 0.1 });
            }
            if (!txtTopSentinelObserver) {
                txtTopSentinelObserver = new IntersectionObserver((entries) => {
                    if (session !== txtSessionId) return;
                    if (isRestoringTxt) return;
                    if (isClosingReader) return;
                    if (hasAnyReaderPanelOpen()) return;
                    for (const entry of entries) {
                        if (entry.isIntersecting) maybeAutoPrependTxt(true);
                    }
                }, { root: contentArea, threshold: 0.1 });
            }
        }

        function observeTxtContainer(session = txtSessionId) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            ensureTxtObservers(session);
            if (txtParagraphObserver) {
                const paras = Array.from(contentArea.querySelectorAll('p[data-abs]'));
                for (const p of paras) {
                    if (!p || p.getAttribute('data-anchor') === '1') continue;
                    if (txtObserved.has(p)) continue;
                    txtObserved.add(p);
                    try { txtParagraphObserver.observe(p); } catch (e) {}
                }
            }
            if (txtSentinelObserver) {
                const sentinel = contentArea.querySelector('[data-txt-sentinel="1"]');
                if (sentinel) {
                    try { txtSentinelObserver.observe(sentinel); } catch (e) {}
                }
            }
            if (txtTopSentinelObserver) {
                const topSentinel = contentArea.querySelector('[data-txt-top-sentinel="1"]');
                if (topSentinel) {
                    try { txtTopSentinelObserver.observe(topSentinel); } catch (e) {}
                }
            }
        }

        function hasAnyReaderPanelOpen() {
            const tocPanel = document.getElementById('tocPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const queryPanel = document.getElementById('queryPanel');
            return (tocPanel && tocPanel.classList.contains('active'))
                || (settingsPanel && settingsPanel.classList.contains('active'))
                || (moreMenu && moreMenu.classList.contains('active'))
                || (queryPanel && queryPanel.classList.contains('active'));
        }

        function setActiveTxtTocIndex(idx) {
            if (!Number.isFinite(idx)) return;
            const i = Math.max(-1, Math.min((currentTxtToc ? currentTxtToc.length : 0) - 1, Math.floor(idx)));
            if (i === currentTxtTocActiveIndex) return;
            const tocList = document.getElementById('tocList');
            if (tocList) {
                const prev = tocList.querySelector('.toc-item.active');
                if (prev) prev.classList.remove('active');
                const next = tocList.querySelector(`.toc-item[data-toc-index="${i}"]`);
                if (next) next.classList.add('active');
            }
            currentTxtTocActiveIndex = i;
        }

        function updatePageIndicatorByTxtPos(absolutePos) {
            const el = document.getElementById('readerPageIndicator');
            const chapEl = document.getElementById('readerChapterPageIndicator');
            if (!el && !chapEl) return;
            if (!currentTxtContent || !Number.isFinite(absolutePos)) {
                if (el) el.textContent = '';
                if (chapEl) chapEl.textContent = '';
                return;
            }
            const perPage = Math.max(1, getTxtCharsPerPage());
            const totalPages = Math.max(1, Math.ceil(currentTxtContent.length / perPage));
            const currentPage = Math.max(1, Math.min(totalPages, Math.floor(absolutePos / perPage) + 1));
            if (el) el.textContent = `${currentPage}/${totalPages}`;
            if (chapEl && currentTxtToc && currentTxtToc.length > 0) {
                const paging = getTxtChapterPagingByAbsPos(absolutePos);
                if (paging && Array.isArray(paging.starts) && paging.starts.length > 0) {
                    const starts = paging.starts;
                    const totalChapterPages = Math.max(1, starts.length - 1);
                    const abs = Math.max(paging.start, Math.min(paging.end, absolutePos));
                    let lo = 0;
                    let hi = starts.length - 1;
                    let ans = 0;
                    while (lo <= hi) {
                        const mid = (lo + hi) >> 1;
                        if ((starts[mid] || 0) <= abs) { ans = mid; lo = mid + 1; }
                        else hi = mid - 1;
                    }
                    const chapterPage = Math.max(1, Math.min(totalChapterPages, ans + 1));
                    chapEl.textContent = `第${chapterPage}/${totalChapterPages}页`;
                } else {
                    const chapterIndex = computeTxtChapterIndexByAbsPos(absolutePos);
                    const start = currentTxtToc[chapterIndex] && Number.isFinite(currentTxtToc[chapterIndex].position) ? currentTxtToc[chapterIndex].position : 0;
                    const end = (chapterIndex + 1 < currentTxtToc.length) && currentTxtToc[chapterIndex + 1] && Number.isFinite(currentTxtToc[chapterIndex + 1].position)
                        ? currentTxtToc[chapterIndex + 1].position
                        : currentTxtContent.length;
                    const totalChapterPages = Math.max(1, Math.ceil(Math.max(1, end - start) / perPage));
                    const chapterPage = Math.max(1, Math.min(totalChapterPages, Math.floor(Math.max(0, absolutePos - start) / perPage) + 1));
                    chapEl.textContent = `第${chapterPage}/${totalChapterPages}页`;
                }
            } else if (chapEl) {
                chapEl.textContent = `第${currentPage}/${totalPages}页`;
            }
        }

        function updateActiveTxtTocByPos(absolutePos) {
            if (!currentTxtToc || currentTxtToc.length === 0) return;
            if (!Number.isFinite(absolutePos) || absolutePos < 0) return;
            let lo = 0;
            let hi = currentTxtToc.length - 1;
            let ans = 0;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const p = currentTxtToc[mid] && Number.isFinite(currentTxtToc[mid].position) ? currentTxtToc[mid].position : 0;
                if (p <= absolutePos) {
                    ans = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            setActiveTxtTocIndex(ans);
            updatePageIndicatorByTxtPos(absolutePos);
        }

        async function openBookFromId(id) {
            if (closeInFlight) {
                debugLog('openBookFromId wait close', { id });
                await closeInFlight;
            }
            const openSession = ++txtSessionId;
            currentBookId = id; // Set ID
            lastTxtProgress = null;
            lastEpubProgress = null;
            isRestoringTxt = true;
            isClosingReader = false;
            teardownTxtObservers();
            const bookData = await storage.getBook(id);
            if (!bookData) return;

            // Prepare Reader View
            document.getElementById('readerTitle').innerText = bookData.title;
            const contentArea = document.getElementById('readerContent');
            contentArea.onclick = (e) => handleReaderContentClick(e);
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            if (txtScrollHandler && txtScrollHandler.cancel) txtScrollHandler.cancel();
            if (txtTouchHandler && txtTouchHandler.cancel) txtTouchHandler.cancel();
            if (txtPointerHandler && txtPointerHandler.cancel) txtPointerHandler.cancel();
            detachTxtFlipGestureHandlers();
            if (txtScrollHandler) contentArea.removeEventListener('scroll', txtScrollHandler);
            if (txtTouchHandler) contentArea.removeEventListener('touchend', txtTouchHandler);
            if (txtPointerHandler) contentArea.removeEventListener('pointerup', txtPointerHandler);
            contentArea.innerHTML = '<div style="padding:40px; text-align:center; color:var(--text-tertiary);">正在加载...</div>';
            document.getElementById('readerView').classList.remove('closing');
            document.getElementById('readerView').classList.remove('menu-visible');
            document.getElementById('settingsPanel').classList.remove('active');
            try { updateReaderBottomSheetOffset(); } catch (e) {}
            document.getElementById('tocPanel').classList.remove('active');
            document.getElementById('tocOverlay').classList.remove('active');
            document.getElementById('moreMenu').classList.remove('active');
            
            // Reset Flip Mode to Scroll for stability on open
            // currentFlipMode = 'scroll';
            // document.getElementById('flipModeText').innerText = '滚动';
            contentArea.classList.remove('mode-slide');
            contentArea.classList.remove('mode-sim');
            document.getElementById('readerView').classList.remove('flip-slide');
            
            lockBodyScroll(true);
            const readerViewEl = document.getElementById('readerView');
            readerViewEl.classList.add('active');
            readerViewEl.classList.add('menu-visible');
            setTimeout(() => {
                if (openSession !== txtSessionId) return;
                const settingsPanel = document.getElementById('settingsPanel');
                const tocPanel = document.getElementById('tocPanel');
                const moreMenu = document.getElementById('moreMenu');
                const hasPanelOpen = (settingsPanel && settingsPanel.classList.contains('active'))
                    || (tocPanel && tocPanel.classList.contains('active'))
                    || (moreMenu && moreMenu.classList.contains('active'));
                if (!hasPanelOpen) readerViewEl.classList.remove('menu-visible');
            }, 1200);

            // Delay processing to allow animation to start smoothly
            setTimeout(async () => {
                if (openSession !== txtSessionId) return;
                if (bookData.format === 'EPUB') {
                    // ... existing EPUB logic ...
                    try {
                        contentArea.innerHTML = '';
                        currentBook = ePub(bookData.fileBlob);
                        rendition = currentBook.renderTo("readerContent", {
                            width: "100%",
                            height: "100%",
                            flow: "scrolled", // Always start scrolled for now
                            manager: "default"
                        });
                        
                        const savedProgress = await storage.getProgress(id);
                        if (savedProgress && savedProgress.cfi) {
                            lastEpubProgress = { cfi: savedProgress.cfi, percent: savedProgress.percentage || 0 };
                        }
                        await rendition.display(savedProgress ? savedProgress.cfi : undefined);
                        startProgressAutoSave(openSession);
                        try { attachEpubInteractionHandlers(rendition, openSession); } catch (e) {}
                        
                        rendition.on('relocated', (location) => {
                            const cfi = location && location.start ? location.start.cfi : null;
                            if (!cfi) return;
                            const rawPercent = currentBook.locations && currentBook.locations.length
                                ? currentBook.locations.percentageFromCfi(cfi)
                                : 0;
                            const percent = Number.isFinite(rawPercent) ? Math.floor(rawPercent * 100) : 0;
                            lastEpubProgress = { cfi, percent };
                            storage.saveProgress(id, cfi, percent);
                        });

                        // Generate TOC
                        const navigation = await currentBook.loaded.navigation;
                        const tocSubtitleEl = document.querySelector('#tocPanel .toc-subtitle');
                        if (tocSubtitleEl) tocSubtitleEl.textContent = `共 ${navigation && navigation.toc ? navigation.toc.length : 0} 章`;
                        const tocList = document.getElementById('tocList');
                        tocList.innerHTML = navigation.toc.map(chapter => `
                            <div class="toc-item" onclick="event.stopPropagation(); rendition.display('${chapter.href}'); closeTOC();">
                                <span>${chapter.label}</span>
                            </div>
                        `).join('');
                    } catch (err) {
                        console.error('EPUB render error:', err);
                        contentArea.innerHTML = '<div style="padding:20px; color:red;">解析失败，请检查文件格式</div>';
                    }
                } else {
                    // Optimized TXT rendering
                    try {
                        const text = await parseTxt(bookData.fileBlob);
                        if (openSession !== txtSessionId) return;
                        currentTxtContent = text;
                        currentTxtToc = parseTxtToc(text);
                        
                        // Render TOC
                        const tocSubtitleEl = document.querySelector('#tocPanel .toc-subtitle');
                        if (tocSubtitleEl) tocSubtitleEl.textContent = `共 ${currentTxtToc.length} 章`;
                        const tocList = document.getElementById('tocList');
                        if (currentTxtToc.length > 0) {
                            tocList.innerHTML = currentTxtToc.map((item, idx) => `
                                <div class="toc-item" data-toc-index="${idx}" onclick="event.stopPropagation(); jumpToTxtPosition(${item.position}, ${idx})">
                                    <span>${item.label}</span>
                                </div>
                            `).join('');
                        } else {
                             tocList.innerHTML = '<div style="padding:20px;">暂无目录</div>';
                        }
                        
                        isRestoringTxt = true;
                        const savedProgress = await storage.getProgress(id);
                        debugLog('txt open: savedProgress', { id, savedProgress });
                        const desiredFlipMode = 'scroll';
                        const savedAnchorId = savedProgress && savedProgress.activeElementId ? String(savedProgress.activeElementId) : null;
                        const savedAnchorAbs = absPosFromAnchorId(savedAnchorId);
                        const savedAnchorOffset = savedProgress && savedProgress.anchorOffset !== undefined && savedProgress.anchorOffset !== null
                            ? Number(savedProgress.anchorOffset)
                            : NaN;
                        const ratio = savedProgress && savedProgress.ratio !== undefined && savedProgress.ratio !== null
                            ? parseFloat(savedProgress.ratio)
                            : NaN;
                        const posFromRatio = Number.isFinite(ratio)
                            ? Math.max(0, Math.min(currentTxtContent.length - 1, Math.floor(ratio * currentTxtContent.length)))
                            : NaN;
                        const cfiPos = savedProgress && savedProgress.cfi !== undefined && savedProgress.cfi !== null
                            ? parseInt(savedProgress.cfi)
                            : NaN;
                        const posFromCfi = Number.isFinite(cfiPos) ? Math.max(0, Math.min(currentTxtContent.length - 1, cfiPos)) : NaN;
                        let absolutePos = Math.max(0, Number.isFinite(posFromCfi) ? posFromCfi : (Number.isFinite(posFromRatio) ? posFromRatio : 0));
                        if (Number.isFinite(savedAnchorAbs)) absolutePos = Math.max(0, Math.min(currentTxtContent.length - 1, savedAnchorAbs));
                        let anchorId = savedAnchorId;
                        if (!anchorId) anchorId = txtAnchorIdForAbsPos(currentBookId, absolutePos);
                        const CHUNK_SIZE = 15000;
                        const chunkStart = Math.max(0, Math.floor(absolutePos / CHUNK_SIZE) * CHUNK_SIZE);
                        debugLog('txt open: restore plan', { absolutePos, posFromCfi, posFromRatio, chunkStart, ratio });
                        currentFlipMode = desiredFlipMode;
                        renderTxtChunk(chunkStart);
                        const fontsReadyPromise = waitForFontsReady();
                        let restoreAttempts = 0;
                        const tryRestore = () => {
                            if (openSession !== txtSessionId) return;
                            observeTxtContainer(openSession);
                            let target = null;
                            if (anchorId) {
                                const el = document.getElementById(anchorId);
                                if (el && contentArea.contains(el)) target = el;
                            }
                            const ps = Array.from(contentArea.querySelectorAll('p[data-abs]'));
                            if (!target && ps.length > 0) {
                                const want = Number.isFinite(absolutePos) ? absolutePos : 0;
                                for (const p of ps) {
                                    const a = parseInt(p.getAttribute('data-abs') || 'NaN', 10);
                                    if (!Number.isFinite(a)) continue;
                                    if (a <= want) target = p;
                                    else break;
                                }
                                if (!target) target = ps[0];
                            }
                            if (target) {
                                scrollParagraphIntoView(target, { anchorOffset: savedAnchorOffset });
                                const abs = parseInt(target.getAttribute('data-abs') || 'NaN', 10);
                                if (Number.isFinite(abs)) {
                                    txtActiveAbsPos = abs;
                                    txtActiveAnchorId = target.id || null;
                                }
                            }
                            restoreAttempts += 1;
                            if (restoreAttempts < 10 && !target) {
                                setTimeout(tryRestore, 80);
                            } else {
                                isRestoringTxt = false;
                                updateActiveTxtTocByPos(Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : absolutePos);
                                startProgressAutoSave(openSession);
                                setTimeout(() => {
                                    if (openSession !== txtSessionId) return;
                                    schedulePersistTxtAnchorProgress('auto');
                                }, 0);
                            }
                        };
                        setTimeout(async () => {
                            await fontsReadyPromise;
                            await nextFrame();
                            await nextFrame();
                            tryRestore();
                        }, 0);
                        
                        if (txtTouchHandler) contentArea.removeEventListener('touchend', txtTouchHandler);
                        if (txtPointerHandler) contentArea.removeEventListener('pointerup', txtPointerHandler);
                        txtTouchHandler = debounce(() => {
                            if (openSession !== txtSessionId) return;
                            if (currentFlipMode === 'slide') snapSlideToPage();
                            schedulePersistTxtAnchorProgress('auto');
                        }, 200);
                        txtPointerHandler = debounce(() => {
                            if (openSession !== txtSessionId) return;
                            if (currentFlipMode === 'slide') snapSlideToPage();
                            schedulePersistTxtAnchorProgress('auto');
                        }, 200);
                        contentArea.addEventListener('touchend', txtTouchHandler, { passive: true });
                        contentArea.addEventListener('pointerup', txtPointerHandler, { passive: true });
                        attachTxtFlipGestureHandlers(openSession);

                    } catch(e) {
                         console.error(e);
                         contentArea.innerHTML = '<div style="padding:20px; color:red;">文件读取失败</div>';
                    }
                }
            }, 600);
        }
        
        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            function wrapped(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            }
            wrapped.cancel = () => {
                clearTimeout(timeout);
                timeout = null;
            };
            return wrapped;
        }

        function snapSlideToPage() {
            const content = document.getElementById('readerContent');
            if (!content) return;
            if (currentFlipMode !== 'slide') return;
            const pageWidth = content.clientWidth || 1;
            const nextLeft = Math.round(content.scrollLeft / pageWidth) * pageWidth;
            if (Math.abs(nextLeft - content.scrollLeft) < 2) return;
            content.scrollTo({ left: nextLeft, behavior: 'smooth' });
        }

        let txtScrollRaf = null;
        function attachTxtScrollHandler(session = txtSessionId) {
            const contentArea = document.getElementById('readerContent');
            if (!contentArea) return;
            if (txtScrollHandler) contentArea.removeEventListener('scroll', txtScrollHandler);
            if (txtScrollRaf) {
                try { cancelAnimationFrame(txtScrollRaf); } catch (e) {}
                txtScrollRaf = null;
            }
            txtScrollHandler = () => {
                if (session !== txtSessionId) return;
                if (currentFlipMode !== 'scroll') return;
                if (isRestoringTxt) return;
                if (isClosingReader) return;
                if (hasAnyReaderPanelOpen()) return;
                if (txtScrollRaf) return;
                txtScrollRaf = requestAnimationFrame(() => {
                    txtScrollRaf = null;
                    try {
                        const snap = getTxtProgressData();
                        if (!snap || !Number.isFinite(snap.absolutePos)) return;
                        const abs = Math.max(0, Math.min(currentTxtContent.length - 1, snap.absolutePos));
                        if (!Number.isFinite(abs)) return;
                        if (abs === txtActiveAbsPos) return;
                        txtActiveAbsPos = abs;
                        txtActiveAnchorId = txtAnchorIdForAbsPos(currentBookId, abs);
                        updateActiveTxtTocByPos(abs);
                        schedulePersistTxtAnchorProgress('auto');
                    } catch (e) {}
                });
            };
            contentArea.addEventListener('scroll', txtScrollHandler, { passive: true });
        }

        let txtPagedResizeTimer = null;
        window.addEventListener('resize', () => {
            if (!currentTxtContent) return;
            if (currentFlipMode !== 'slide' && currentFlipMode !== 'simulation') return;
            if (isRestoringTxt) return;
            if (isClosingReader) return;
            if (txtPagedResizeTimer) clearTimeout(txtPagedResizeTimer);
            txtPagedResizeTimer = setTimeout(() => {
                if (!currentTxtContent) return;
                if (currentFlipMode !== 'slide' && currentFlipMode !== 'simulation') return;
                buildTxtPagedView(currentFlipMode, Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : null);
            }, 140);
        }, { passive: true });

        function startProgressAutoSave(session = txtSessionId) {
            stopProgressAutoSave();
            progressAutoSaveTimer = setInterval(() => {
                if (session !== txtSessionId) return;
                saveTxtProgressFromView('auto');
                saveEpubProgressFromView('auto');
            }, 1200);
        }

        function stopProgressAutoSave() {
            if (progressAutoSaveTimer) {
                clearInterval(progressAutoSaveTimer);
                progressAutoSaveTimer = null;
            }
        }

        function getTxtProgressData() {
            const contentArea = document.getElementById('readerContent');
            if (!currentTxtContent || !contentArea) return null;
            const CHUNK_SIZE = 15000;
            const currentStart = parseInt(contentArea.getAttribute('data-chunk-start') || '0');
            const renderLength = parseInt(contentArea.getAttribute('data-render-length') || '0');
            const isSlide = currentFlipMode === 'slide';
            const maxScroll = isSlide
                ? (contentArea.scrollWidth - contentArea.clientWidth)
                : (contentArea.scrollHeight - contentArea.clientHeight);
            const scrollPos = isSlide ? contentArea.scrollLeft : contentArea.scrollTop;
            const scrollRatio = maxScroll > 0 ? Math.min(1, Math.max(0, scrollPos / maxScroll)) : 0;
            const paragraphs = Array.from(contentArea.querySelectorAll('p[data-pos]'));
            let target = null;
            if (isSlide) {
                const rect = contentArea.getBoundingClientRect();
                const x = rect.left + rect.width * 0.2;
                const y = rect.top + rect.height * 0.3;
                const hit = document.elementFromPoint(x, y);
                const p = hit ? hit.closest('p[data-pos]') : null;
                if (p && p.getAttribute('data-anchor') !== '1') target = p;
            } else {
                const anchorTop = contentArea.scrollTop + (maxScroll > 0 ? Math.floor(contentArea.clientHeight * 0.25) : 1);
                for (const p of paragraphs) {
                    if (p.getAttribute('data-anchor') === '1') continue;
                    if (p.offsetTop <= anchorTop) target = p;
                    else break;
                }
            }
            if (!target && paragraphs.length > 0) target = paragraphs.find(p => p.getAttribute('data-anchor') !== '1') || paragraphs[0];
            const relativePos = target ? parseInt(target.getAttribute('data-pos') || '0') : 0;
            const absolutePosByParagraph = Math.min(currentTxtContent.length - 1, currentStart + relativePos);
            const absolutePos = absolutePosByParagraph;
            const ratio = currentTxtContent.length > 0 ? (absolutePos / currentTxtContent.length) : 0;
            const percent = absolutePos > 0
                ? Math.min(100, Math.max(1, Math.round(ratio * 100)))
                : 0;
            const loadedLength = parseInt(contentArea.getAttribute('data-render-length') || '0');
            const resumeStart = Math.max(0, Math.floor(absolutePos / CHUNK_SIZE) * CHUNK_SIZE);
            return { absolutePos, percent, scrollTop: scrollPos, chunkStart: currentStart, scrollRatio, ratio, loadedLength, resumeStart };
        }

        async function saveTxtProgressFromView(reason = 'auto') {
            if (!currentBookId || !currentTxtContent) return;
            if (isRestoringTxt) return;
            if (isClosingReader && reason === 'auto') return;
            if (reason === 'auto' && hasAnyReaderPanelOpen()) return;
            const readerActive = document.getElementById('readerView').classList.contains('active');
            if (!readerActive && reason === 'auto') return;
            const contentArea = document.getElementById('readerContent');
            try {
                const snap = getTxtProgressData();
                if (snap && Number.isFinite(snap.absolutePos)) {
                    const abs = Math.max(0, Math.min(currentTxtContent.length - 1, snap.absolutePos));
                    txtActiveAbsPos = abs;
                    const id = txtAnchorIdForAbsPos(currentBookId, abs);
                    txtActiveAnchorId = id || txtActiveAnchorId;
                } else if ((!txtActiveAnchorId || !Number.isFinite(txtActiveAbsPos)) && contentArea) {
                    const first = contentArea.querySelector('p[data-abs]');
                    if (first) {
                        const abs = parseInt(first.getAttribute('data-abs') || 'NaN', 10);
                        if (Number.isFinite(abs)) {
                            txtActiveAbsPos = abs;
                            txtActiveAnchorId = first.id || null;
                        }
                    }
                }
            } catch (e) {}
            await persistTxtAnchorProgress(reason);
        }

        async function saveEpubProgressFromView(reason = 'auto') {
            if (!currentBookId || !rendition || !currentBook || !currentBook.locations) return;
            if (isClosingReader && reason === 'auto') return;
            const location = rendition.currentLocation();
            if (!location || !location.start || !location.start.cfi) return;
            const percent = currentBook.locations.percentageFromCfi(location.start.cfi);
            lastEpubProgress = { cfi: location.start.cfi, percent: Math.floor(percent * 100) };
            await storage.saveProgress(currentBookId, location.start.cfi, Math.floor(percent * 100), 0);
        }
        
        function renderTxtChunk(startPos) {
            const CHUNK_SIZE = 15000;
            const contentArea = document.getElementById('readerContent');
            const chunk = currentTxtContent.slice(startPos, startPos + CHUNK_SIZE);
            
            contentArea.setAttribute('data-chunk-start', startPos);
            contentArea.setAttribute('data-render-length', chunk.length);
            if (startPos + CHUNK_SIZE < currentTxtContent.length) {
                contentArea.setAttribute('data-next-start', startPos + CHUNK_SIZE);
            } else {
                contentArea.removeAttribute('data-next-start');
            }
            
            let pos = 0;
            const html = chunk.split('\n').map(line => {
                const currentPos = pos;
                pos += line.length + 1;
                const abs = startPos + currentPos;
                const display = String(line || '').replace(/\r$/, '');
                const id = txtAnchorIdForAbsPos(currentBookId, abs);
                return display.trim() ? `<p id="${id}" data-abs="${abs}" data-pos="${currentPos}" style="margin-bottom:16px; text-align:justify;">${escapeHtml(display)}</p>` : '';
            }).join('');
            
            contentArea.innerHTML = html;
            contentArea.scrollTop = 0;
            contentArea.scrollLeft = 0;
            let anchorRef = null;
            const topSentinel = document.createElement('div');
            topSentinel.setAttribute('data-txt-top-sentinel', '1');
            topSentinel.style.height = '1px';
            contentArea.insertAdjacentElement('afterbegin', topSentinel);
            const sentinel = document.createElement('div');
            sentinel.setAttribute('data-txt-sentinel', '1');
            sentinel.style.height = '1px';
            contentArea.appendChild(sentinel);
            
            // Add "Prev" button if not at start
            if (startPos > 0) {
                const prevBtn = document.createElement('div');
                prevBtn.style.cssText = "padding: 20px; text-align: center; color: var(--accent-purple); cursor: pointer; font-weight: bold;";
                prevBtn.innerText = "上一页";
                prevBtn.onclick = (e) => {
                    if (e && e.stopPropagation) e.stopPropagation();
                    const prevStart = Math.max(0, startPos - CHUNK_SIZE);
                    renderTxtChunk(prevStart);
                };
                topSentinel.insertAdjacentElement('afterend', prevBtn);
                anchorRef = prevBtn;
            }
        
            const anchor = document.createElement('p');
            anchor.setAttribute('data-pos', '0');
            anchor.setAttribute('data-anchor', '1');
            anchor.style.cssText = 'margin:0;height:0;';
            if (anchorRef) anchorRef.insertAdjacentElement('afterend', anchor);
            else topSentinel.insertAdjacentElement('afterend', anchor);
            observeTxtContainer();
            attachTxtScrollHandler();
        }
        
        
        function renderTxtChunkAppend(startPos) {
             const CHUNK_SIZE = 15000;
             if (startPos >= currentTxtContent.length) return;
             const container = document.getElementById('readerContent');
             
             const chunk = currentTxtContent.slice(startPos, startPos + CHUNK_SIZE);
             let pos = 0;
             const html = chunk.split('\n').map(line => {
                 const currentPos = pos;
                 pos += line.length + 1;
                 const abs = startPos + currentPos;
                 const display = String(line || '').replace(/\r$/, '');
                 const id = txtAnchorIdForAbsPos(currentBookId, abs);
                 return display.trim() ? `<p id="${id}" data-abs="${abs}" data-pos="${currentPos}" style="margin-bottom:16px; text-align:justify;">${escapeHtml(display)}</p>` : '';
             }).join('');
             
             const range = document.createRange();
             range.selectNodeContents(container);
             const fragment = range.createContextualFragment(html);
             const combined = document.createDocumentFragment();
             const anchor = document.createElement('p');
             anchor.setAttribute('data-pos', '0');
             anchor.setAttribute('data-anchor', '1');
             anchor.style.cssText = 'margin:0;height:0;';
             combined.appendChild(anchor);
             combined.appendChild(fragment);
             const sentinel = container.querySelector('[data-txt-sentinel="1"]');
             if (sentinel) {
                 container.insertBefore(combined, sentinel);
             } else {
                 container.appendChild(combined);
             }
             
             const currentLength = parseInt(container.getAttribute('data-render-length') || '0');
             container.setAttribute('data-render-length', currentLength + chunk.length);
             if (startPos + CHUNK_SIZE < currentTxtContent.length) {
                 container.setAttribute('data-next-start', startPos + CHUNK_SIZE);
             } else {
                 container.removeAttribute('data-next-start');
             }
             observeTxtContainer();
        }

        function renderTxtChunkPrepend(startPos) {
            const CHUNK_SIZE = 15000;
            if (!currentTxtContent) return;
            if (startPos < 0) return;
            const container = document.getElementById('readerContent');
            if (!container) return;
            const chunk = currentTxtContent.slice(startPos, startPos + CHUNK_SIZE);
            let pos = 0;
            const html = chunk.split('\n').map(line => {
                const currentPos = pos;
                pos += line.length + 1;
                const abs = startPos + currentPos;
                const display = String(line || '').replace(/\r$/, '');
                const id = txtAnchorIdForAbsPos(currentBookId, abs);
                return display.trim() ? `<p id="${id}" data-abs="${abs}" data-pos="${currentPos}" style="margin-bottom:16px; text-align:justify;">${escapeHtml(display)}</p>` : '';
            }).join('');
            const range = document.createRange();
            range.selectNodeContents(container);
            const fragment = range.createContextualFragment(html);
            const combined = document.createDocumentFragment();
            const anchor = document.createElement('p');
            anchor.setAttribute('data-pos', '0');
            anchor.setAttribute('data-anchor', '1');
            anchor.style.cssText = 'margin:0;height:0;';
            combined.appendChild(anchor);
            combined.appendChild(fragment);
            let topSentinel = container.querySelector('[data-txt-top-sentinel="1"]');
            if (!topSentinel) {
                topSentinel = document.createElement('div');
                topSentinel.setAttribute('data-txt-top-sentinel', '1');
                topSentinel.style.height = '1px';
                container.insertAdjacentElement('afterbegin', topSentinel);
            }
            const insertBeforeNode = topSentinel.nextSibling;
            if (insertBeforeNode) container.insertBefore(combined, insertBeforeNode);
            else container.appendChild(combined);
            const currentLength = parseInt(container.getAttribute('data-render-length') || '0');
            container.setAttribute('data-render-length', currentLength + chunk.length);
            container.setAttribute('data-chunk-start', startPos);
            observeTxtContainer();
        }

        function maybeAutoAppendTxt(force = false) {
            if (!currentTxtContent) return;
            if (isRestoringTxt) return;
            if (isClosingReader) return;
            if (hasAnyReaderPanelOpen()) return;
            const readerActive = document.getElementById('readerView').classList.contains('active');
            if (!readerActive) return;
            const container = document.getElementById('readerContent');
            if (!container) return;
            if (isAppendingTxt) return;
            const nextStart = parseInt(container.getAttribute('data-next-start') || 'NaN');
            if (!Number.isFinite(nextStart) || nextStart >= currentTxtContent.length) return;
            if (!force) {
                const distanceToBottom = container.scrollHeight - (container.scrollTop + container.clientHeight);
                if (distanceToBottom > 1000) return;
            }
            const now = Date.now();
            if (txtLastAppendStart === nextStart && (now - txtLastAppendAt) < 800) return;
            isAppendingTxt = true;
            try {
                renderTxtChunkAppend(nextStart);
                txtLastAppendStart = nextStart;
                txtLastAppendAt = now;
            } finally {
                isAppendingTxt = false;
            }
        }

        function maybeAutoPrependTxt(force = false) {
            if (!currentTxtContent) return;
            if (isRestoringTxt) return;
            if (isClosingReader) return;
            if (hasAnyReaderPanelOpen()) return;
            const readerActive = document.getElementById('readerView').classList.contains('active');
            if (!readerActive) return;
            const container = document.getElementById('readerContent');
            if (!container) return;
            if (isPrependingTxt) return;
            const CHUNK_SIZE = 15000;
            const currentStart = parseInt(container.getAttribute('data-chunk-start') || '0');
            if (!Number.isFinite(currentStart) || currentStart <= 0) return;
            const prevStart = Math.max(0, currentStart - CHUNK_SIZE);
            if (prevStart === currentStart) return;
            if (!force) {
                if (container.scrollTop > 1000) return;
            }
            const now = Date.now();
            if (txtLastPrependStart === prevStart && (now - txtLastPrependAt) < 800) return;
            const oldScrollHeight = container.scrollHeight;
            const oldScrollTop = container.scrollTop;
            isPrependingTxt = true;
            try {
                renderTxtChunkPrepend(prevStart);
                const newScrollHeight = container.scrollHeight;
                const offset = newScrollHeight - oldScrollHeight;
                container.scrollTop = oldScrollTop + offset;
                txtLastPrependStart = prevStart;
                txtLastPrependAt = now;
            } finally {
                isPrependingTxt = false;
            }
        }

        function jumpToTxtPosition(pos, tocIdx = null) {
            const session = txtSessionId;
            const readerView = document.getElementById('readerView');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            if (settingsPanel) settingsPanel.classList.remove('active');
            if (moreMenu) moreMenu.classList.remove('active');
            if (readerView) readerView.classList.add('menu-visible');
            const CHUNK_SIZE = 15000;
            const startPos = Math.max(0, Math.floor(pos / CHUNK_SIZE) * CHUNK_SIZE);
            const contentArea = document.getElementById('readerContent');
            if (contentArea && (currentFlipMode === 'slide' || currentFlipMode === 'simulation')) {
                contentArea.setAttribute('data-chunk-start', String(startPos));
                contentArea.setAttribute('data-render-length', String(Math.min(CHUNK_SIZE, currentTxtContent.length - startPos)));
                if (startPos + CHUNK_SIZE < currentTxtContent.length) contentArea.setAttribute('data-next-start', String(startPos + CHUNK_SIZE));
                else contentArea.removeAttribute('data-next-start');
                buildTxtPagedView(currentFlipMode, pos);
                closeTOC();
                if (Number.isFinite(tocIdx)) setActiveTxtTocIndex(tocIdx);
                else updateActiveTxtTocByPos(pos);
                schedulePersistTxtAnchorProgress('auto');
                return;
            }
            renderTxtChunk(startPos);
            closeTOC();
            const anchorId = txtAnchorIdForAbsPos(currentBookId, pos);
            setTimeout(() => {
                if (session !== txtSessionId) return;
                observeTxtContainer(session);
                let target = null;
                const el = document.getElementById(anchorId);
                if (el && contentArea.contains(el)) target = el;
                if (!target) {
                    const ps = Array.from(contentArea.querySelectorAll('p[data-abs]'));
                    for (const p of ps) {
                        const a = parseInt(p.getAttribute('data-abs') || 'NaN', 10);
                        if (!Number.isFinite(a)) continue;
                        if (a <= pos) target = p;
                        else break;
                    }
                    if (!target && ps.length > 0) target = ps[0];
                }
                if (target) {
                    scrollParagraphIntoView(target);
                    const abs = parseInt(target.getAttribute('data-abs') || 'NaN', 10);
                    if (Number.isFinite(abs)) {
                        txtActiveAbsPos = abs;
                        txtActiveAnchorId = target.id || null;
                    }
                }
                schedulePersistTxtAnchorProgress('auto');
            }, 0);
            if (Number.isFinite(tocIdx)) setActiveTxtTocIndex(tocIdx);
            else updateActiveTxtTocByPos(pos);
            setTimeout(() => {
                if (session !== txtSessionId) return;
                saveTxtProgressFromView('auto');
            }, 0);
        }

        function playOpenAnimation(coverEl, title) {

            const rect = coverEl.getBoundingClientRect();
            const animLayer = document.getElementById('animLayer');
            animLayer.classList.add('active');
            animLayer.innerHTML = ''; 

            const flyer = document.createElement('div');
            flyer.classList.add('flying-book');
            flyer.style.left = rect.left + 'px';
            flyer.style.top = rect.top + 'px';
            flyer.style.width = rect.width + 'px';
            flyer.style.height = rect.height + 'px';
            flyer.style.transform = 'translateZ(0) scale(0.75) rotateX(10deg)';
            
            const cover = document.createElement('div');
            cover.classList.add('flying-cover');
            cover.style.backgroundImage = coverEl.style.backgroundImage;
            cover.style.backgroundSize = coverEl.style.backgroundSize;
            cover.style.backgroundPosition = coverEl.style.backgroundPosition;
            cover.style.backgroundColor = coverEl.style.backgroundColor;
            cover.innerHTML = coverEl.innerHTML;
            
            const bgClass = Array.from(coverEl.classList).find(c => c.startsWith('cover-'));
            if (bgClass) cover.classList.add(bgClass);

            const page = document.createElement('div');
            page.classList.add('flying-page');
            page.innerHTML = `<div style="opacity:0.3; margin-top:50px;"><h2>${title}</h2><p>...</p></div>`;
            
            flyer.appendChild(page);
            flyer.appendChild(cover);
            animLayer.appendChild(flyer);

            requestAnimationFrame(() => {
                flyer.style.left = '0px';
                flyer.style.top = '0px';
                flyer.style.width = window.innerWidth + 'px';
                flyer.style.height = window.innerHeight + 'px';
                flyer.style.transform = 'translateZ(0) scale(1) rotateX(0deg)';
                flyer.classList.add('open');
            });

            setTimeout(() => {
                lockBodyScroll(true);
                document.getElementById('readerView').classList.add('active');
                setTimeout(() => {
                    animLayer.classList.remove('active');
                    animLayer.innerHTML = ''; 
                }, 950);
            }, 700); 
        }

        function playCloseAnimation(coverEl, title) {
            const rect = coverEl.getBoundingClientRect();
            const animLayer = document.getElementById('animLayer');
            animLayer.classList.add('active');
            animLayer.innerHTML = '';

            const flyer = document.createElement('div');
            flyer.classList.add('flying-book', 'open');
            flyer.style.left = '0px';
            flyer.style.top = '0px';
            flyer.style.width = window.innerWidth + 'px';
            flyer.style.height = window.innerHeight + 'px';
            flyer.style.transform = 'translateZ(0) scale(1) rotateX(0deg)';

            const cover = document.createElement('div');
            cover.classList.add('flying-cover');
            cover.style.backgroundImage = coverEl.style.backgroundImage;
            cover.style.backgroundSize = coverEl.style.backgroundSize;
            cover.style.backgroundPosition = coverEl.style.backgroundPosition;
            cover.style.backgroundColor = coverEl.style.backgroundColor;
            cover.innerHTML = coverEl.innerHTML;

            const bgClass = Array.from(coverEl.classList).find(c => c.startsWith('cover-'));
            if (bgClass) cover.classList.add(bgClass);

            const page = document.createElement('div');
            page.classList.add('flying-page');
            page.innerHTML = `<div style="opacity:0.25; margin-top:50px;"><h2>${title}</h2><p>...</p></div>`;

            flyer.appendChild(page);
            flyer.appendChild(cover);
            animLayer.appendChild(flyer);

            requestAnimationFrame(() => {
                flyer.classList.remove('open');
                flyer.style.left = rect.left + 'px';
                flyer.style.top = rect.top + 'px';
                flyer.style.width = rect.width + 'px';
                flyer.style.height = rect.height + 'px';
                flyer.style.transform = 'translateZ(0) scale(0.75) rotateX(10deg)';
            });

            return new Promise(resolve => {
                setTimeout(() => {
                    animLayer.classList.remove('active');
                    animLayer.innerHTML = '';
                    resolve();
                }, 980);
            });
        }

        function closeTOC() {
            document.getElementById('tocPanel').classList.remove('active');
            document.getElementById('tocOverlay').classList.remove('active');
        }

        function openBook(card) {
            // Replaced by openBookFromId
        }

        async function closeBook() {
            if (closeInFlight) return closeInFlight;
            isClosingReader = true;
            txtSessionId += 1;
            debugLog('closeBook start', { bookId: currentBookId });
            closeInFlight = (async () => {
                try {
                    stopProgressAutoSave();
                    try { ensureSettingsPanelMountPoint(); } catch (e) {}
                    const contentArea = document.getElementById('readerContent');
                    if (txtScrollHandler && txtScrollHandler.cancel) txtScrollHandler.cancel();
                    if (txtTouchHandler && txtTouchHandler.cancel) txtTouchHandler.cancel();
                    if (txtPointerHandler && txtPointerHandler.cancel) txtPointerHandler.cancel();
                    if (contentArea) {
                        if (txtTouchHandler) contentArea.removeEventListener('touchend', txtTouchHandler);
                        if (txtPointerHandler) contentArea.removeEventListener('pointerup', txtPointerHandler);
                    }
                    detachTxtFlipGestureHandlers();
                    const settingsPanel = document.getElementById('settingsPanel');
                    const tocPanel = document.getElementById('tocPanel');
                    const tocOverlay = document.getElementById('tocOverlay');
                    const moreMenu = document.getElementById('moreMenu');
                    const queryOverlay = document.getElementById('queryOverlay');
                    const queryPanel = document.getElementById('queryPanel');
                    const queryBtn = document.getElementById('selectionQueryBtn');
                    if (settingsPanel) settingsPanel.classList.remove('active');
                    if (tocPanel) tocPanel.classList.remove('active');
                    if (tocOverlay) tocOverlay.classList.remove('active');
                    if (moreMenu) moreMenu.classList.remove('active');
                    if (queryOverlay) queryOverlay.classList.remove('active');
                    if (queryPanel) queryPanel.classList.remove('active');
                    if (queryBtn) queryBtn.classList.remove('active');
                    await saveTxtProgressFromView('close');
                    await saveEpubProgressFromView('close');
                    teardownTxtObservers();
                    isRestoringTxt = false;
                    const readerViewEl = document.getElementById('readerView');
                    readerViewEl.classList.remove('menu-visible');
                    readerViewEl.classList.add('closing');
                    await new Promise(r => setTimeout(r, 280));
                    readerViewEl.classList.remove('active');
                    readerViewEl.classList.remove('closing');
                    lockBodyScroll(false);
                    
                    if (rendition) {
                        rendition.destroy();
                        rendition = null;
                    }
                    if (currentBook) {
                        currentBook.destroy();
                        currentBook = null;
                    }
                    debugLog('closeBook end', { bookId: currentBookId });
                } finally {
                    isClosingReader = false;
                    closeInFlight = null;
                }
            })();
            return closeInFlight;
        }

        
        // --- Reader Features ---
        let selectionQueryText = '';
        let selectionQueryFetchSeq = 0;
        const selectionQueryCache = new Map();
        let epubSelectionInfo = null;

        function hideSelectionQueryBtn() {
            const btn = document.getElementById('selectionQueryBtn');
            if (!btn) return;
            btn.classList.remove('active');
        }

        function clearQueryResult() {
            const el = document.getElementById('queryResult');
            if (!el) return;
            el.innerHTML = '';
        }

        function setQueryResultHtml(html) {
            const el = document.getElementById('queryResult');
            if (!el) return;
            el.innerHTML = html || '';
        }

        function showSelectionQueryBtnAtRect(text, rect) {
            const btn = document.getElementById('selectionQueryBtn');
            const panel = document.getElementById('queryPanel');
            const readerView = document.getElementById('readerView');
            if (!btn || !readerView) return;
            if (panel && panel.classList.contains('active')) {
                hideSelectionQueryBtn();
                return;
            }
            if (!text || !rect || hasAnyReaderPanelOpen()) {
                selectionQueryText = '';
                hideSelectionQueryBtn();
                return;
            }
            selectionQueryText = String(text || '').trim();
            if (!selectionQueryText) {
                hideSelectionQueryBtn();
                return;
            }
            const rvRect = readerView.getBoundingClientRect();
            const x = (rect.left - rvRect.left) + (rect.width || 0) / 2;
            const y = (rect.top - rvRect.top);
            const btnW = btn.offsetWidth || 56;
            const left = Math.max(8, Math.min((rvRect.width || 0) - btnW - 8, x - btnW / 2));
            const top = Math.max(8, Math.min((rvRect.height || 0) - 48, y - 42));
            btn.style.left = `${Math.round(left)}px`;
            btn.style.top = `${Math.round(top)}px`;
            btn.classList.add('active');
        }

        function getReaderSelectionInfo() {
            const readerView = document.getElementById('readerView');
            const contentArea = document.getElementById('readerContent');
            if (!readerView || !readerView.classList.contains('active')) return null;
            if (!contentArea) return null;
            const sel = window.getSelection ? window.getSelection() : null;
            if (!sel || sel.rangeCount <= 0 || sel.isCollapsed) return null;
            const text = String(sel.toString() || '').trim();
            if (!text) return null;
            const a = sel.anchorNode;
            const f = sel.focusNode;
            const aEl = a && a.nodeType === 1 ? a : (a && a.parentElement ? a.parentElement : null);
            const fEl = f && f.nodeType === 1 ? f : (f && f.parentElement ? f.parentElement : null);
            if (!aEl || !fEl) return null;
            if (!contentArea.contains(aEl) || !contentArea.contains(fEl)) return null;
            let rect = null;
            try { rect = sel.getRangeAt(0).getBoundingClientRect(); } catch (e) {}
            if (!rect || (!rect.width && !rect.height)) {
                try { rect = aEl.getBoundingClientRect(); } catch (e) {}
            }
            if (!rect) return null;
            return { text, rect };
        }

        function updateSelectionQueryBtnFromSelection() {
            const panel = document.getElementById('queryPanel');
            const readerView = document.getElementById('readerView');
            if (!readerView) return;
            if (panel && panel.classList.contains('active')) {
                hideSelectionQueryBtn();
                return;
            }
            const info = getReaderSelectionInfo() || epubSelectionInfo;
            if (!info || hasAnyReaderPanelOpen()) {
                selectionQueryText = '';
                hideSelectionQueryBtn();
                return;
            }
            showSelectionQueryBtnAtRect(info.text, info.rect);
        }

        document.addEventListener('selectionchange', () => {
            try { updateSelectionQueryBtnFromSelection(); } catch (e) {}
        }, { passive: true });

        function normalizeQueryText(text) {
            const t = String(text || '').trim().replace(/\s+/g, ' ');
            if (!t) return '';
            if (t.length > 32) return t.slice(0, 32);
            return t;
        }

        function buildQueryResultHtml(queryText, data) {
            const q = escapeHtml(queryText);
            const pinyin = data && data.pinyin ? escapeHtml(data.pinyin) : '';
            const defs = Array.isArray(data && data.definitions) ? data.definitions : [];
            const origin = data && data.origin ? escapeHtml(data.origin) : '';
            const sourceUrl = data && data.sourceUrl ? String(data.sourceUrl) : '';
            const safeUrl = sourceUrl ? escapeHtml(sourceUrl) : '';

            const defItems = defs.slice(0, 10).map((d, i) => `<div class="query-result-item">${escapeHtml(`${i + 1}. ${d}`)}</div>`).join('');
            const metaBits = [];
            if (pinyin) metaBits.push(`拼音：${pinyin}`);
            if (safeUrl) metaBits.push(`数据：<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">百度</a>`);
            const meta = metaBits.length ? metaBits.join('　') : '';

            let html = `<div class="query-result-title">${q}</div>`;
            if (meta) html += `<div class="query-result-meta">${meta}</div>`;
            if (defItems) {
                html += `<div class="query-result-section"><div class="query-result-section-title">释义</div><div class="query-result-list">${defItems}</div></div>`;
            } else {
                html += `<div class="query-result-hint">未识别到释义内容，可尝试下方链接继续查询。</div>`;
            }
            if (origin) {
                html += `<div class="query-result-section"><div class="query-result-section-title">来源</div><div class="query-result-item">${origin}</div></div>`;
            }
            return html;
        }

        function parseBaiduMobileMarkdown(markdown) {
            const contentIdx = markdown.indexOf('Markdown Content:');
            const body = contentIdx >= 0 ? markdown.slice(contentIdx + 'Markdown Content:'.length) : markdown;
            const lines = body.split(/\r?\n/).map(l => String(l || '').trim()).filter(Boolean);

            const toneLineRe = /^[a-zA-Zāáǎàēéěèīíǐìōóǒòūúǔùüǖǘǚǜńňǹḿm̀·\s-]+$/;
            let pinyin = '';
            for (const line of lines) {
                if (!toneLineRe.test(line)) continue;
                if (!/[a-zA-Z]/.test(line)) continue;
                if (line.length > 32) continue;
                pinyin = line.replace(/\s+/g, ' ').trim();
                break;
            }

            const findLineIndex = (keys) => {
                for (let i = 0; i < lines.length; i += 1) {
                    const line = lines[i];
                    for (const k of keys) {
                        if (line.includes(k)) return i;
                    }
                }
                return -1;
            };

            const defStart = findLineIndex(['释义', '解释', '基本释义', '含义']);
            const defEnd = (() => {
                if (defStart < 0) return -1;
                for (let i = defStart + 1; i < lines.length; i += 1) {
                    const l = lines[i];
                    if (l.includes('组词') || l.includes('近义') || l.includes('反义') || l.includes('相关') || l.includes('词语') || l.includes('成语')) return i;
                }
                return lines.length;
            })();

            const defLines = (defStart >= 0 && defEnd > defStart) ? lines.slice(defStart + 1, defEnd) : [];
            const defs = [];
            for (const l of defLines) {
                const m = /^\s*(\d+)\.\s*(.+)\s*$/.exec(l);
                if (m && m[2]) defs.push(m[2].trim());
            }
            if (defs.length === 0) {
                const combined = defLines.join(' ').replace(/\s+/g, ' ').trim();
                if (combined) defs.push(combined);
            }

            const originStart = findLineIndex(['出处', '来源', '词源']);
            let origin = '';
            if (originStart >= 0) {
                const chunk = lines.slice(originStart, Math.min(lines.length, originStart + 6)).join(' ').replace(/\s+/g, ' ').trim();
                origin = chunk.replace(/^(出处|来源|词源)\s*[:：]?\s*/g, '').trim();
            }

            return { pinyin, definitions: defs, origin };
        }

        async function fetchSelectionExplanation(queryText) {
            const q = normalizeQueryText(queryText);
            if (!q) return null;
            if (selectionQueryCache.has(q)) return selectionQueryCache.get(q);
            const url = `https://r.jina.ai/https://m.baidu.com/s?word=${encodeURIComponent(q + ' 拼音 释义')}`;
            const res = await fetch(url, { method: 'GET', mode: 'cors', credentials: 'omit', cache: 'no-store' });
            const text = await res.text();
            const data = parseBaiduMobileMarkdown(text);
            const out = { ...data, sourceUrl: `https://hanyu.baidu.com/s?wd=${encodeURIComponent(q)}` };
            selectionQueryCache.set(q, out);
            return out;
        }

        async function startSelectionQueryFetch(text) {
            const q = normalizeQueryText(text);
            if (!q) {
                clearQueryResult();
                return;
            }
            const seq = ++selectionQueryFetchSeq;
            setQueryResultHtml('<div class="query-result-hint">正在查询…</div>');
            try {
                const data = await fetchSelectionExplanation(q);
                if (seq !== selectionQueryFetchSeq) return;
                setQueryResultHtml(buildQueryResultHtml(q, data));
            } catch (e) {
                if (seq !== selectionQueryFetchSeq) return;
                setQueryResultHtml('<div class="query-result-hint">查询失败，可使用下方链接继续查询。</div>');
            }
        }

        function openSelectionQueryPanel() {
            const info = getReaderSelectionInfo() || epubSelectionInfo;
            const text = normalizeQueryText(selectionQueryText || (info ? info.text : '') || '');
            if (!text) return;
            selectionQueryText = text;
            const panelText = document.getElementById('queryPanelText');
            if (panelText) panelText.textContent = text;
            const overlay = document.getElementById('queryOverlay');
            const panel = document.getElementById('queryPanel');
            if (overlay) overlay.classList.add('active');
            if (panel) panel.classList.add('active');
            hideSelectionQueryBtn();
            startSelectionQueryFetch(text);
        }

        function hideSelectionQueryPanel() {
            const overlay = document.getElementById('queryOverlay');
            const panel = document.getElementById('queryPanel');
            if (overlay) overlay.classList.remove('active');
            if (panel) panel.classList.remove('active');
            try { updateSelectionQueryBtnFromSelection(); } catch (e) {}
        }

        function openSelectionQuery(kind) {
            const text = String(selectionQueryText || '').trim();
            if (!text) return;
            const q = encodeURIComponent(text);
            let url = '';
            if (kind === 'youdao') url = `https://www.youdao.com/result?word=${q}&lang=zh`;
            else if (kind === 'baidu_hanyu') url = `https://hanyu.baidu.com/s?wd=${q}`;
            else if (kind === 'baidu_baike') url = `https://baike.baidu.com/item/${q}`;
            else if (kind === 'wiki') url = `https://zh.wikipedia.org/wiki/${q}`;
            if (!url) return;
            try {
                const w = window.open(url, '_blank');
                if (!w) location.href = url;
            } catch (e) {
                location.href = url;
            }
        }

        function attachEpubInteractionHandlers(renditionInstance, session) {
            if (!renditionInstance) return;

            const tryToggle = (ev) => {
                if (session !== txtSessionId) return;
                try {
                    const target = ev && ev.target ? ev.target : null;
                    if (target && typeof target.closest === 'function') {
                        const link = target.closest('a');
                        if (link && (link.getAttribute('href') || link.getAttribute('xlink:href'))) return;
                    }
                } catch (e) {}
                toggleMenu({ event: ev, ignoreGuard: true });
            };

            try { renditionInstance.on('click', tryToggle); } catch (e) {}

            try {
                renditionInstance.on('selected', (cfiRange, contents) => {
                    if (session !== txtSessionId) return;
                    if (!contents || !contents.window) return;
                    const sel = contents.window.getSelection ? contents.window.getSelection() : null;
                    if (!sel || sel.rangeCount <= 0 || sel.isCollapsed) return;
                    const text = normalizeQueryText(sel.toString());
                    if (!text) return;
                    let rect = null;
                    try { rect = sel.getRangeAt(0).getBoundingClientRect(); } catch (e) {}
                    if (!rect) return;
                    const iframe = contents.iframe || (contents.document && contents.document.defaultView ? contents.document.defaultView.frameElement : null);
                    if (!iframe || !iframe.getBoundingClientRect) return;
                    const iframeRect = iframe.getBoundingClientRect();
                    const mergedRect = {
                        left: iframeRect.left + (rect.left || 0),
                        top: iframeRect.top + (rect.top || 0),
                        width: rect.width || 0,
                        height: rect.height || 0
                    };
                    epubSelectionInfo = { text, rect: mergedRect };
                    showSelectionQueryBtnAtRect(text, mergedRect);
                });
            } catch (e) {}

            try {
                renditionInstance.on('rendered', (section, contents) => {
                    if (session !== txtSessionId) return;
                    if (!contents || !contents.document || !contents.window) return;
                    const doc = contents.document;
                    const root = doc.documentElement;
                    if (root && root.getAttribute('data-mozi-epub-bind') === '1') return;
                    if (root) root.setAttribute('data-mozi-epub-bind', '1');

                    let startX = 0;
                    let startY = 0;
                    let startAt = 0;
                    doc.addEventListener('touchstart', (e) => {
                        if (session !== txtSessionId) return;
                        if (!e || !e.touches || !e.touches[0]) return;
                        const t = e.touches[0];
                        startX = t.clientX || 0;
                        startY = t.clientY || 0;
                        startAt = Date.now();
                    }, { passive: true });

                    doc.addEventListener('touchend', (e) => {
                        if (session !== txtSessionId) return;
                        if (!e || !e.changedTouches || !e.changedTouches[0]) return;
                        const t = e.changedTouches[0];
                        const dx = (t.clientX || 0) - startX;
                        const dy = (t.clientY || 0) - startY;
                        const dt = Math.max(1, Date.now() - startAt);
                        const click = Math.abs(dx) <= 10 && Math.abs(dy) <= 10 && dt <= 550;
                        if (!click) return;
                        tryToggle(e);
                    }, { passive: true });

                    doc.addEventListener('selectionchange', () => {
                        if (session !== txtSessionId) return;
                        try {
                            const sel = contents.window.getSelection ? contents.window.getSelection() : null;
                            const txt = sel ? normalizeQueryText(sel.toString()) : '';
                            if (!txt) {
                                epubSelectionInfo = null;
                                if (!hasAnyReaderPanelOpen()) hideSelectionQueryBtn();
                            }
                        } catch (e) {}
                    });
                });
            } catch (e) {}
        }

        function shouldIgnoreMenuToggleTarget(target) {
            if (!target) return false;
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const queryPanel = document.getElementById('queryPanel');
            const queryOverlay = document.getElementById('queryOverlay');
            const queryBtn = document.getElementById('selectionQueryBtn');
            const tocButton = document.getElementById('tocButton');
            const settingsButton = document.getElementById('settingsButton');
            const moreButton = document.getElementById('moreButton');
            const closeButton = document.getElementById('closeButton');
            if (tocPanel && tocPanel.contains(target)) return true;
            if (tocOverlay && tocOverlay.contains(target)) return true;
            if (settingsPanel && settingsPanel.contains(target)) return true;
            if (moreMenu && moreMenu.contains(target)) return true;
            if (queryPanel && queryPanel.contains(target)) return true;
            if (queryOverlay && queryOverlay.contains(target)) return true;
            if (queryBtn && queryBtn.contains(target)) return true;
            if (tocButton && tocButton.contains(target)) return true;
            if (settingsButton && settingsButton.contains(target)) return true;
            if (moreButton && moreButton.contains(target)) return true;
            if (closeButton && closeButton.contains(target)) return true;
            const topBar = document.querySelector('.reader-top-bar');
            const bottomBar = document.querySelector('.reader-bottom-bar');
            if (topBar && topBar.contains(target)) return true;
            if (bottomBar && bottomBar.contains(target)) return true;
            return false;
        }

        function handleReaderContentClick(e) {
            if (Date.now() < suppressNextContentClickUntil) return;
            toggleMenu({ event: e });
        }

        function toggleMenu(options = null) {
            const ignoreGuard = !!(options && options.ignoreGuard);
            const eventTarget = options && options.event ? options.event.target : null;
            const target = eventTarget || lastPointerTarget;
            if (!ignoreGuard && shouldIgnoreMenuToggleTarget(target)) return;
            if (!ignoreGuard && (Date.now() - lastFlipGestureAt) < 320) return;
            const reader = document.getElementById('readerView');
            // Close panels if open
            const settings = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const queryOverlay = document.getElementById('queryOverlay');
            const queryPanel = document.getElementById('queryPanel');
            
            if (settings.classList.contains('active')) {
                settings.classList.remove('active');
                try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
                return;
            }
            if (moreMenu.classList.contains('active')) {
                moreMenu.classList.remove('active');
                return;
            }
            if (tocPanel.classList.contains('active')) {
                tocPanel.classList.remove('active');
                tocOverlay.classList.remove('active');
                return;
            }
            if ((queryOverlay && queryOverlay.classList.contains('active')) || (queryPanel && queryPanel.classList.contains('active'))) {
                hideSelectionQueryPanel();
                return;
            }
            
            reader.classList.toggle('menu-visible');
        }
        
        function toggleNightMode() {
            const body = document.body;
            const icon = document.getElementById('nightModeIcon');
            const text = document.getElementById('nightModeText');
            
            body.classList.toggle('night-mode');
            
            if (body.classList.contains('night-mode')) {
                // Change to Sun icon
                icon.innerHTML = '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>';
                text.innerText = "日间";
            } else {
                // Change to Moon icon
                icon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>';
                text.innerText = "夜间";
            }
        }
        
        function toggleSettings() {
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            try {
                const settingsButton = document.getElementById('settingsButton');
                if (settingsButton && lastPointerTarget && !settingsButton.contains(lastPointerTarget)) return;
            } catch (e) {}
            const panel = document.getElementById('settingsPanel');
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const moreMenu = document.getElementById('moreMenu');
            const reader = document.getElementById('readerView');
            if (tocPanel) tocPanel.classList.remove('active');
            if (tocOverlay) tocOverlay.classList.remove('active');
            if (moreMenu) moreMenu.classList.remove('active');
            if (reader) reader.classList.add('menu-visible');
            panel.classList.toggle('active');
            try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
        }
        
        function toggleMoreMenu() {
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            const moreMenu = document.getElementById('moreMenu');
            const tocPanel = document.getElementById('tocPanel');
            const tocOverlay = document.getElementById('tocOverlay');
            const settingsPanel = document.getElementById('settingsPanel');
            const reader = document.getElementById('readerView');
            if (tocPanel) tocPanel.classList.remove('active');
            if (tocOverlay) tocOverlay.classList.remove('active');
            if (settingsPanel) settingsPanel.classList.remove('active');
            try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
            if (reader) reader.classList.add('menu-visible');
            moreMenu.classList.toggle('active');
        }
        
        function setReaderTheme(theme, el) {
            const body = document.body;
            body.classList.remove('night-mode'); // Reset
            
            // UI Selection State
            document.querySelectorAll('.theme-circle').forEach(c => c.classList.remove('active'));
            el.classList.add('active');
            
            if (theme === 'dark') {
                body.classList.add('night-mode');
            } else if (theme === 'sepia') {
                document.documentElement.style.setProperty('--reader-bg', '#f4ecd8');
                document.documentElement.style.setProperty('--reader-text', '#5b4636');
                document.documentElement.style.setProperty('--reader-menu-bg', '#f4ecd8');
                document.documentElement.style.setProperty('--reader-menu-text', '#5b4636');
            } else if (theme === 'green') {
                document.documentElement.style.setProperty('--reader-bg', '#dcedc8');
                document.documentElement.style.setProperty('--reader-text', '#33691e');
                document.documentElement.style.setProperty('--reader-menu-bg', '#dcedc8');
                document.documentElement.style.setProperty('--reader-menu-text', '#33691e');
            } else {
                // White/Default
                document.documentElement.style.removeProperty('--reader-bg');
                document.documentElement.style.removeProperty('--reader-text');
                document.documentElement.style.removeProperty('--reader-menu-bg');
                document.documentElement.style.removeProperty('--reader-menu-text');
            }
        }
        
        function updateFontSize(val) {
            document.documentElement.style.setProperty('--reader-font-size', val + 'px');
            document.getElementById('fontSizeDisplay').innerText = val;
            try {
                invalidateTxtCharsPerPage();
                if (currentTxtContent) {
                    if (currentFlipMode === 'slide') buildTxtPagedView('slide', Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : null);
                    else updatePageIndicatorByTxtPos(txtActiveAbsPos);
                }
                updateReaderBottomSheetOffset();
            } catch (e) {}
        }
        
        function updateLineHeight(val) {
            document.documentElement.style.setProperty('--reader-line-height', val / 10);
            try {
                invalidateTxtCharsPerPage();
                if (currentTxtContent) {
                    if (currentFlipMode === 'slide') buildTxtPagedView('slide', Number.isFinite(txtActiveAbsPos) ? txtActiveAbsPos : null);
                    else updatePageIndicatorByTxtPos(txtActiveAbsPos);
                }
                updateReaderBottomSheetOffset();
            } catch (e) {}
        }
        
        function toggleToc() {
            try { ensureSettingsPanelMountPoint(); } catch (e) {}
            const panel = document.getElementById('tocPanel');
            const overlay = document.getElementById('tocOverlay');
            const settingsPanel = document.getElementById('settingsPanel');
            const moreMenu = document.getElementById('moreMenu');
            const reader = document.getElementById('readerView');
            const willOpen = !panel.classList.contains('active');
            if (settingsPanel) settingsPanel.classList.remove('active');
            try { updateReaderBottomSheetOffset(); setTimeout(updateReaderBottomSheetOffset, 260); } catch (e) {}
            if (moreMenu) moreMenu.classList.remove('active');
            if (willOpen && reader) reader.classList.add('menu-visible');
            panel.classList.toggle('active');
            overlay.classList.toggle('active');
            if (willOpen && currentTxtTocActiveIndex >= 0) {
                const active = document.querySelector(`.toc-item[data-toc-index="${currentTxtTocActiveIndex}"]`);
                if (active) active.scrollIntoView({ block: 'center' });
            }
        }
        
        function jumpToChapter(idx) {
            const el = document.getElementById('chap-' + idx);
            if(el) {
                el.scrollIntoView({ behavior: 'smooth' });
                toggleToc(); // Close menu
                toggleMenu({ ignoreGuard: true }); // Hide bars for immersion
            }
        }
        
        function scrollPage(direction) {
            const content = document.getElementById('readerContent');
            if (!content) return;
            const cs = window.getComputedStyle(content);
            const padT = parseFloat(cs.paddingTop || '0') || 0;
            const padB = parseFloat(cs.paddingBottom || '0') || 0;
            const visibleH = Math.max(160, (content.clientHeight || window.innerHeight) - padT - padB);
            const amount = visibleH * 0.92;
            const nextTop = (content.scrollTop || 0) + amount * direction;
            content.scrollTo({ top: nextTop, behavior: 'smooth' });
        }

    </script>

</body>
</html>
</toolcall_result>
